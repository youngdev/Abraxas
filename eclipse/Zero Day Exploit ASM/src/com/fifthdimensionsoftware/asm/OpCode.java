package com.fifthdimensionsoftware.asm;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.LinkedList;

import com.fifthdimensionsoftware.asm.types.GENERIC;
import com.fifthdimensionsoftware.asm.types.IMM;
import com.fifthdimensionsoftware.asm.types.MEM;
import com.fifthdimensionsoftware.asm.types.REG;
import com.fifthdimensionsoftware.asm.types.STR;

public enum OpCode
{
	MOV (ArgTypes.REG, ArgTypes.ARG),
	MVN (ArgTypes.REG, ArgTypes.ARG),
	AND (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	ORR (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	EOR (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	BIC (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	ADD (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	SUB (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	RSB (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	CMP (ArgTypes.REG, ArgTypes.ARG),
	CMN (ArgTypes.REG, ArgTypes.ARG),
	MUL (ArgTypes.REG, ArgTypes.REG, ArgTypes.REG),
	MLA (ArgTypes.REG, ArgTypes.REG, ArgTypes.REG, ArgTypes.REG),
	BL (ArgTypes.IMM),
	BX (ArgTypes.REG),
	B (ArgTypes.IMM),
	SWI (ArgTypes.IMM),
	LDR (ArgTypes.ARG, ArgTypes.MEM),
	STR (ArgTypes.ARG, ArgTypes.MEM),
	SWP (ArgTypes.REG, ArgTypes.REG, ArgTypes.MEM),
	NOP (false),
	LSL (false, ArgTypes.IMM),
	LSR (false, ArgTypes.IMM),
	ASR (false, ArgTypes.IMM),
	RET (),
	SET (ArgTypes.STR, ArgTypes.MEM),
	GET (ArgTypes.STR, ArgTypes.MEM),
	LEV (ArgTypes.ARG, ArgTypes.ARG, ArgTypes.ARG),
	PUSH (ArgTypes.ARG),
	POP (ArgTypes.REG),
	PEEK (ArgTypes.REG);
	
	public int argLength;
	public boolean conditionCode;
	public ArgTypes[] args = {};
	
	private OpCode(boolean codeParam, ArgTypes...argTypes)
	{
		this.argLength = argTypes.length;
		this.conditionCode = codeParam;
		this.args = argTypes;
	}
	
	private OpCode(ArgTypes...argTypes)
	{
		this.argLength = argTypes.length;
		this.conditionCode = true;
		this.args = argTypes;
	}
	
	public static OpCode getCodeForString(String code)
	{
		code = code.toUpperCase();
		for(OpCode opCode : OpCode.values())
		{
			try {
				String tmpCode = code.substring(0, opCode.name().length());
				if(opCode.name().equals(tmpCode))
					return opCode;
			} catch (StringIndexOutOfBoundsException e) 
			{
				continue;
			}
		}
		
		return OpCode.NOP;
	}
	
	public static void verifySanity()
	{
		ArrayList<String> methodList = new ArrayList<String>();
		for(Method method : OpCodeFunctions.class.getDeclaredMethods())
		{
			methodList.add(method.getName());
		}
		
		for(OpCode code : OpCode.values())
		{
			if(!methodList.contains(code.name()))
				ArmCore.logEvent(true, false, "ERROR", code.name() + " does not have a method bound!");
		}
	}
	
	public void preformCode(ConditionCode code, Object...args)
	{
		if (code.getCodeResult()) {
			@SuppressWarnings("rawtypes")
			Class[] argTypes = new Class[args.length];
			int loop = 0;
			for (Object arg : args) {
				argTypes[loop] = arg.getClass();
				loop++;
			}
			try {
				Method renderMethod = OpCodeFunctions.class.getDeclaredMethod(
						this.name(), argTypes);
				renderMethod.setAccessible(true);
				renderMethod.invoke(ClassLoader.getSystemClassLoader(), args);
			} catch (SecurityException | IllegalAccessException
					| IllegalArgumentException | InvocationTargetException
					| NoSuchMethodException e) {
				System.err.println("[ARMCORE] Caught exception while reflecting into opcode");
				e.printStackTrace();
			}
		}
	}
	
	public Object[] resolveArguments(String...data)
	{
		LinkedList<Object> toReturn = new LinkedList<Object>();
		
		int loop = 0;
		for(ArgTypes argType : this.args)
		{
			switch(argType.name())
			{
			case "REG":
				toReturn.add(new REG(data[loop]));
				break;
			case "ARG":
				toReturn.add(new GENERIC(data[loop]));
				break;
			case "MEM":
				toReturn.add(new MEM(data[loop]));
				break;
			case "IMM":
				toReturn.add(new IMM(data[loop]));
				break;
			case "STR":
				toReturn.add(new STR(data[loop]));
				break;
			}
			loop++;
		}
		
		return toReturn.toArray();
	}
}
enum ConditionCode
{
	AL,
	EQ,
	NE,
	MI,
	PL,
	LT,
	GT,
	LE;
	
	public static ConditionCode getCode(String code)
	{
		code = code.toUpperCase();
		OpCode opCode = OpCode.getCodeForString(code);
		if (opCode.conditionCode)
		{
			try {
				return ConditionCode.valueOf(code.substring(opCode.name().length(),
						opCode.name().length() + 2));
			} catch (StringIndexOutOfBoundsException | IllegalArgumentException e) {
				return AL;
			}
		} else
			return AL;
	}
	
	public boolean getCodeResult()
	{
		try {
			Method renderMethod = ConditionCodeFunctions.class.getDeclaredMethod(this.name(), new Class[]{});
			renderMethod.setAccessible(true);
			return (Boolean)renderMethod.invoke(ClassLoader.getSystemClassLoader(), new Object[]{});
		} catch (SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException e) 
		{
			System.err.println("[ARMCORE] Caught exception while reflecting into condition code");
		}
		return true;
	}
}
enum ArgTypes
{
	REG ("^R\\d?\\d"),
	MEM ("^\\[.+\\]$"),
	IMM ("^#\\d+"),
	STR ("\\\".+\\\""),
	VAR ("\\^.+"),
	ARG (".+"),
	;
	
	private String regex = "";
	
	private ArgTypes(String regParam)
	{
		this.regex = regParam;
	}
	
	public boolean verifyType(String arg)
	{
		return arg.matches(this.regex);
	}
}
class ConditionCodeFunctions
{
	public static boolean AL()
	{
		return true;
	}
	
	public static boolean EQ()
	{
		return ArmCore.getInstance().cmpOne - ArmCore.getInstance().cmpTwo == 0;
	}
	
	public static boolean NE()
	{
		return !EQ();
	}
	
	public static boolean MI()
	{
		return ArmCore.getInstance().cmpOne - ArmCore.getInstance().cmpTwo < 0;
	}
	
	public static boolean PL()
	{
		return !MI();
	}
	
	public static boolean LT()
	{
		return MI();
	}
	
	public static boolean GT()
	{
		return ArmCore.getInstance().cmpOne - ArmCore.getInstance().cmpTwo > 0;
	}
	
	public static boolean LE()
	{
		return ArmCore.getInstance().cmpOne - ArmCore.getInstance().cmpTwo <= 0;
	}
}
class OpCodeFunctions
{
	public static void MOV(REG register, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "MOV", "Moving " + argument.resolveString().toLowerCase() + " to register R"+register.registerID());
		ArmCore.getInstance().setRegister(register.registerID(), argument.resolveArgument());
	}
	
	public static void MVN(REG register, GENERIC argument)
	{
		int resolvedInt = ~argument.resolveArgument();
		
		ArmCore.logEvent(false, true, "MVN", "Moving " + resolvedInt + " to register R"+register.registerID());
		ArmCore.getInstance().setRegister(register.registerID(), resolvedInt);
	}
	
	public static void AND(REG resultRegister, REG argRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "AND", "Updated R" + resultRegister.registerID() + " with " + (argRegister.resolveArgument() & argument.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argRegister.resolveArgument() & argument.resolveArgument()));
	}
	
	public static void ORR(REG resultRegister, REG argRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "ORR", "Updated R" + resultRegister.registerID() + " with " + (argRegister.resolveArgument() | argument.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argRegister.resolveArgument() | argument.resolveArgument()));
	}
	
	public static void EOR(REG resultRegister, REG argRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "EOR", "Updated R" + resultRegister.registerID() + " with " + (argRegister.resolveArgument() ^ argument.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argRegister.resolveArgument() ^ argument.resolveArgument()));
	}
	
	public static void BIC(REG resultRegister, REG argRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "BIC", "Updated R" + resultRegister.registerID() + " with " + ~(argRegister.resolveArgument() & argument.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), ~(argRegister.resolveArgument() & argument.resolveArgument()));
	}
	
	public static void ADD(REG resultRegister, REG argRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "ADD", "Updated R" + resultRegister.registerID() + " with " + (argRegister.resolveArgument() + argument.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argRegister.resolveArgument() + argument.resolveArgument()));
	}
	
	public static void SUB(REG resultRegister, REG argRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "SUB", "Updated R" + resultRegister.registerID() + " with " + (argRegister.resolveArgument() - argument.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argRegister.resolveArgument() - argument.resolveArgument()));
	}
	
	public static void RSB(REG resultRegister, REG argRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "RSB", "Updated R" + resultRegister.registerID() + " with " + (argument.resolveArgument() - argRegister.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argument.resolveArgument() - argRegister.resolveArgument()));
	}
	
	public static void CMP(REG resultRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "CMP", "Condion codes updated with " + resultRegister.resolveArgument() + " and " + argument.resolveArgument());
		ArmCore.getInstance().cmpOne = resultRegister.resolveArgument();
		ArmCore.getInstance().cmpTwo = argument.resolveArgument();
	}
	
	public static void CMN(REG resultRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "CMN", "Condion codes updated with " + resultRegister.resolveArgument() + " and " + -argument.resolveArgument());
		ArmCore.getInstance().cmpOne = resultRegister.resolveArgument();
		ArmCore.getInstance().cmpTwo = -argument.resolveArgument();
	}
	
	public static void MUL(REG resultRegister, REG argRegister, REG argument)
	{
		ArmCore.logEvent(false, true, "MUL", "Updated R" + resultRegister.registerID() + " with " + (argRegister.resolveArgument() * argument.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argRegister.resolveArgument() * argument.resolveArgument()));
	}
	
	public static void MLA(REG resultRegister, REG argRegister, REG argument, REG strangeReg)
	{
		ArmCore.logEvent(false, true, "MLA", "Updated R" + resultRegister.registerID() + " with " + (argRegister.resolveArgument() * argument.resolveArgument() + strangeReg.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argRegister.resolveArgument() * argument.resolveArgument() + strangeReg.resolveArgument()));
	}
	
	public static void SET(STR varName, GENERIC value)
	{
		ArmCore.logEvent(false, true, "SET", "Updated variable " + varName.resolveString() + " with " + value.resolveString());
		ArmCore.getInstance().setVar(varName.resolveString(), value);
	}
	
	public static void GET(STR varName, MEM memoryStart)
	{
		GENERIC value = ArmCore.getInstance().getVar(varName.resolveString());
		if(value.isString())
		{
			ArmCore.logEvent(false, true, "GET", "Loaded string " + value.resolveString() + " to address " + memoryStart.resolveAddress());
			ArmCore.getInstance().loadStringToMemory(value.resolveString(), memoryStart.resolveAddress());
		}else
		{
			ArmCore.logEvent(false, true, "GET", "Loaded " + value.resolveString() + " to address " + memoryStart.resolveAddress());
			ArmCore.getInstance().setMemory(memoryStart.resolveAddress(), value.resolveArgument());
		}
	}
	
	public static void B(IMM jmpAddr)
	{
		ArmCore.logEvent(false, true, "B", "Jumping to "+jmpAddr.resolveArgument());
		ArmCore.getInstance().setExecutionLoc(jmpAddr.resolveArgument());
	}
	
	public static void BNOLOG(IMM jmpAddr)
	{
		//ArmCore.logEvent(false, true, "B", "Jumping to "+jmpAddr.resolveArgument());
		ArmCore.getInstance().setExecutionLoc(jmpAddr.resolveArgument());
	}
	
	public static void BL(IMM jmpAddr)
	{
		ArmCore.logEvent(false, true, "BL", "Jumping to "+jmpAddr.resolveArgument()+", will return to "+ArmCore.getInstance().getExecutionLoc());
		ArmCore.getInstance().setRet(ArmCore.getInstance().getExecutionLoc());
		BNOLOG(jmpAddr);
	}
	
	public static void BX(REG register)
	{
		ArmCore.logEvent(false, true, "BX", "Setting return point to "+register.resolveArgument());
		ArmCore.getInstance().setRet(register.resolveArgument());
	}
	
	public static void SWI(IMM value)
	{
		ArmCore.logEvent(false, true, "SWI", "Calling interrupt "+value.resolveArgument());
		ArmCore.getInstance().interrupt(value.resolveArgument());
	}
	
	public static void RET()
	{
		ArmCore.logEvent(false, true, "RET", "Returning to "+ArmCore.getInstance().getRet());
		BNOLOG(new IMM("#"+ArmCore.getInstance().getRet()));
	}
	
	public static void SWP(REG d, REG m, MEM n)
	{
		ArmCore.logEvent(false, true, "SWP", "R"+m.registerID() + " --> [" + n.resolveAddress() + "] --> R" + d.registerID());
		ArmCore.getInstance().setRegister(d.registerID(), n.resolveArgument());
		ArmCore.getInstance().setMemory(n.resolveAddress(), m.resolveArgument());
	}
	
	public static void LDR(GENERIC string, MEM m)
	{
		ArmCore.getInstance().setVar(string.resolveString(), new GENERIC(("\""+ArmCore.getInstance().unloadStringFromMemory(m.resolveAddress()) + "\"").trim()));
		ArmCore.logEvent(false, true, "LDR", "Loaded \""+ArmCore.getInstance().getVar(string.resolveString()).resolveString().trim() + "\" into " + string.resolveString());
	}
	
	public static void STR(GENERIC string, MEM m)
	{
		ArmCore.getInstance().loadStringToMemory(string.resolveString(), m.resolveAddress());
		ArmCore.logEvent(false, true, "STR", "Stored " + string.resolveString() + " to [" + m.resolveAddress() + "]");
	}
	
	public static void LEV(GENERIC start, GENERIC end, GENERIC lev)
	{
		ArmCore.logEvent(false, true, "LEV", (ArmCore.getInstance().hasAccess(ArmCore.getInstance().getExecutionLoc(), start.resolveArgument()) ? "Updated " : "Did not update ") + "the security level for locations "+start.resolveArgument() + " through "+end.resolveArgument());
		ArmCore.getInstance().setAccessLevel(start.resolveArgument(), end.resolveArgument(), (byte)lev.resolveArgument());
	}
	
	public static void NOP()
	{
		//Dummy method, its supposed to do nothing
	}
	
	public static void PUSH(GENERIC value)
	{
		ArmCore.logEvent(false, true, "PUSH", "Pushed "+value.resolveArgument()+" to the stack");
		ArmCore.getInstance().globalStack.push(value.resolveArgument());
	}
	
	public static void POP(REG reg)
	{
		ArmCore.logEvent(false, true, "POP", "Popped "+ArmCore.getInstance().globalStack.peek()+" from the stack and into register "+reg.registerID());
		ArmCore.getInstance().setRegister(reg.registerID(), ArmCore.getInstance().globalStack.pop());
	}
	
	public static void PEEK(REG reg)
	{
		ArmCore.logEvent(false, true, "PEEK", "Peeked at the stack and placed " + ArmCore.getInstance().globalStack.peek() + " into register " + reg.registerID());
		ArmCore.getInstance().setRegister(reg.registerID(), ArmCore.getInstance().globalStack.peek());
	}
}
