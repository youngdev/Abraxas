package com.fifthdimensionsoftware.asm;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.LinkedList;

import com.fifthdimensionsoftware.asm.types.BIGVAL;
import com.fifthdimensionsoftware.asm.types.GENERIC;
import com.fifthdimensionsoftware.asm.types.IMM;
import com.fifthdimensionsoftware.asm.types.MEM;
import com.fifthdimensionsoftware.asm.types.REG;
import com.fifthdimensionsoftware.asm.types.STR;

public enum OpCode
{
	MOV (ArgTypes.REG, ArgTypes.ARG),
	MVN (ArgTypes.REG, ArgTypes.ARG),
	AND (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	ORR (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	EOR (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	BIC (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	ADD (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	SUB (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	RSB (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	CMP (ArgTypes.REG, ArgTypes.ARG),
	CMN (ArgTypes.REG, ArgTypes.ARG),
	MUL (ArgTypes.REG, ArgTypes.REG, ArgTypes.REG),
	MLA (ArgTypes.REG, ArgTypes.REG, ArgTypes.REG, ArgTypes.REG),
	BL (ArgTypes.MEM),
	BX (ArgTypes.ARG),
	B (ArgTypes.MEM),
	SWI (ArgTypes.IMM),
	LDR (ArgTypes.ARG, ArgTypes.MEM),
	STR (ArgTypes.ARG, ArgTypes.MEM),
	SWP (ArgTypes.REG, ArgTypes.REG, ArgTypes.MEM),
	NOP (false),
	LSL (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	LSR (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	ASR (ArgTypes.REG, ArgTypes.REG, ArgTypes.ARG),
	RET,
	SET (ArgTypes.STR, ArgTypes.ARG),
	GET (ArgTypes.STR, ArgTypes.MEM),
	LEV (ArgTypes.ARG, ArgTypes.ARG, ArgTypes.ARG),
	PUSH (ArgTypes.ARG),
	POP (ArgTypes.REG),
	PEEK (ArgTypes.REG),
	LBL (ArgTypes.STR, ArgTypes.ARG),
	HLT,
	LOCK (ArgTypes.STR, ArgTypes.ARG),
	INT (Byte.MAX_VALUE, ArgTypes.IMM),
	REG (ArgTypes.IMM, ArgTypes.MEM),
	QNTM (ArgTypes.ARG, ArgTypes.IMM),
	;
	
	public int argLength, level = -1;
	public boolean conditionCode;
	public ArgTypes[] args = {};
	
	private OpCode(boolean codeParam, ArgTypes...argTypes)
	{
		this.argLength = argTypes.length;
		this.conditionCode = codeParam;
		this.args = argTypes;
	}
	
	private OpCode(ArgTypes...argTypes)
	{
		this.argLength = argTypes.length;
		this.conditionCode = true;
		this.args = argTypes;
	}
	
	private OpCode(int baseLevel, ArgTypes...argTypes)
	{
		this.argLength = argTypes.length;
		this.conditionCode = true;
		this.args = argTypes;
		this.level = baseLevel;
	}
	
	public static OpCode getCodeForString(String code)
	{
		code = code.toUpperCase();
		for(OpCode opCode : OpCode.values())
		{
			try {
				String tmpCode = code.substring(0, opCode.name().length());
				if(opCode.name().equals(tmpCode))
					return opCode;
			} catch (StringIndexOutOfBoundsException e) 
			{
				continue;
			}
		}
		
		return OpCode.NOP;
	}
	
	public static void verifySanity()
	{
		ArrayList<String> methodList = new ArrayList<String>();
		for(Method method : OpCodeFunctions.class.getDeclaredMethods())
		{
			methodList.add(method.getName());
		}
		
		for(OpCode code : OpCode.values())
		{
			if(!methodList.contains(code.name()))
				ArmCore.logEvent(true, false, "ERROR", code.name() + " does not have a method bound!");
		}
	}
	
	public void preformCode(ConditionCode code, Object...args)
	{
		if (code.getCodeResult() && (ArmCore.getInstance().getSecurityAt(ArmCore.getInstance().getExecutionLoc()) >= this.level || this.level == -1)) {
			Class<?>[] argTypes = new Class<?>[args.length];
			int loop = 0;
			for (Object arg : args) {
				argTypes[loop] = arg.getClass();
				loop++;
			}
			try {
				Method renderMethod = OpCodeFunctions.class.getDeclaredMethod(
						this.name(), argTypes);
				renderMethod.setAccessible(true);
				renderMethod.invoke(ClassLoader.getSystemClassLoader(), args);
			} catch (SecurityException | IllegalAccessException
					| IllegalArgumentException | InvocationTargetException
					| NoSuchMethodException e) {
				System.err.println("[ARMCORE] Caught exception while reflecting into opcode");
				e.printStackTrace();
			}
		}
	}
	
	public Object[] resolveArguments(String...data)
	{
		LinkedList<Object> toReturn = new LinkedList<Object>();
		
		int loop = 0;
		for(ArgTypes argType : this.args)
		{
			switch(argType.name())
			{
			case "REG":
				toReturn.add(new REG(data[loop]));
				break;
			case "ARG":
				toReturn.add(new GENERIC(data[loop]));
				break;
			case "MEM":
				toReturn.add(new MEM(data[loop]));
				break;
			case "IMM":
				toReturn.add(new IMM(data[loop]));
				break;
			case "STR":
				toReturn.add(new STR(data[loop]));
				break;
			case "BIGVAL":
				toReturn.add(new BIGVAL(data[loop]));
				break;
			}
			loop++;
		}
		
		return toReturn.toArray();
	}
	
	public void setExecutionRestriction(int newLevel)
	{
		this.level = newLevel;
	}
}
enum ConditionCode
{
	AL,
	EQ,
	NE,
	MI,
	PL,
	LT,
	GT,
	LE;
	
	public static ConditionCode getCode(String code)
	{
		code = code.toUpperCase();
		OpCode opCode = OpCode.getCodeForString(code);
		if (opCode.conditionCode)
		{
			try {
				return ConditionCode.valueOf(code.substring(opCode.name().length(),
						opCode.name().length() + 2));
			} catch (StringIndexOutOfBoundsException | IllegalArgumentException e) {
				return AL;
			}
		} else
			return AL;
	}
	
	public boolean getCodeResult()
	{
		try {
			Method renderMethod = ConditionCodeFunctions.class.getDeclaredMethod(this.name(), new Class[]{});
			renderMethod.setAccessible(true);
			return (Boolean)renderMethod.invoke(ClassLoader.getSystemClassLoader(), new Object[]{});
		} catch (SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException e) 
		{
			System.err.println("[ARMCORE] Caught exception while reflecting into condition code");
		}
		return true;
	}
}
enum ArgTypes
{
	REG ("^R\\d?\\d"),
	MEM ("^\\[.+\\]$"),
	IMM ("^#\\d+"),
	STR ("\\\".+\\\""),
	VAR ("\\^.+"),
	BIGVAL ("^L.+"),
	ARG (".+"),
	;
	
	private String regex = "";
	
	private ArgTypes(String regParam)
	{
		this.regex = regParam;
	}
	
	public boolean verifyType(String arg)
	{
		return arg.matches(this.regex);
	}
}
class ConditionCodeFunctions
{
	public static boolean AL()
	{
		return true;
	}
	
	public static boolean EQ()
	{
		return ArmCore.getInstance().cmpOne - ArmCore.getInstance().cmpTwo == 0;
	}
	
	public static boolean NE()
	{
		return !EQ();
	}
	
	public static boolean MI()
	{
		return ArmCore.getInstance().cmpOne - ArmCore.getInstance().cmpTwo < 0;
	}
	
	public static boolean PL()
	{
		return !MI();
	}
	
	public static boolean LT()
	{
		return MI();
	}
	
	public static boolean GT()
	{
		return ArmCore.getInstance().cmpOne - ArmCore.getInstance().cmpTwo > 0;
	}
	
	public static boolean LE()
	{
		return ArmCore.getInstance().cmpOne - ArmCore.getInstance().cmpTwo <= 0;
	}
}
class OpCodeFunctions
{
	public static void MOV(REG register, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "MOV", "Moving " + argument.resolveString().toLowerCase() + " to register R"+register.registerID());
		ArmCore.getInstance().setRegister(register.registerID(), argument.resolveArgument());
	}
	
	public static void MVN(REG register, GENERIC argument)
	{
		int resolvedInt = ~argument.resolveArgument();
		
		ArmCore.logEvent(false, true, "MVN", "Moving " + resolvedInt + " to register R"+register.registerID());
		ArmCore.getInstance().setRegister(register.registerID(), resolvedInt);
	}
	
	public static void AND(REG resultRegister, REG argRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "AND", "Updated R" + resultRegister.registerID() + " with " + (argRegister.resolveArgument() & argument.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argRegister.resolveArgument() & argument.resolveArgument()));
	}
	
	public static void ORR(REG resultRegister, REG argRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "ORR", "Updated R" + resultRegister.registerID() + " with " + (argRegister.resolveArgument() | argument.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argRegister.resolveArgument() | argument.resolveArgument()));
	}
	
	public static void EOR(REG resultRegister, REG argRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "EOR", "Updated R" + resultRegister.registerID() + " with " + (argRegister.resolveArgument() ^ argument.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argRegister.resolveArgument() ^ argument.resolveArgument()));
	}
	
	public static void BIC(REG resultRegister, REG argRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "BIC", "Updated R" + resultRegister.registerID() + " with " + ~(argRegister.resolveArgument() & argument.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), ~(argRegister.resolveArgument() & argument.resolveArgument()));
	}
	
	public static void ADD(REG resultRegister, REG argRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "ADD", "Updated R" + resultRegister.registerID() + " with " + (argRegister.resolveArgument() + argument.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argRegister.resolveArgument() + argument.resolveArgument()));
	}
	
	public static void SUB(REG resultRegister, REG argRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "SUB", "Updated R" + resultRegister.registerID() + " with " + (argRegister.resolveArgument() - argument.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argRegister.resolveArgument() - argument.resolveArgument()));
	}
	
	public static void RSB(REG resultRegister, REG argRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "RSB", "Updated R" + resultRegister.registerID() + " with " + (argument.resolveArgument() - argRegister.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argument.resolveArgument() - argRegister.resolveArgument()));
	}
	
	public static void CMP(REG resultRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "CMP", "Condion codes updated with " + resultRegister.resolveArgument() + " and " + argument.resolveArgument());
		ArmCore.getInstance().cmpOne = resultRegister.resolveArgument();
		ArmCore.getInstance().cmpTwo = argument.resolveArgument();
	}
	
	public static void CMN(REG resultRegister, GENERIC argument)
	{
		ArmCore.logEvent(false, true, "CMN", "Condion codes updated with " + resultRegister.resolveArgument() + " and " + -argument.resolveArgument());
		ArmCore.getInstance().cmpOne = resultRegister.resolveArgument();
		ArmCore.getInstance().cmpTwo = -argument.resolveArgument();
	}
	
	public static void MUL(REG resultRegister, REG argRegister, REG argument)
	{
		ArmCore.logEvent(false, true, "MUL", "Updated R" + resultRegister.registerID() + " with " + (argRegister.resolveArgument() * argument.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argRegister.resolveArgument() * argument.resolveArgument()));
	}
	
	public static void MLA(REG resultRegister, REG argRegister, REG argument, REG strangeReg)
	{
		ArmCore.logEvent(false, true, "MLA", "Updated R" + resultRegister.registerID() + " with " + (argRegister.resolveArgument() * argument.resolveArgument() + strangeReg.resolveArgument()));
		ArmCore.getInstance().setRegister(resultRegister.registerID(), (argRegister.resolveArgument() * argument.resolveArgument() + strangeReg.resolveArgument()));
	}
	
	public static void SET(STR varName, GENERIC value)
	{
		ArmCore.logEvent(false, true, "SET", "Updated variable " + varName.resolveString() + " with " + value.resolveString());
		ArmCore.getInstance().setVar(varName.resolveString(), value);
	}
	
	public static void GET(STR varName, MEM memoryStart)
	{
		GENERIC value = ArmCore.getInstance().getVar(varName.resolveString());
		if(value.isString())
		{
			ArmCore.logEvent(false, true, "GET", "Loaded string " + value.resolveString() + " to address " + memoryStart.resolveAddress());
			ArmCore.getInstance().loadStringToMemory(value.resolveString(), memoryStart.resolveAddress());
		}else
		{
			ArmCore.logEvent(false, true, "GET", "Loaded " + value.resolveString() + " to address " + memoryStart.resolveAddress());
			ArmCore.getInstance().setMemory(memoryStart.resolveAddress(), value.resolveArgument());
		}
	}
	
	public static void B(MEM jmpAddr)
	{
		ArmCore.logEvent(false, true, "B", "Jumping to "+jmpAddr.resolveString());
		ArmCore.getInstance().setExecutionLoc(jmpAddr.resolveAddress());
	}
	
	public static void BNOLOG(GENERIC jmpAddr)
	{
		//ArmCore.logEvent(false, true, "B", "Jumping to "+jmpAddr.resolveArgument());
		ArmCore.getInstance().setExecutionLoc(jmpAddr.resolveArgument());
	}
	
	public static void BL(MEM jmpAddr)
	{
		ArmCore.logEvent(false, true, "BL", "Jumping to "+jmpAddr.resolveAddress()+", will return to "+ArmCore.getInstance().getExecutionLoc());
		ArmCore.getInstance().setRet(ArmCore.getInstance().getExecutionLoc());
		BNOLOG(new GENERIC("#"+jmpAddr.resolveAddress()));
	}
	
	public static void BX(REG register)
	{
		ArmCore.logEvent(false, true, "BX", "Setting return point to "+register.resolveArgument());
		ArmCore.getInstance().setRet(register.resolveArgument());
	}
	
	public static void SWI(IMM value)
	{
		ArmCore.logEvent(false, true, "SWI", "Calling interrupt "+value.resolveArgument());
		ArmCore.getInstance().interrupt(value.resolveArgument());
	}
	
	public static void RET()
	{
		ArmCore.getInstance().endQuantum(ArmCore.getInstance().getRet());
	}
	
	public static void SWP(REG d, REG m, MEM n)
	{
		ArmCore.logEvent(false, true, "SWP", "R"+m.registerID() + " --> [" + n.resolveAddress() + "] --> R" + d.registerID());
		ArmCore.getInstance().setRegister(d.registerID(), n.resolveArgument());
		ArmCore.getInstance().setMemory(n.resolveAddress(), m.resolveArgument());
	}
	
	public static void LDR(GENERIC string, MEM m)
	{
		ArmCore.getInstance().setVar(string.resolveString(), new GENERIC(("\""+ArmCore.getInstance().unloadStringFromMemory(m.resolveAddress()) + "\"").trim()));
		ArmCore.logEvent(false, true, "LDR", "Loaded \""+ArmCore.getInstance().getVar(string.resolveString()).resolveString().trim() + "\" into " + string.resolveString());
	}
	
	public static void STR(GENERIC string, MEM m)
	{
		ArmCore.getInstance().loadStringToMemory(string.resolveString(), m.resolveAddress());
		ArmCore.logEvent(false, true, "STR", "Stored " + string.resolveString() + " to [" + m.resolveAddress() + "]");
	}
	
	public static void LEV(GENERIC start, GENERIC end, GENERIC lev)
	{
		ArmCore.logEvent(false, true, "LEV", (ArmCore.getInstance().hasAccess(ArmCore.getInstance().getExecutionLoc(), start.resolveArgument()) ? "Updated " : "Did not update ") + "the security level for locations "+start.resolveArgument() + " through "+end.resolveArgument());
		ArmCore.getInstance().setAccessLevel(start.resolveArgument(), end.resolveArgument(), (byte)lev.resolveArgument());
	}
	
	public static void NOP()
	{
		//Dummy method, its supposed to do nothing
	}
	
	public static void PUSH(GENERIC value)
	{
		ArmCore.logEvent(false, true, "PUSH", "Pushed "+value.resolveArgument()+" to the stack");
		ArmCore.getInstance().globalStack.push(value.resolveArgument());
	}
	
	public static void POP(REG reg)
	{
		ArmCore.logEvent(false, true, "POP", "Popped "+ArmCore.getInstance().globalStack.peek()+" from the stack and into register "+reg.registerID());
		ArmCore.getInstance().setRegister(reg.registerID(), ArmCore.getInstance().globalStack.pop());
	}
	
	public static void PEEK(REG reg)
	{
		ArmCore.logEvent(false, true, "PEEK", "Peeked at the stack and placed " + ArmCore.getInstance().globalStack.peek() + " into register " + reg.registerID());
		ArmCore.getInstance().setRegister(reg.registerID(), ArmCore.getInstance().globalStack.peek());
	}
	
	//Initialize labels!
	public static void LBL(STR name, GENERIC maxHops)
	{
		int labelLoc = 0;
		for(int loop = 0; loop < maxHops.resolveArgument(); loop++)
		{
			String str = ArmCore.getInstance().unloadStringFromMemory(labelLoc).trim();
			if(str.trim().isEmpty())
				break;
			
			if(str.equals(":" + name.resolveString()))
			{
				ArmCore.getInstance().labels.put(str, labelLoc);
				ArmCore.logEvent(false, true, "LBL", "Mapped label " + str.replace(":", "") + " to address " + labelLoc);
				return;
			}
			
			labelLoc += ArmCore.getInstance().getMemory(labelLoc) + 1;
		}
		
		ArmCore.logEvent(true, true, "LBL", "Failed to map label "+name.resolveString());
	}
	
	/*public static void JMP(STR arg)
	{
		BNOLOG(new GENERIC("#"+ArmCore.getInstance().labels.get(":"+arg.resolveString())));
		ArmCore.logEvent(false, true, "JMP", "Jumped to label " + arg.resolveString() + " at address " + ArmCore.getInstance().labels.get(":"+arg.resolveString()));
	}*/
	
	public static void LSL(REG resutlReg, REG arg1, GENERIC arg2)
	{
		ArmCore.getInstance().setRegister(resutlReg.registerID(), arg1.resolveArgument() << arg2.resolveArgument());
		ArmCore.logEvent(false, true, "LSL", "Preformed a logical shift on " + arg1.resolveArgument() + ", moving it " + arg2.resolveArgument() + " bits to the left");
	}
	
	public static void LSR(REG resutlReg, REG arg1, GENERIC arg2)
	{
		ArmCore.getInstance().setRegister(resutlReg.registerID(), arg1.resolveArgument() >> arg2.resolveArgument());
		ArmCore.logEvent(false, true, "LSR", "Preformed a logical shift on " + arg1.resolveArgument() + ", moving it " + arg2.resolveArgument() + " bits to the right");
	}
	
	public static void ASR(REG resutlReg, REG arg1, GENERIC arg2)
	{
		ArmCore.getInstance().setRegister(resutlReg.registerID(), arg1.resolveArgument() >>> arg2.resolveArgument());
		ArmCore.logEvent(false, true, "ASR", "Preformed an arithmetic shift on " + arg1.resolveArgument() + ", moving it " + arg2.resolveArgument() + " bits to the right");
	}
	
	public static void HLT()
	{
		ArmCore.logEvent(false, true, "HLT", "System halted");
	}
	
	public static void LOCK(STR string, GENERIC level)
	{
		String data = string.resolveString().toUpperCase();
		if(ArmCore.getInstance().getSecurityAt(ArmCore.getInstance().getExecutionLoc()) == Byte.MAX_VALUE)
		{
			(OpCode.getCodeForString(data) != null ? OpCode.getCodeForString(data) : OpCode.NOP).setExecutionRestriction(level.resolveArgument());
			ArmCore.logEvent(true, true, "LOCK", "Locked instruction \"" + data + "\" to security level " + level.resolveArgument());
		}else
			ArmCore.logEvent(true, true, "LOCK", "Failed to lock \"" + data + "\" at level " + level.resolveArgument());
	}
	
	public static void INT(IMM id)
	{
		try {
			Method renderMethod = BIOS.class.getDeclaredMethod(ArmCore.getInstance().IVT.get(id), new Class[]{});
			renderMethod.setAccessible(true);
			renderMethod.invoke(ClassLoader.getSystemClassLoader(), new Object[]{});
			ArmCore.logEvent(false, true, "INT", "Preformed BIOS interrupt " + id.resolveArgument());
		} catch (SecurityException | IllegalAccessException
				| IllegalArgumentException | InvocationTargetException
				| NoSuchMethodException e) {
			System.err.println("[ARMCORE] Caught exception while reflecting into BIOS interrupt");
			e.printStackTrace();
		}
	}
	
	public static void REG(IMM id, MEM pos)
	{
		ArmCore.getInstance().registerInterrupt(id.resolveArgument(), pos.resolveAddress());
		ArmCore.logEvent(false, true, "REG", "Registered interrupt " + id.resolveArgument() + " to address " + pos.resolveAddress());
	}
	
	public static void QNTM(GENERIC nanos, IMM intupt)
	{
		ArmCore.getInstance().setQuantum(nanos.resolveArgument(), intupt.resolveArgument());
		ArmCore.logEvent(false, true, "QNTM", "Updated quantum drive for " + nanos.resolveArgument() + " cycles per session using interrupt " + intupt.resolveArgument());
	}
}
