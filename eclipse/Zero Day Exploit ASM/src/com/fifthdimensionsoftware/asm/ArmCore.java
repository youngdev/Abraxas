package com.fifthdimensionsoftware.asm;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.io.RandomAccessFile;
import java.lang.Thread.UncaughtExceptionHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.IntBuffer;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Stack;

import com.fifthdimensionsoftware.asm.types.GENERIC;

public class ArmCore
{

	//Registers
	private static boolean verbose, nolog;
	private static ArmCore armInstance;
	private int[] registers = new int[16];
	private int[] memory = new int[262144];
	private byte[] memLevel = new byte[this.memory.length];
	public int cmpOne, cmpTwo;
	private static PrintStream logStream;
	//private HashMap<Integer, Integer> interrupts = new HashMap<Integer, Integer>();
	public HashMap<Integer, String> IVT = new HashMap<Integer, String>();
	private HashMap<String, GENERIC> vars = new HashMap<String, GENERIC>();
	public Stack<Integer> globalStack = new Stack<Integer>();
	
	//Hard disk file
	private RandomAccessFile diskFile;
	
	public ArmCore(String diskFile, String[] args)
	{
		Thread.currentThread().setUncaughtExceptionHandler(new UncaughtExceptionHandler() {
			
			public void uncaughtException(Thread t, Throwable e)
			{
				e.printStackTrace(logStream);
				e.printStackTrace();
			}
		});
		
		if(armInstance == null)
			armInstance = this;
		else
			System.exit(1);
		
		if(args.length > 0)
			ArmCore.verbose = args[0].equals("--verbose");
		if(args.length > 1)
			ArmCore.nolog = args[1].equals("--nolog");
		
		try {
			boolean existsPrior = new File(diskFile).exists();
			this.diskFile = new RandomAccessFile(diskFile, "rw");
			if(!existsPrior)
				this.diskFile.setLength(1024 * 1024 * 1024);
			
			logStream = new PrintStream(new FileOutputStream(new File("logFile.log"), true));
			
			if (!nolog) {
				logStream.println();
				logStream.println("[DEBUG] "
						+ new SimpleDateFormat("HH:mm:ss - ww/dd/yyyy").format(
								Calendar.getInstance().getTime()).toString());
			}
			OpCode.verifySanity();
		} catch (IOException e) 
		{
			ArmCore.logEvent(true, false, "ARMCORE", "IO error on construction");
			System.exit(1);
		}
	}
	
	public ArmCore(File diskFile, String[] args)
	{
		this(diskFile.getAbsolutePath(), args);
	}
	
	public void doAsm(String asmCode)
	{
		asmCode = asmCode.trim().replaceAll("\\s+", " ").toUpperCase();
		//Define variables
		OpCode opCode = OpCode.NOP;
		ConditionCode conditionCode = ConditionCode.AL;
		String[] args = {};
		
		//Prepare variables
		if (!asmCode.startsWith(";"))
		{
			String code = asmCode.split("\\s(?=([^\"]*\"[^\"]*\")*[^\"]*$)")[0];
			opCode = OpCode.getCodeForString(code);
			args = Arrays.copyOfRange(asmCode.split("\\s(?=([^\"]*\"[^\"]*\")*[^\"]*$)", opCode.argLength + 1), 1, opCode.argLength+1);
			conditionCode = ConditionCode.getCode(code);
		}else
			return;
		
		opCode.preformCode(conditionCode, opCode.resolveArguments(args));
	}
	
	public static ArmCore getInstance()
	{
		return armInstance;
	}
	
	public void setRegister(int id, int value)
	{
		try {
			this.registers[id] = value;
		} catch (ArrayIndexOutOfBoundsException e) 
		{
			ArmCore.logEvent(true, false, "ARMCORE", "Attempt to set a register that doesn't exist");
		}
	}
	
	public int getRegister(int id)
	{
		try {
			return this.registers[id];
		} catch (ArrayIndexOutOfBoundsException e) 
		{
			ArmCore.logEvent(true, false, "ARMCORE", "Attempt to get a register that doesn't exist");
		}
		return 0;
	}
	
	public static boolean isVerbose()
	{
		return verbose;
	}
	
	public int getMemory(int index)
	{
		return this.memory[index];
	}
	
	public void setMemory(int index, int value)
	{
		if(this.hasAccess(this.getExecutionLoc(), index))
			this.memory[index] = value;
	}
	
	public static void logEvent(boolean severe, boolean isVerbose, String type, String content)
	{
		String finalContent = "["+type.toUpperCase()+"] "+content;
		if(isVerbose() && isVerbose)
		{
			if(severe)
			{
				System.err.println(finalContent);
				if(!nolog)
					logStream.println("! "+finalContent);
			}else
			{
				System.out.println(finalContent);
				if(!nolog)
					logStream.println(finalContent);
			}
			
		}else if(severe && !isVerbose)
		{
			System.err.println(finalContent);
			if(!nolog)
				logStream.println("! "+finalContent);
		}else if(!severe && !isVerbose)
		{
			System.out.println(finalContent);
			if(!nolog)
				logStream.println(finalContent);
		}
	}
	
	public void setRet(int value)
	{
		this.setRegister(14, value);
	}
	
	public int getRet()
	{
		return this.getRegister(14);
	}
	
	public static int lastStrSize = 0;
	
	public void loadStringToMemory(String code, int startingAddress)
	{
			if (((long) code.length() % 4L) != 0) {
				int loop = 0;
				while (loop < ((long) code.length() % 4L)) {
					code += (char) 0;
					loop++;
				}
			}
			
			IntBuffer intBuf = ByteBuffer.wrap(code.getBytes())
					.order(ByteOrder.BIG_ENDIAN).asIntBuffer();
			int[] array = new int[intBuf.remaining()];
			intBuf.get(array);
			lastStrSize = array.length;
			if (this.hasAccess(this.getExecutionLoc(), startingAddress)) {
				this.setMemory(startingAddress++, array.length);
				System.arraycopy(array, 0, this.memory, startingAddress,
						array.length);
			}
	}
	
	public String unloadStringFromMemory(int startingAddress)
	{
		String toReturn = "";
		if (true) {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			DataOutputStream dos = new DataOutputStream(baos);
			int start = this.getMemory(startingAddress++);
			for (int loop = 0; loop < start; loop++) {
				try {
					dos.writeInt(this.getMemory(startingAddress++));
				} catch (IOException e) {
				}
			}
			toReturn = new String(baos.toByteArray());
			try {
				baos.close();
				dos.close();
			} catch (IOException e) {
			}
		}
		return toReturn;
	}
	
	public void loadDiskRegion(long start, int length, int ramLoc)
	{
		try {
			this.diskFile.seek(start * 8);
			for(int loop = 0; loop < length; loop++)
			{
				this.setMemory(ramLoc + loop, this.diskFile.readInt());
			}
		} catch (IOException e)
		{
			e.printStackTrace();
		}
	}
	
	public void saveDiskRegion(long start, int length, int ramLoc)
	{
		try {
			this.diskFile.seek(start * 8);
			for(int loop = 0; loop < length; loop++)
			{
				this.diskFile.writeInt(this.getMemory(ramLoc + loop));
			}
		} catch (IOException e)
		{
			e.printStackTrace();
		}
	}
	
	private int numCycles = 0;
	
	
	public void doExecution(int startAddr)
	{
		this.setExecutionLoc(startAddr);
		float pastTime = System.nanoTime();
		
		while(true)
		{
			String executionString = this.unloadStringFromMemory(this.getExecutionLoc());
			if(executionString.trim().isEmpty())
				break;
			this.incrementExecutionLoc(this.getMemory(this.getExecutionLoc()) + 1);
			this.doAsm(executionString);
			this.numCycles++;
		}
		
		ArmCore.logEvent(true, false, "DEBUG", "Execution of " + this.numCycles +" opcodes completed in " + (System.nanoTime() - pastTime) / 1000000000F + " seconds, at " + (System.nanoTime() - pastTime) / (1000000000F * this.numCycles) + " seconds per cycle");
		}
	
	public void setVar(String name, GENERIC value)
	{
		this.vars.put(name, value);
		
	}
	
	public GENERIC getVar(String name)
	{
		return this.vars.containsKey(name) ? this.vars.get(name) : new GENERIC("#0");
	}
	
	public void interrupt(int id)
	{
		if (!this.IVT.containsKey(id))
		{
			/*OpCodeFunctions.BL(new IMM("#" + this.interrupts.get(id)));
			doExecution(this.getExecutionLoc());
			this.setExecutionLoc(this.getRet());*/
		}else
		{
			try {
				Method renderMethod = BIOS.class.getDeclaredMethod(this.IVT.get(id), new Class[]{});
				renderMethod.setAccessible(true);
				renderMethod.invoke(ClassLoader.getSystemClassLoader(), new Object[]{});
			} catch (SecurityException | IllegalAccessException
					| IllegalArgumentException | InvocationTargetException
					| NoSuchMethodException e) {
				System.err.println("[ARMCORE] Caught exception while reflecting into BIOS interrupt");
				e.printStackTrace();
			}
		}
	}
	
	public boolean hasAccess(int executionPos, int accessPos)
	{
		return this.memLevel[executionPos] >= this.memLevel[accessPos];
	}
	
	public void setAccessLevel(int start, int end, byte level)
	{
		start--;
		
		byte tmpLevel = this.memLevel[this.getExecutionLoc()];
		
		while (start++ < end)
		{
			if(tmpLevel >= this.memLevel[start])
			{
				this.memLevel[start] = level;
			}
		}
	}
	
	public void forceAccessLevel(int start, int end, byte level)
	{
		start--;
		while (start++ < end)
		{
			this.memLevel[start] = level;
		}
	}
	
	public int getExecutionLoc()
	{
		return this.getRegister(13);
	}
	
	public void setExecutionLoc(int param)
	{
		this.setRegister(13, param);
	}
	
	public void incrementExecutionLoc(int param)
	{
		this.setExecutionLoc(getExecutionLoc()+param);
	}
	
	public int getByteRegion(boolean highByte, int value)
	{
		return highByte ? value >> 16 & 0xffff : value & 0xffff;
	}
}