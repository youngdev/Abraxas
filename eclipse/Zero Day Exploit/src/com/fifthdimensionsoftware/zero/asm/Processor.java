package com.fifthdimensionsoftware.zero.asm;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;

import com.fifthdimensionsoftware.zero.ZeroDayExploit;
import com.fifthdimensionsoftware.zero.tools.MemoryUtil;

public class Processor {
	
	@SuppressWarnings("unused") //As these are only invoked via reflection, eclipse complains
	private static class Instructions
	{
		public static void STR(int opcode)
		{
			int[] parsed = parseDataOp(opcode);
			
			Processor.instance.setMemorySegment(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue(), (byte)((Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111_0000_0000_0000_0000_0000_0000) >> 24), (byte)((Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111_0000_0000_0000_0000) >> 16), (byte)((Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111_0000_0000) >> 8), (byte)(Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111));
			
			System.out.println("Memory at " + (parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue()) + " set to " + Arrays.toString(Processor.instance.getMemorySegment(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue(), 4)));
		}
		
		public static void STRB(int opcode)
		{
			int[] parsed = parseDataOp(opcode);
			
			Processor.instance.setMemory(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue(), (byte)(Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111));
			
			System.out.println("Address " + (parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue()) + " set to " + Processor.instance.getMemory(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue()));
		
		}
		
		public static void HLT(int opcode)
		{
			System.out.println("System Halted");
			System.exit(0);
		}
		
		public static void B(int opcode)
		{
			int toJump = opcode & 0b1111_1111_1111_1111_1111_1111;
			
			toJump = AsmCore.expandInt(toJump, 24);
			
			toJump -= 4;
			
			Processor.instance.getRegisterPerMode(15).setValue(Processor.instance.getRegisterPerMode(15).getValue() + toJump);
			
			System.out.println("Jumped " + (toJump + 4));
		}
		
		public static void BL(int opcode)
		{
			Processor.instance.getRegisterPerMode(14).setValue(Processor.instance.getRegisterPerMode(15).getValue());
			
			B(opcode);
		}
		
		public static void MOV(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			Register dest = Processor.instance.getRegisterPerMode(ops[1]);
			
			dest.setValue(ops[2]);
			
			System.out.println("Register " + dest.getName() + " updated to " + ops[2]);
		}
		
		private static int[] parseDataOp(int opcode)
		{
			int[] toReturn = new int[3];
			
			toReturn[0] = opcode >> 16 & 0b1111;
			toReturn[1] = opcode >> 12 & 0b1111;
			
			if(((opcode & 0b10000_0_0000_0000_000000000000) >> 25) == 0b1)
			{
				toReturn[2] = opcode & 0b1111_1111_1111;
				toReturn[2] = AsmCore.expandInt(toReturn[2], 12);
				
			}else
			{
				toReturn[2] = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue();
			}
			
			return toReturn;
		}
	}
	
	public enum ProcessorMode {
		User32(16), FIQ32(17), Supervisor32(19), Abort32(23), IRQ32(18), Undefined32(27), System32(31);
		
		public byte id;
		
		private ProcessorMode(int id)
		{
			this.id = (byte) id;
		}
	}
	
	private LinkedList<RandomAccessFile> disks = new LinkedList<RandomAccessFile>();
	private RandomAccessFile bios;
	public byte[] memory = new byte[536870912];
	
	public static HashMap<String, Register> globalRegsiters = new HashMap<String, Register>();
	public static Processor instance;
	private ProcessorMode mode = ProcessorMode.Undefined32;
	
	static
	{
		Register.initializeRegisters(globalRegsiters);
	}
	
	public Processor(File biosFile, String...diskFiles) throws IOException
	{
		if(instance == null)
			instance = this;
		else
			ZeroDayExploit.throwFatal("Attempted to initialize the processor twice");
		this.bios = new RandomAccessFile(biosFile, "rw");
		for(String file : diskFiles)
			this.disks.push(new RandomAccessFile(new File(file), "rw"));
		MemoryUtil.loadFile(0, 0, 0xA545, getBiosImage());
	}
	
	public byte[] getMemorySegment(int start, int length)
	{
		byte[] toReturn = new byte[length];
		
		System.arraycopy(this.memory, start, toReturn, 0, length);
		
		return toReturn;
	}
	
	public void setMemorySegment(int start, byte...data)
	{
		System.arraycopy(data, 0, this.memory, start, data.length);
	}
	
	public byte getMemory(int addr)
	{
		return this.memory[addr];
	}
	
	public void setMemory(int addr, byte data)
	{
		this.memory[addr] = data;
	}
	
	public RandomAccessFile getBiosImage()
	{
		return this.bios;
	}
	
	public Register getRegisterPerMode(int id)
	{
		if(id == 18)
			return globalRegsiters.get("cpsr");
		
		if(this.mode != ProcessorMode.System32)
			return globalRegsiters.get("r"+id + "_" +this.mode.name());
		else
			return globalRegsiters.get("r"+id + "_User32");
	}
	
	public void setMode(ProcessorMode newMode)
	{
		System.out.println(Integer.toHexString(globalRegsiters.get("cpsr").getValue()));
		this.mode = newMode;
		globalRegsiters.get("cpsr").setValue((globalRegsiters.get("cpsr").getValue() & 0x00_ff_ff_ff) | this.mode.id);
		System.out.println(Integer.toHexString(globalRegsiters.get("cpsr").getValue()));
	}
	
	public ProcessorMode getMode()
	{
		return this.mode;
	}
	
	//The method to end all methods
	public void execute(int position)
	{
		this.getRegisterPerMode(15).setValue(position);
		while(true)//this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4)[0] != 0)
		{
			byte[] tmpInst = this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4);
			int inst = 0;
			int tmpInt = tmpInst[0] & 0b1111_1111;
			inst |= tmpInt;
			inst <<= 8;
			tmpInt = tmpInst[1] & 0b1111_1111;
			inst |= tmpInt;
			inst <<= 8;
			tmpInt = tmpInst[2] & 0b1111_1111;
			inst |= tmpInt;
			inst <<= 8;
			tmpInt = tmpInst[3] & 0b1111_1111;
			inst |= tmpInt;
			
			if (AsmCore.isCondition(inst))
				try {
					Instructions.class.getDeclaredMethod(
							AsmCore.guessCode(inst),
							new Class<?>[] { int.class }).invoke(null, inst);
				} catch (IllegalAccessException | IllegalArgumentException
						| InvocationTargetException | NoSuchMethodException
						| SecurityException e) {
					e.printStackTrace();
				}
				
			this.getRegisterPerMode(15).setValue(this.getRegisterPerMode(15).getValue() + 4);
		}
	}
}