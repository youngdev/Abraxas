package com.fifthdimensionsoftware.zero.asm;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;

import com.fifthdimensionsoftware.zero.ZeroDayExploit;
import com.fifthdimensionsoftware.zero.tools.GameUtil;
import com.fifthdimensionsoftware.zero.tools.MemoryUtil;

public class Processor
{	
	public static class Instructions
	{
		public static void BX(int opcode)
		{
			int toJump = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue();
			int mode = (opcode & 0b11110000) >> 4;
			
			for(ProcessorMode tmpMode : ProcessorMode.values())
				if(tmpMode.id == (mode))
					Processor.instance.setMode(tmpMode);
			
			Processor.instance.getRegisterPerMode(15).setValue(toJump);
			
			System.out.println("Jumped to " + toJump);
		}
		
		public static void SVC(int opcode)
		{
			int intrupt = opcode & 0b111111111111111111111111;
			
			int tmpAddr = Processor.instance.getRegisterPerMode(15).getValue();
			
			Processor.instance.getRegisterPerMode(15).setValue(AsmCore.fromBytes(Processor.instance.getMemorySegment(Processor.instance.ivtAddr + (intrupt * 4), 4)));
			
			Processor.instance.setMode(ProcessorMode.IRQ);
			
			Processor.instance.getRegisterPerMode(14).setValue(tmpAddr);
			
			System.out.println("Jumped to interrupt " + intrupt);
		}
		
		public static void BIC(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			args[1] = Processor.instance.getRegisterPerMode(args[1]).getValue();
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(args[1] & ~args[2]);
			
			System.out.println("Performed a bit clear on " + args[1] + " and " + args[2]);
		}
		
		public static void AND(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			args[1] = Processor.instance.getRegisterPerMode(args[1]).getValue();
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(args[1] & args[2]);
			
			System.out.println("Performed a bitwise AND on " + args[1] + " and " + args[2]);
		}
		
		public static void ORR(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			args[1] = Processor.instance.getRegisterPerMode(args[1]).getValue();
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(args[1] | args[2]);
			
			System.out.println("Performed a bitwise OR on " + args[1] + " and " + args[2]);
		}
		
		public static void EOR(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			args[1] = Processor.instance.getRegisterPerMode(args[1]).getValue();
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(args[1] ^ args[2]);
			
			System.out.println("Performed a bitwise XOR or on " + args[1] + " and " + args[2]);
		}
		
		public static void ADD(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			args[1] = Processor.instance.getRegisterPerMode(args[1]).getValue();
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(args[1] + args[2]);
			
			System.out.println("Added " + args[2] + " to " + args[1]);
		}
		
		public static void RSB(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			args[1] = Processor.instance.getRegisterPerMode(args[1]).getValue();
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(args[2] - args[1]);
			
			System.out.println("Subtracted " + args[1] + " from " + args[2]);
		}
		
		public static void SUB(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			args[1] = Processor.instance.getRegisterPerMode(args[1]).getValue();
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(args[1] - args[2]);
			
			System.out.println("Subtracted " + args[2] + " from " + args[1]);
		}
		
		public static void CTD(int opcode)
		{
			Processor.instance.getRegisterPerMode(opcode & 0b1111).setValue(Processor.instance.disks.size());
		}
		
		public static void DSTR(int opcode)
		{			
			int memStart = Processor.instance.getRegisterPerMode((opcode >> 8) & 0b1111).getValue(), diskStart = Processor.instance.getRegisterPerMode((opcode >> 4) & 0b1111).getValue(), length = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue(), id = (opcode >> 12) & 0b111_1111_1111;
			
			if(((opcode >> 23) & 0b1) == 0b1)
				id = Processor.instance.getRegisterPerMode(id).getValue();
			
			MemoryUtil.saveDiskRegion(memStart, diskStart, length, id);
			
			System.out.println("Saved! " + memStart + " : " + diskStart + " : " + length + " : " + id);
		}
		
		public static void DLDR(int opcode)
		{
			int memStart = Processor.instance.getRegisterPerMode((opcode >> 8) & 0b1111).getValue(), diskStart = Processor.instance.getRegisterPerMode((opcode >> 4) & 0b1111).getValue(), length = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue(), id = (opcode >> 12) & 0b111_1111_1111;
			
			if(((opcode >> 23) & 0b1) == 0b1)
				id = Processor.instance.getRegisterPerMode(id).getValue();
			
			MemoryUtil.loadDiskRegion(memStart, diskStart, length, id);
			
			System.out.println("Loaded! " + memStart + " : " + diskStart + " : " + length + " : " + id);
		}
		
		public static void CPM(int opcode)
		{
			for(ProcessorMode mode : ProcessorMode.values())
				if(mode.id == (opcode & 0b1111))
					Processor.instance.setMode(mode);
		}
		
		public static void PUSH(int opcode)
		{
			int val = Processor.instance.getRegisterPerMode(13).getValue();
			int off = AsmCore.fromBytes(Processor.instance.getMemorySegment(val, 4));
			
			System.out.println(Arrays.toString(AsmCore.toBytes(Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue())));
			
			Processor.instance.setMemorySegment(val + off, AsmCore.toBytes(Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue()));
			Processor.instance.setMemorySegment(val, AsmCore.toBytes(off + 4));
			
			System.out.println("Pushed " + Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue() + " to the stack at " + (val + off));
		}
		
		public static void POP(int opcode)
		{
			int val = Processor.instance.getRegisterPerMode(13).getValue();
			int off = AsmCore.fromBytes(Processor.instance.getMemorySegment(val, 4)) - 4;
			
			System.out.println(Arrays.toString(Processor.instance.getMemorySegment(val, 4)));
			
			Processor.instance.getRegisterPerMode(opcode & 0b1111).setValue(AsmCore.fromBytes(Processor.instance.getMemorySegment(val + off, 4)));
			Processor.instance.setMemorySegment(val, AsmCore.toBytes(off));
			
			System.out.println("Popped " + Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue() + " from the stack (" + (val + off) +") and into " + Processor.instance.getRegisterPerMode(opcode & 0b1111).getName());
		}
		
		public static void TEQ(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			int op1 = Processor.instance.getRegisterPerMode(ops[1]).getValue();
			
			op1 ^= ops[2];
			AsmCore.setCPSR(op1 < 0, op1 == 0, false, false);
		}
		
		public static void TST(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			int op1 = Processor.instance.getRegisterPerMode(ops[1]).getValue();
			
			op1 &= ops[2];
			AsmCore.setCPSR(op1 < 0, op1 == 0, false, false);
		}
		
		public static void CMP(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			int op1 = Processor.instance.getRegisterPerMode(ops[1]).getValue();
			
			op1 -= ops[2];
			AsmCore.setCPSR(op1 < 0, op1 == 0, false, false);
		}
		
		public static void CMN(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			int op1 = Processor.instance.getRegisterPerMode(ops[1]).getValue();
			
			op1 += ops[2];
			AsmCore.setCPSR(op1 < 0, op1 == 0, false, false);
		}
		
		public static void STR(int opcode)
		{
			int[] parsed = parseDataOp(opcode);
			
			Processor.instance.setMemorySegment(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue(), (byte)((Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111_0000_0000_0000_0000_0000_0000) >> 24), (byte)((Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111_0000_0000_0000_0000) >> 16), (byte)((Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111_0000_0000) >> 8), (byte)(Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111));
			
			System.out.println("Memory at " + (parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue()) + " set to " + Arrays.toString(Processor.instance.getMemorySegment(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue(), 4)));
		}
		
		public static void STRB(int opcode)
		{
			int[] parsed = parseDataOp(opcode);
			
			Processor.instance.setMemory(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue(), (byte)(Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111));
			
			System.out.println("Memory at " + (parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue()) + " set to " + Processor.instance.getMemory(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue()));
		
		}
		
		public static void LDR(int opcode)
		{
			int[] parsed = parseDataOp(opcode);
			
			Processor.instance.getRegisterPerMode(parsed[1]).setValue(AsmCore.fromBytes(Processor.instance.getMemorySegment(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue(), 4)));
			
			System.out.println("Register " + Processor.instance.getRegisterPerMode(parsed[1]).getName() + " updated to " + Processor.instance.getRegisterPerMode(parsed[1]).getValue());
		}
		
		public static void LDRB(int opcode)
		{
			int[] parsed = parseDataOp(opcode);
			
			Processor.instance.getRegisterPerMode(parsed[1]).setValue(Processor.instance.getMemory(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue()));
			
			System.out.println("Register " + Processor.instance.getRegisterPerMode(parsed[1]).getName() + " updated to " + Processor.instance.getRegisterPerMode(parsed[1]).getValue());
		}
		
		public static void HLT(int opcode)
		{
			if (Processor.instance.mode != ProcessorMode.USR) {
				System.out.println("System Halted");
				Processor.instance.haltProcessor();
			}else
				GameUtil.throwNonFatal("Cannot halt from user mode");
		}
		
		public static void B(int opcode)
		{
			int toJump = opcode & 0b1111_1111_1111_1111_1111_1111;
			
			toJump = AsmCore.expandInt(toJump, 24);
			
			toJump -= 4;
			
			Processor.instance.getRegisterPerMode(15).setValue(Processor.instance.getRegisterPerMode(15).getValue() + toJump);
			
			System.out.println("Jumped " + (toJump + 4));
		}
		
		public static void BL(int opcode)
		{
			Processor.instance.getRegisterPerMode(14).setValue(Processor.instance.getRegisterPerMode(15).getValue());
			
			B(opcode);
		}
		
		public static void MOV(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			Register dest = Processor.instance.getRegisterPerMode(ops[1]);
			
			dest.setValue(ops[2]);
			
			System.out.println("Register " + dest.getName() + " updated to " + ops[2]);
		}
		
		public static void MVN(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			Register dest = Processor.instance.getRegisterPerMode(ops[1]);
			
			dest.setValue(~ops[2]);
			
			System.out.println("Register " + dest.getName() + " updated to " + ~ops[2]);
		}
		
		public static void SWP(int opcode)
		{
			int[] toReturn = new int[3];
			
			toReturn[0] = Processor.instance.getRegisterPerMode(opcode >> 16 & 0b1111).getValue();
			Register dest = Processor.instance.getRegisterPerMode(opcode >> 12 & 0b1111);
			
			toReturn[2] = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue();
			
			int tmpVal = AsmCore.fromBytes(Processor.instance.getMemorySegment(toReturn[0] + toReturn[2], 4));
			Processor.instance.setMemorySegment(toReturn[0] + toReturn[2], AsmCore.toBytes(dest.getValue()));
			dest.setValue(tmpVal);
			
			System.out.println(dest.getName() + " swapped with [" + (toReturn[0] + toReturn[2]) + "]");
		}
		
		public static void SWPB(int opcode)
		{
			int[] toReturn = new int[3];
			
			toReturn[0] = Processor.instance.getRegisterPerMode(opcode >> 16 & 0b1111).getValue();
			Register dest = Processor.instance.getRegisterPerMode(opcode >> 12 & 0b1111);
			
			toReturn[2] = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue();
			
			byte tmpVal = Processor.instance.getMemory(toReturn[0] + toReturn[2]);
			Processor.instance.setMemory(toReturn[0] + toReturn[2], (byte) (dest.getValue() & 0b1111_1111));
			dest.setValue(tmpVal);
			
			System.out.println(dest.getName() + " swapped with [" + (toReturn[0] + toReturn[2]) + "]");
		}
		
		public static void MUL(int opcode)
		{
			Register dest = Processor.instance.getRegisterPerMode((opcode >> 16) & 0b1111);
			dest.setValue(Processor.instance.getRegisterPerMode((opcode >> 12) & 0b1111).getValue() * Processor.instance.getRegisterPerMode((opcode) & 0b1111).getValue());
			System.out.println(dest.getName() + " updated to " + dest.getValue());
		}
		
		private static int[] parseDataOp(int opcode)
		{
			int[] toReturn = new int[3];
			
			toReturn[0] = opcode >> 16 & 0b1111;
			toReturn[1] = opcode >> 12 & 0b1111;
			
			if(((opcode & 0b10000_0_0000_0000_000000000000) >> 25) == 0b1)
			{
				toReturn[2] = opcode & 0b1111_1111_1111;
				toReturn[2] = AsmCore.expandInt(toReturn[2], 12);
				
			}else
			{
				toReturn[2] = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue();
			}
			
			return toReturn;
		}
	}
	
	public enum ProcessorMode {
		USR(0b1000), FIQ(0b0100), SUP(0b0010), ABT(0b0001), IRQ(0b1001), UNDEF(0b0101), SYS(0b0011);
		
		public byte id;
		
		private ProcessorMode(int id)
		{
			this.id = (byte) id;
		}
	}
	
	private LinkedList<RandomAccessFile> disks = new LinkedList<RandomAccessFile>();
	private RandomAccessFile bios;
	public byte[] memory = new byte[536870912];
	
	public static HashMap<String, Register> globalRegsiters = new HashMap<String, Register>();
	public static Processor instance;
	private ProcessorMode mode = ProcessorMode.UNDEF;
	private boolean toExit = false;
	private int ivtAddr = 512;
	
	static
	{
		Register.initializeRegisters(globalRegsiters);
	}
	
	public Processor(File biosFile, String...diskFiles) throws IOException
	{
		if(instance == null)
			instance = this;
		else
			ZeroDayExploit.throwFatal("Attempted to initialize the processor twice");
		this.bios = new RandomAccessFile(biosFile, "rw");
		for(String file : diskFiles)
			this.disks.push(new RandomAccessFile(new File(file), "rw"));
		MemoryUtil.loadFile(0, 0, 0xA545, getBiosImage());
	}
	
	public byte[] getMemorySegment(int start, int length)
	{
		byte[] toReturn = new byte[length];
		
		System.arraycopy(this.memory, start, toReturn, 0, length);
		
		return toReturn;
	}
	
	public void setMemorySegment(int start, byte...data)
	{
		System.arraycopy(data, 0, this.memory, start, data.length);
	}
	
	public byte getMemory(int addr)
	{
		return this.memory[addr];
	}
	
	public void setMemory(int addr, byte data)
	{
		this.memory[addr] = data;
	}
	
	public RandomAccessFile getBiosImage()
	{
		return this.bios;
	}
	
	public Register getRegisterPerMode(int id)
	{
		if(id == 18)
			return globalRegsiters.get("cpsr");
		
		if(id == 15)
			return globalRegsiters.get("pc");
		
		if(this.mode != ProcessorMode.SYS)
			return globalRegsiters.get("r"+id + "_" +this.mode.name());
		else
			return globalRegsiters.get("r"+id + "_User32");
	}
	
	public void setMode(ProcessorMode newMode)
	{
		this.mode = newMode;
		System.out.println("Mode updated to " + newMode.name());
	}
	
	public ProcessorMode getMode()
	{
		return this.mode;
	}
	
	public void haltProcessor()
	{
		toExit = true;
	}
	
	public RandomAccessFile getDisk(int id)
	{
		return disks.get(id);
	}
	
	//The method to end all methods
	public void execute(int position)
	{
		this.getRegisterPerMode(15).setValue(position);
		while(!toExit && AsmCore.fromBytes(this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4)) != 0)//this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4)[0] != 0)
		{
			int inst = AsmCore.fromBytes(this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4));
			
			if (AsmCore.isCondition(inst))
				try {
					Instructions.class.getDeclaredMethod(AsmCore.guessCode(inst), int.class).invoke(null, inst);
				} catch (IllegalAccessException | IllegalArgumentException
						| InvocationTargetException | NoSuchMethodException
						| SecurityException e) {
					System.err.println("Processor halted while attempting " + AsmCore.guessCode(inst));
					e.printStackTrace();
					this.haltProcessor();
				}
			else
				System.out.println("Ignored a(n) " + AsmCore.guessCode(inst) + " instruction due to condition codes");
			this.getRegisterPerMode(15).setValue(this.getRegisterPerMode(15).getValue() + 4);
		}
	}
}