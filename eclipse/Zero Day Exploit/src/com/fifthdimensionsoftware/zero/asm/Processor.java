package com.fifthdimensionsoftware.zero.asm;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;

import com.fifthdimensionsoftware.zero.ZeroDayExploit;
import com.fifthdimensionsoftware.zero.tools.MemoryUtil;

public class Processor
{	
	@SuppressWarnings("unused") //As these are only invoked via reflection, eclipse complains
	public static class Instructions
	{
		public static void PUSH(int opcode)
		{
			int val = Processor.instance.getRegisterPerMode(13).getValue();
			int off = AsmCore.fromBytes(Processor.instance.getMemorySegment(val, 4));
			
			System.out.println(Arrays.toString(AsmCore.toBytes(Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue())));
			
			Processor.instance.setMemorySegment(val + off, AsmCore.toBytes(Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue()));
			Processor.instance.setMemorySegment(val, AsmCore.toBytes(off + 4));
			
			System.out.println("Pushed " + Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue() + " to the stack at " + (val + off));
		}
		
		public static void POP(int opcode)
		{
			int val = Processor.instance.getRegisterPerMode(13).getValue();
			int off = AsmCore.fromBytes(Processor.instance.getMemorySegment(val, 4)) - 4;
			
			System.out.println(Arrays.toString(Processor.instance.getMemorySegment(val, 4)));
			
			Processor.instance.getRegisterPerMode(opcode & 0b1111).setValue(AsmCore.fromBytes(Processor.instance.getMemorySegment(val + off, 4)));
			Processor.instance.setMemorySegment(val, AsmCore.toBytes(off));
			
			System.out.println("Popped " + Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue() + " from the stack (" + (val + off) +") and into " + Processor.instance.getRegisterPerMode(opcode & 0b1111).getName());
		}
		
		public static void CMP(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			int op1 = Processor.instance.getRegisterPerMode(ops[1]).getValue();
			Register dest = Processor.instance.getRegisterPerMode(18 /*cpsr*/);
			
			op1 -= ops[2];
			AsmCore.setCPSR(op1 >> 31 == 1, op1 == 0, false, false);
		}
		
		public static void STR(int opcode)
		{
			int[] parsed = parseDataOp(opcode);
			
			Processor.instance.setMemorySegment(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue(), (byte)((Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111_0000_0000_0000_0000_0000_0000) >> 24), (byte)((Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111_0000_0000_0000_0000) >> 16), (byte)((Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111_0000_0000) >> 8), (byte)(Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111));
			
			System.out.println("Memory at " + (parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue()) + " set to " + Arrays.toString(Processor.instance.getMemorySegment(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue(), 4)));
		}
		
		public static void STRB(int opcode)
		{
			int[] parsed = parseDataOp(opcode);
			
			Processor.instance.setMemory(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue(), (byte)(Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111));
			
			System.out.println("Memory at " + (parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue()) + " set to " + Processor.instance.getMemory(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue()));
		
		}
		
		public static void LDR(int opcode)
		{
			int[] parsed = parseDataOp(opcode);
			
			Processor.instance.getRegisterPerMode(parsed[1]).setValue(AsmCore.fromBytes(Processor.instance.getMemorySegment(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue(), 4)));
			
			System.out.println("Register " + Processor.instance.getRegisterPerMode(parsed[1]).getName() + " updated to " + Processor.instance.getRegisterPerMode(parsed[1]).getValue());
		}
		
		public static void LDRB(int opcode)
		{
			int[] parsed = parseDataOp(opcode);
			
			Processor.instance.getRegisterPerMode(parsed[1]).setValue(Processor.instance.getMemory(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue()));
			
			System.out.println("Register " + Processor.instance.getRegisterPerMode(parsed[1]).getName() + " updated to " + Processor.instance.getRegisterPerMode(parsed[1]).getValue());
		}
		
		public static void HLT(int opcode)
		{
			System.out.println("System Halted");
			Processor.instance.haltProcessor();
		}
		
		public static void B(int opcode)
		{
			int toJump = opcode & 0b1111_1111_1111_1111_1111_1111;
			
			toJump = AsmCore.expandInt(toJump, 24);
			
			toJump -= 4;
			
			Processor.instance.getRegisterPerMode(15).setValue(Processor.instance.getRegisterPerMode(15).getValue() + toJump);
			
			System.out.println("Jumped " + (toJump + 4));
		}
		
		public static void BL(int opcode)
		{
			Processor.instance.getRegisterPerMode(14).setValue(Processor.instance.getRegisterPerMode(15).getValue());
			
			B(opcode);
		}
		
		public static void MOV(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			Register dest = Processor.instance.getRegisterPerMode(ops[1]);
			
			dest.setValue(ops[2]);
			
			System.out.println("Register " + dest.getName() + " updated to " + ops[2]);
		}
		
		public static void MVN(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			Register dest = Processor.instance.getRegisterPerMode(ops[1]);
			
			dest.setValue(~ops[2]);
			
			System.out.println("Register " + dest.getName() + " updated to " + ~ops[2]);
		}
		
		public static void SWP(int opcode)
		{
			int[] toReturn = new int[3];
			
			toReturn[0] = Processor.instance.getRegisterPerMode(opcode >> 16 & 0b1111).getValue();
			Register dest = Processor.instance.getRegisterPerMode(opcode >> 12 & 0b1111);
			
			toReturn[2] = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue();
			
			int tmpVal = AsmCore.fromBytes(Processor.instance.getMemorySegment(toReturn[0] + toReturn[2], 4));
			Processor.instance.setMemorySegment(toReturn[0] + toReturn[2], AsmCore.toBytes(dest.getValue()));
			dest.setValue(tmpVal);
			
			System.out.println(dest.getName() + " swapped with [" + (toReturn[0] + toReturn[2]) + "]");
		}
		
		public static void SWPB(int opcode)
		{
			int[] toReturn = new int[3];
			
			toReturn[0] = Processor.instance.getRegisterPerMode(opcode >> 16 & 0b1111).getValue();
			Register dest = Processor.instance.getRegisterPerMode(opcode >> 12 & 0b1111);
			
			toReturn[2] = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue();
			
			byte tmpVal = Processor.instance.getMemory(toReturn[0] + toReturn[2]);
			Processor.instance.setMemory(toReturn[0] + toReturn[2], (byte) (dest.getValue() & 0b1111_1111));
			dest.setValue(tmpVal);
			
			System.out.println(dest.getName() + " swapped with [" + (toReturn[0] + toReturn[2]) + "]");
		}
		
		public static void MUL(int opcode)
		{
			Register dest = Processor.instance.getRegisterPerMode((opcode >> 16) & 0b1111);
			dest.setValue(Processor.instance.getRegisterPerMode((opcode >> 12) & 0b1111).getValue() * Processor.instance.getRegisterPerMode((opcode) & 0b1111).getValue());
			System.out.println(dest.getName() + " updated to " + dest.getValue());
		}
		
		private static int[] parseDataOp(int opcode)
		{
			int[] toReturn = new int[3];
			
			toReturn[0] = opcode >> 16 & 0b1111;
			toReturn[1] = opcode >> 12 & 0b1111;
			
			if(((opcode & 0b10000_0_0000_0000_000000000000) >> 25) == 0b1)
			{
				toReturn[2] = opcode & 0b1111_1111_1111;
				toReturn[2] = AsmCore.expandInt(toReturn[2], 12);
				
			}else
			{
				toReturn[2] = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue();
			}
			
			return toReturn;
		}
	}
	
	public enum ProcessorMode {
		User32(16), FIQ32(17), Supervisor32(19), Abort32(23), IRQ32(18), Undefined32(27), System32(31);
		
		public byte id;
		
		private ProcessorMode(int id)
		{
			this.id = (byte) id;
		}
	}
	
	private LinkedList<RandomAccessFile> disks = new LinkedList<RandomAccessFile>();
	private RandomAccessFile bios;
	public byte[] memory = new byte[536870912];
	
	public static HashMap<String, Register> globalRegsiters = new HashMap<String, Register>();
	public static Processor instance;
	private ProcessorMode mode = ProcessorMode.Undefined32;
	private boolean toExit = false;
	
	static
	{
		Register.initializeRegisters(globalRegsiters);
	}
	
	public Processor(File biosFile, String...diskFiles) throws IOException
	{
		if(instance == null)
			instance = this;
		else
			ZeroDayExploit.throwFatal("Attempted to initialize the processor twice");
		this.bios = new RandomAccessFile(biosFile, "rw");
		for(String file : diskFiles)
			this.disks.push(new RandomAccessFile(new File(file), "rw"));
		MemoryUtil.loadFile(0, 0, 0xA545, getBiosImage());
	}
	
	public byte[] getMemorySegment(int start, int length)
	{
		byte[] toReturn = new byte[length];
		
		System.arraycopy(this.memory, start, toReturn, 0, length);
		
		return toReturn;
	}
	
	public void setMemorySegment(int start, byte...data)
	{
		System.arraycopy(data, 0, this.memory, start, data.length);
	}
	
	public byte getMemory(int addr)
	{
		return this.memory[addr];
	}
	
	public void setMemory(int addr, byte data)
	{
		this.memory[addr] = data;
	}
	
	public RandomAccessFile getBiosImage()
	{
		return this.bios;
	}
	
	public Register getRegisterPerMode(int id)
	{
		if(id == 18)
			return globalRegsiters.get("cpsr");
		
		if(this.mode != ProcessorMode.System32)
			return globalRegsiters.get("r"+id + "_" +this.mode.name());
		else
			return globalRegsiters.get("r"+id + "_User32");
	}
	
	public void setMode(ProcessorMode newMode)
	{
		System.out.println(Integer.toHexString(globalRegsiters.get("cpsr").getValue()));
		this.mode = newMode;
		globalRegsiters.get("cpsr").setValue((globalRegsiters.get("cpsr").getValue() & 0x00_ff_ff_ff) | this.mode.id);
		System.out.println(Integer.toHexString(globalRegsiters.get("cpsr").getValue()));
	}
	
	public ProcessorMode getMode()
	{
		return this.mode;
	}
	
	public void haltProcessor()
	{
		toExit = true;
	}
	
	//The method to end all methods
	public void execute(int position)
	{
		this.getRegisterPerMode(15).setValue(position);
		while(!toExit && AsmCore.fromBytes(this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4)) != 0)//this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4)[0] != 0)
		{
			int inst = AsmCore.fromBytes(this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4));
			
			if (AsmCore.isCondition(inst))
				try {
					Instructions.class.getDeclaredMethod(AsmCore.guessCode(inst), int.class).invoke(null, inst);
				} catch (IllegalAccessException | IllegalArgumentException
						| InvocationTargetException | NoSuchMethodException
						| SecurityException e) {
					System.err.println("Processor halted while attempting " + AsmCore.guessCode(inst));
					e.printStackTrace();
					this.haltProcessor();
				}
			else
				System.out.println("Ignored a(n) " + AsmCore.guessCode(inst) + " instruction due to condition codes");
			this.getRegisterPerMode(15).setValue(this.getRegisterPerMode(15).getValue() + 4);
		}
	}
}