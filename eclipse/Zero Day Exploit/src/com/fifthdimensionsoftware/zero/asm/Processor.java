package com.fifthdimensionsoftware.zero.asm;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.LinkedList;

import org.lwjgl.input.Mouse;
import org.newdawn.slick.Color;
import org.newdawn.slick.Graphics;

import com.fifthdimensionsoftware.zero.ZeroDayExploit;
import com.fifthdimensionsoftware.zero.graphics.GLComplex;
import com.fifthdimensionsoftware.zero.graphics.GraphicsUtil;
import com.fifthdimensionsoftware.zero.graphics.RenderAction;
import com.fifthdimensionsoftware.zero.tools.GameUtil;
import com.fifthdimensionsoftware.zero.tools.MemoryUtil;
import com.fifthdimensionsoftware.zero.tools.MouseUtil;

public class Processor
{	
	public static class Instructions
	{
		private static boolean fill = false;
		
		public static void NOP(int opcode)
		{
			System.err.println("Encountered a NOP : " + Integer.toBinaryString(opcode));
			System.err.println(Processor.instance.getRegisterPerMode(15).toString());
			System.exit(1);
		}
		
		public static void GQTM(int opcode)
		{
			Register qntm = Processor.instance.getRegisterPerMode(opcode & 0b1111);
			
			qntm.setValue(Processor.instance.getRegisterPerMode(18).getValue() & 0b1111_1111_1111_1111_1111_1111_1111);
		}
		
		public static void QNTM(int opcode)
		{
			int qntm = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue();
			
			Processor.instance.getRegisterPerMode(18).setValue(Processor.instance.getRegisterPerMode(18).getValue() | (qntm & 0b1111_1111_1111_1111_1111_1111_1111));
		}
		
		public static void SEC(int opcode)
		{
			int start = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue(), length = Processor.instance.getRegisterPerMode((opcode >> 4) & 0b1111).getValue();
			boolean	sec = Processor.instance.getRegisterPerMode((opcode >> 8) & 0b1111).getValue() != 0;
			
			Processor.instance.secureRegion(start, length, sec);
		}
		
		public static void SCR(int opcode)
		{
			Register x = Processor.instance.getRegisterPerMode(opcode & 0b1111);
			Register y = Processor.instance.getRegisterPerMode((opcode >> 4) & 0b1111);
			
			x.setValue(GraphicsUtil.getScreenWidth());
			y.setValue(GraphicsUtil.getScreenHeight());
		}
		
		public static void ROT(int opcode)
		{
			int x = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue(), y = Processor.instance.getRegisterPerMode((opcode >> 4) & 0b1111).getValue(), o = Processor.instance.getRegisterPerMode((opcode >> 8) & 0b1111).getValue();
			
			GameUtil.setRotate(x, y, o);
		}
		
		public static void MOUSE(int opcode)
		{
			Register x = Processor.instance.getRegisterPerMode(opcode & 0b1111);
			Register y = Processor.instance.getRegisterPerMode((opcode >> 4) & 0b1111);
			
			x.setValue(Mouse.getX());
			y.setValue(MouseUtil.getY());
		}
		
		public static void TEXT(int opcode)
		{
			float x = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue(), y = Processor.instance.getRegisterPerMode((opcode >> 4) & 0b1111).getValue(), off = Processor.instance.getRegisterPerMode((opcode >> 8) & 0b1111).getValue();
			
			byte[] textBytes = {};
			
			byte[] oldBytes = textBytes;
			textBytes = new byte[textBytes.length + 1];
			System.arraycopy(oldBytes, 0, textBytes, 0, oldBytes.length);
			textBytes[oldBytes.length] = Processor.instance.getMemory((int) (off + oldBytes.length));
			
			while(textBytes[textBytes.length - 1] != 0)
			{
				oldBytes = textBytes;
				textBytes = new byte[textBytes.length + 1];
				System.arraycopy(oldBytes, 0, textBytes, 0, oldBytes.length);
				textBytes[oldBytes.length] = Processor.instance.getMemory((int) (off + oldBytes.length));
			}
			
			try {
//				System.out.println("TEXT : \"" + new String(textBytes, "UTF-8") + "\"");
				GameUtil.renderQueue.push(new RenderAction(Graphics.class.getDeclaredMethod("drawString", String.class, float.class, float.class), GLComplex.gc.getGraphics(), new String(textBytes, "UTF-8").replace((char) 13, '\n'), x, y));
			} catch (NoSuchMethodException | SecurityException | UnsupportedEncodingException e) {
				e.printStackTrace();
			}
		}
		
		public static void GCOLOR(int opcode)
		{
			Register dest = Processor.instance.getRegisterPerMode(opcode & 0b1111);
			
			dest.setValue((GLComplex.gc.getGraphics().getColor().getRedByte() << 24) | (GLComplex.gc.getGraphics().getColor().getGreenByte() << 16) | (GLComplex.gc.getGraphics().getColor().getBlueByte() << 8) | (GLComplex.gc.getGraphics().getColor().getAlphaByte() << 0));
		}
		
		public static void COLOR(int opcode)
		{
			int value = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue();
			Color toSet = new Color((value >> 24) & 0xff, (value >> 16) & 0xff, (value >> 8) & 0xff, (value >> 0) & 0xff);
			try {
				GameUtil.renderQueue.push(new RenderAction(Graphics.class.getDeclaredMethod("setColor", Color.class), GLComplex.gc.getGraphics(), toSet));
			} catch (NoSuchMethodException | SecurityException e) {
				e.printStackTrace();
			}
		}
		
		public static void LSR(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			args[1] = Processor.instance.getRegisterPerMode(args[1]).getValue();
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(args[1] << args[2]);
		}
		
		public static void LSL(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			args[1] = Processor.instance.getRegisterPerMode(args[1]).getValue();
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(args[1] << args[2]);
		}
		
		public static void ASR(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			args[1] = Processor.instance.getRegisterPerMode(args[1]).getValue();
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(args[1] >>> args[2]);
		}
		
		public static void OVL(int opcode)
		{
			float x = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue(), y = Processor.instance.getRegisterPerMode((opcode >> 4) & 0b1111).getValue(), w = Processor.instance.getRegisterPerMode((opcode >> 8) & 0b1111).getValue(), h = Processor.instance.getRegisterPerMode((opcode >> 12) & 0b1111).getValue();
			
			if(fill)
				try {
					GameUtil.renderQueue.push(new RenderAction(Graphics.class.getDeclaredMethod("fillOval", float.class, float.class, float.class, float.class), GLComplex.gc.getGraphics(), x, y, w, h));
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
			else
				try {
					GameUtil.renderQueue.push(new RenderAction(Graphics.class.getDeclaredMethod("drawOval", float.class, float.class, float.class, float.class), GLComplex.gc.getGraphics(), x, y, w, h));
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
		}
		
		public static void RECT(int opcode)
		{
			float x = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue(), y = Processor.instance.getRegisterPerMode((opcode >> 4) & 0b1111).getValue(), w = Processor.instance.getRegisterPerMode((opcode >> 8) & 0b1111).getValue(), h = Processor.instance.getRegisterPerMode((opcode >> 12) & 0b1111).getValue();
			
			if(fill)
				try {
					GameUtil.renderQueue.push(new RenderAction(Graphics.class.getDeclaredMethod("fillRect", float.class, float.class, float.class, float.class), GLComplex.gc.getGraphics(), x, y, w, h));
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
			else
				try {
					GameUtil.renderQueue.push(new RenderAction(Graphics.class.getDeclaredMethod("drawRect", float.class, float.class, float.class, float.class), GLComplex.gc.getGraphics(), x, y, w, h));
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
		}
		
		public static void FILL(int opcode)
		{
			fill = true;
		}
		
		public static void DRAW(int opcode)
		{
			fill = false;
		}
		
		public static void CLR(int opcode)
		{
			GameUtil.queueClear();
			
			/*try {
				GameUtil.renderQueue.add(new RenderAction(Graphics.class.getDeclaredMethod("clear"), GLComplex.gc.getGraphics()));
			} catch (NoSuchMethodException | SecurityException e) {
				e.printStackTrace();
			}*/
		}
		
		public static void DSTR(int opcode)
		{
			if(Processor.instance.getMode() == ProcessorMode.USR)
			{
				GameUtil.throwNonFatal("Cannot store to the disk from user mode");
				return;
			}
			
			int memStart = Processor.instance.getRegisterPerMode((opcode >> 8) & 0b1111).getValue(), diskStart = Processor.instance.getRegisterPerMode((opcode >> 4) & 0b1111).getValue(), length = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue(), id = (opcode >> 12) & 0b111_1111_1111;
			
			if(((opcode >> 23) & 0b1) == 0b1)
				id = Processor.instance.getRegisterPerMode(id).getValue();
			
			MemoryUtil.saveDiskRegion(memStart, diskStart, length, id);
		}

		public static void DLDR(int opcode)
		{
//			System.out.println(Integer.toBinaryString(opcode));
			
			int memStart = Processor.instance.getRegisterPerMode((opcode >> 8) & 0b1111).getValue(), diskStart = Processor.instance.getRegisterPerMode((opcode >> 4) & 0b1111).getValue(), length = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue(), id = (opcode >> 12) & 0b111_1111_1111;
			
			if(((opcode >> 23) & 0b1) == 0b1)
				id = Processor.instance.getRegisterPerMode(id).getValue();
			
//			System.out.println(memStart + " : " + diskStart + " : " + length + " : " + id);
			
			MemoryUtil.loadDiskRegion(memStart, diskStart, length, id);
		}

		public static void CTD(int opcode)
		{
			Processor.instance.getRegisterPerMode(opcode & 0b1111).setValue(Processor.instance.disks.size());
		}

		public static void CPM(int opcode)
		{
			for(ProcessorMode mode : ProcessorMode.values())
				if(mode.id == (opcode & 0b1111))
					Processor.instance.setMode(mode);
		}

		public static void HLT(int opcode)
		{
			if (Processor.instance.mode != ProcessorMode.USR)
			{
				System.out.println("System Halted");
				Processor.instance.haltProcessor();
			}
			else
				GameUtil.throwNonFatal("Cannot halt from user mode");
		}

		public static void PUSH(int opcode)
		{
			int val = Processor.instance.getRegisterPerMode(13).getValue();
			int off = AsmCore.fromBytes(Processor.instance.getMemorySegment(val, 4));
			
			Processor.instance.setMemorySegment(val + off, AsmCore.toBytes(Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue()));
			Processor.instance.setMemorySegment(val, AsmCore.toBytes(off + 4));
		}

		public static void POP(int opcode)
		{
			int val = Processor.instance.getRegisterPerMode(13).getValue();
			int off = AsmCore.fromBytes(Processor.instance.getMemorySegment(val, 4)) - 4;
			
			Processor.instance.getRegisterPerMode(opcode & 0b1111).setValue(AsmCore.fromBytes(Processor.instance.getMemorySegment(val + off, 4)));
			Processor.instance.setMemorySegment(val, AsmCore.toBytes(off));
		}

		public static void B(int opcode)
		{
			int toJump = opcode & 0b1111_1111_1111_1111_1111_1111;
			
			toJump = AsmCore.expandInt(toJump, 24);
			
			toJump -= 4;
			
			Processor.instance.getRegisterPerMode(15).setValue(Processor.instance.getRegisterPerMode(15).getValue() + toJump);
		}

		public static void BL(int opcode)
		{
			Processor.instance.getRegisterPerMode(14).setValue(Processor.instance.getRegisterPerMode(15).getValue());
			
			B(opcode);
		}

		public static void BX(int opcode)
		{
			int toJump = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue();
			int mode = (opcode & 0b11110000) >> 4;
			
			for(ProcessorMode tmpMode : ProcessorMode.values())
				if(tmpMode.id == (mode))
					Processor.instance.setMode(tmpMode);
			
			Processor.instance.getRegisterPerMode(15).setValue(toJump);
		}

		public static void STR(int opcode)
		{
			int[] parsed = parseDataOp(opcode);
			
			Processor.instance.setMemorySegment(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue(), (byte)((Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111_0000_0000_0000_0000_0000_0000) >> 24), (byte)((Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111_0000_0000_0000_0000) >> 16), (byte)((Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111_0000_0000) >> 8), (byte)(Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111));
		}

		public static void LDR(int opcode)
		{
			int[] parsed = parseDataOp(opcode);
			
			Processor.instance.getRegisterPerMode(parsed[1]).setValue(AsmCore.fromBytes(Processor.instance.getMemorySegment(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue(), 4)));
//			System.out.println("Read " + Processor.instance.getRegisterPerMode(parsed[1]).getValue());
		}

		public static void STRB(int opcode)
		{
			int[] parsed = parseDataOp(opcode);
			
			Processor.instance.setMemory(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue(), (byte)(Processor.instance.getRegisterPerMode(parsed[1]).getValue() & 0b1111_1111));
		}

		public static void LDRB(int opcode)
		{
			int[] parsed = parseDataOp(opcode);
			
			Processor.instance.getRegisterPerMode(parsed[1]).setValue(Processor.instance.getMemory(parsed[2] + Processor.instance.getRegisterPerMode(parsed[0]).getValue()));
		}

		public static void SWP(int opcode)
		{
			int[] toReturn = new int[3];
			
			toReturn[0] = Processor.instance.getRegisterPerMode(opcode >> 16 & 0b1111).getValue();
			Register dest = Processor.instance.getRegisterPerMode(opcode >> 12 & 0b1111);
			
			toReturn[2] = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue();
			
			int tmpVal = AsmCore.fromBytes(Processor.instance.getMemorySegment(toReturn[0] + toReturn[2], 4));
			Processor.instance.setMemorySegment(toReturn[0] + toReturn[2], AsmCore.toBytes(dest.getValue()));
			dest.setValue(tmpVal);
		}

		public static void SWPB(int opcode)
		{
			int[] toReturn = new int[3];
			
			toReturn[0] = Processor.instance.getRegisterPerMode(opcode >> 16 & 0b1111).getValue();
			Register dest = Processor.instance.getRegisterPerMode(opcode >> 12 & 0b1111);
			
			toReturn[2] = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue();
			
			byte tmpVal = Processor.instance.getMemory(toReturn[0] + toReturn[2]);
			Processor.instance.setMemory(toReturn[0] + toReturn[2], (byte) (dest.getValue() & 0b1111_1111));
			dest.setValue(tmpVal);
		}

		public static void MUL(int opcode)
		{
			Register dest = Processor.instance.getRegisterPerMode((opcode >> 16) & 0b1111);
			dest.setValue(Processor.instance.getRegisterPerMode((opcode >> 12) & 0b1111).getValue() * Processor.instance.getRegisterPerMode((opcode) & 0b1111).getValue());
		}
		
		public static void DIV(int opcode)
		{
			Register dest = Processor.instance.getRegisterPerMode((opcode >> 16) & 0b1111);
			dest.setValue(Processor.instance.getRegisterPerMode((opcode >> 12) & 0b1111).getValue() / Processor.instance.getRegisterPerMode((opcode) & 0b1111).getValue());
		}

		public static void SVC(int opcode)
		{
			int intrupt = opcode & 0b111111111111111111111111;
			
			int tmpAddr = Processor.instance.getRegisterPerMode(15).getValue();
			
			Processor.instance.getRegisterPerMode(15).setValue(AsmCore.fromBytes(Processor.instance.getMemorySegment((Processor.instance.getRegisterPerMode(12).getValue()) + (intrupt * 4), 4)));
			
			Processor.instance.setMode(ProcessorMode.IRQ);
			
			Processor.instance.getRegisterPerMode(14).setValue(tmpAddr);
		}

		public static void EOR(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(Processor.instance.getRegisterPerMode(args[1]).getValue() ^ args[2]);
		}

		public static void SUB(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(Processor.instance.getRegisterPerMode(args[1]).getValue() - args[2]);
		}

		public static void RSB(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(args[2] - Processor.instance.getRegisterPerMode(args[1]).getValue());
		}

		public static void ADD(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(Processor.instance.getRegisterPerMode(args[1]).getValue() + args[2]);
		}

		public static void TST(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			int op1 = Processor.instance.getRegisterPerMode(ops[1]).getValue();
			
			op1 &= ops[2];
			AsmCore.setCPSR(op1 < 0, op1 == 0, false, false);
		}

		public static void TEQ(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			int op1 = Processor.instance.getRegisterPerMode(ops[1]).getValue();
			
			op1 ^= ops[2];
			AsmCore.setCPSR(op1 < 0, op1 == 0, false, false);
		}

		public static void CMP(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			int op1 = Processor.instance.getRegisterPerMode(ops[1]).getValue();
			
//			System.out.println(op1 + " : " + ops[2] + " : " + (op1 - ops[2]) + " - " + (op1 - ops[2] < 0) + " : " + (op1 - ops[2] == 0));
			
			AsmCore.setCPSR(op1 - ops[2] < 0, op1 - ops[2] == 0, false, false);
		}

		public static void CMN(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			int op1 = Processor.instance.getRegisterPerMode(ops[1]).getValue();
			
			op1 += ops[2];
			AsmCore.setCPSR(op1 < 0, op1 == 0, false, false);
		}

		public static void ORR(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(Processor.instance.getRegisterPerMode(args[1]).getValue() | args[2]);
		}

		public static void MOV(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			Register dest = Processor.instance.getRegisterPerMode(ops[1]);
			dest.setValue(ops[2]);
			
//			System.out.println("MOV : " + dest.toString());
		}

		public static void BIC(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(Processor.instance.getRegisterPerMode(args[1]).getValue() & ~args[2]);
		}

		public static void MVN(int opcode)
		{
			int[] ops = parseDataOp(opcode);
			Register dest = Processor.instance.getRegisterPerMode(ops[1]);
			
			dest.setValue(~ops[2]);
		}

		public static void AND(int opcode)
		{
			int[] args = parseDataOp(opcode);
			
			Processor.instance.getRegisterPerMode(args[0]).setValue(Processor.instance.getRegisterPerMode(args[1]).getValue() & args[2]);
		}

		private static int[] parseDataOp(int opcode)
		{
			int[] toReturn = new int[3];
			
			toReturn[0] = opcode >> 16 & 0b1111;
			toReturn[1] = opcode >> 12 & 0b1111;
			
			if(((opcode & 0b10000_0_0000_0000_000000000000) >> 25) == 0b1)
			{
				toReturn[2] = opcode & 0b1111_1111_1111;
				toReturn[2] = AsmCore.expandInt(toReturn[2], 12);
				
			}else
				toReturn[2] = Processor.instance.getRegisterPerMode(opcode & 0b1111).getValue();
			
			return toReturn;
		}
	}
	
	public enum ProcessorMode {
		USR(0b1000), FIQ(0b0100), SUP(0b0010), ABT(0b0001), IRQ(0b1001), UNDEF(0b0101), SYS(0b0011);
		
		public byte id;
		
		private ProcessorMode(int id)
		{
			this.id = (byte) id;
		}
	}
	
	private LinkedList<RandomAccessFile> disks = new LinkedList<RandomAccessFile>();
	private RandomAccessFile bios;
	public byte[] memory = new byte[268435456];
	public byte[] memorySec = new byte[memory.length / 4];
	
	public static HashMap<String, Register> globalRegsiters = new HashMap<String, Register>();
	public static Processor instance;
	private ProcessorMode mode = ProcessorMode.UNDEF;
	private boolean toExit = false;
	private int toIntrupt = -1;
	
	
	public Processor(File biosFile, String...diskFiles) throws IOException
	{
		if(instance == null)
			instance = this;
		else
			ZeroDayExploit.throwFatal("Attempted to initialize the processor twice");
		
		Processor.globalRegsiters.clear();
		Register.initializeRegisters(globalRegsiters);
		
		this.bios = new RandomAccessFile(biosFile, "rw");
		for(String file : diskFiles)
		{
			this.disks.push(new RandomAccessFile(new File(file), "rw"));
		}
		MemoryUtil.loadFile(0, 0, 0xA545, getBiosImage());
	}
	
	public void queueIntrupt(int id)
	{
		this.toIntrupt = id;
	}
	
	public byte[] getMemorySegment(int start, int length)
	{
		byte[] toReturn = new byte[length];
		
		int index = 0;
		for(@SuppressWarnings("unused") byte tmp : toReturn)
		{
			toReturn[index] = this.getMemory(start + index);
			index++;
		}
		
		return toReturn;
	}
	
	public void setMemorySegment(int start, byte...data)
	{
		int index = 0;
		for(byte tmp : data)
		{
			this.setMemory(start + index, tmp);
			index++;
		}
	}
	
	public byte getMemory(int addr)
	{
		if((this.mode == ProcessorMode.USR && this.getSec(addr)) || this.mode != ProcessorMode.USR)
			return this.memory[addr];
		else
			return 0;
	}
	
	public void setMemory(int addr, byte data)
	{
		if((this.mode == ProcessorMode.USR && this.getSec(addr)) || this.mode != ProcessorMode.USR)
			this.memory[addr] = data;
		else
			this.memory[addr] = 0;
	}
	
	public void secureRegion(int start, int length, boolean isSecure)
	{
		if(this.mode != ProcessorMode.USR)
		{
			for(int loop = 0; loop < length; loop++)
				this.setSec(start + loop, isSecure);
		}
	}
	
	public boolean getSec(int addr)
	{
		return ((memorySec[addr / 4] >> (addr % 4)) & 0b1) == 0b1;
	}
	
	public void setSec(int addr, boolean toSet)
	{
		if(toSet)
			memorySec[addr / 4] |= 0b1 << (addr % 4);
		else
			memorySec[addr / 4] &= ~(0b1 << (addr % 4));
	}
	
	public RandomAccessFile getBiosImage()
	{
		return this.bios;
	}
	
	public Register getRegisterPerMode(int id)
	{
		if(id == 18)
			return globalRegsiters.get("cpsr");
		
		if(id == 15)
			return globalRegsiters.get("pc");
		
		if(this.mode != ProcessorMode.SYS)
			return globalRegsiters.get("r" + id + "_" +this.mode.name());
		else
			return globalRegsiters.get("r" + id + "_" + ProcessorMode.USR.name());
	}
	
	public void setMode(ProcessorMode newMode)
	{
		this.mode = newMode;
		System.out.println("Mode updated to " + newMode.name());
	}
	
	public ProcessorMode getMode()
	{
		return this.mode;
	}
	
	public void haltProcessor()
	{
		this.bios = null;
		this.disks.clear();
		this.memory = new byte[0];
		this.setMode(ProcessorMode.UNDEF);
		toExit = true;
	}
	
	public RandomAccessFile getDisk(int id)
	{
		return disks.get(id);
	}
	
	private int structCT = 0;
	
	//The method to end all methods
	public void execute(int position)
	{
		this.getRegisterPerMode(15).setValue(position);
		while(!toExit && AsmCore.fromBytes(this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4)) != 0)//this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4)[0] != 0)
		{
			int inst = AsmCore.fromBytes(this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4));
			
			if (AsmCore.isCondition(inst))
				try {
					/*if(!AsmCore.guessCode(inst).equals("B"))
						System.out.println(AsmCore.guessCode(inst) + "_" + Assembler.guessCondition(inst));*/
					Instructions.class.getDeclaredMethod(AsmCore.guessCode(inst), int.class).invoke(null, inst);
				} catch (IllegalAccessException | IllegalArgumentException
						| InvocationTargetException | NoSuchMethodException
						| SecurityException e) {
					System.err.println("Processor halted while attempting " + AsmCore.guessCode(inst));
					e.printStackTrace();
					this.haltProcessor();
				}
			else
				System.out.println("Ignored a" + (AsmCore.guessCode(inst).startsWith("A") || AsmCore.guessCode(inst).startsWith("E") || AsmCore.guessCode(inst).startsWith("I") || AsmCore.guessCode(inst).startsWith("O") || AsmCore.guessCode(inst).startsWith("U") ? "n " : " ") + AsmCore.guessCode(inst) + " instruction due to condition codes");
			this.getRegisterPerMode(15).setValue(this.getRegisterPerMode(15).getValue() + 4);
			
			if(this.toIntrupt >= 0)
			{
				int tmpAddr = Processor.instance.getRegisterPerMode(15).getValue();
				Processor.instance.getRegisterPerMode(15).setValue(AsmCore.fromBytes(Processor.instance.getMemorySegment(Processor.instance.getRegisterPerMode(12).getValue() + (this.toIntrupt * 4), 4)));
				Processor.instance.getRegisterPerMode(14).setValue(tmpAddr - 4);
				Processor.instance.setMode(ProcessorMode.FIQ);
				Processor.instance.getRegisterPerMode(14).setValue(tmpAddr - 4);

				this.toIntrupt = -1;
//				System.out.println("INTRUTPT : " + Processor.instance.getRegisterPerMode(15).getValue() + " POINTER : " + Processor.instance.getRegisterPerMode(12).getValue());
			}
			
			if((this.structCT >= (this.getRegisterPerMode(18).getValue() & 0b1111_1111_1111_1111_1111_1111_1111)) && (this.getRegisterPerMode(18).getValue() & 0b1111_1111_1111_1111_1111_1111_1111) != 0)
			{
				this.toIntrupt = 1;
				this.structCT = 0;
			}
			
			structCT++;
		}
		
		GameUtil.exitRuntime();
	}
}