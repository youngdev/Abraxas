package com.fifthdimensionsoftware.zero.asm;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.reflect.InvocationTargetException;
import java.util.Scanner;

import com.fifthdimensionsoftware.zero.ZeroDayExploit;

public class Assembler
{	
	@SuppressWarnings("unused")
	private static class Instructions
	{
		public static int B(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			int toReturn = 0;
			
			toReturn |= Integer.parseInt(args[0].replace("#", "")) & 0b1111_1111_1111_1111_1111_1111;
			
			return toReturn;
		}
		
		public static int BL(String data)
		{
			return B(data);
		}
		
		public static int MOV(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			int toReturn = 0;
			
			toReturn = writeDataOp(args[1].startsWith("#"), 0, Integer.parseInt(args[0].replace("R", "")), Integer.parseInt(args[1].replace("R", "").replace("#", "")));
			
			return toReturn;
		}
		
		private static int writeDataOp(boolean imm, int...args)
		{
			int toReturn = 0;
			
			toReturn |= (args[0] & 0b1111) << 16;
			toReturn |= (args[1] & 0b1111) << 12;
			if(imm)
			{
				toReturn |= 0b1_0000_0_0000_0000_000000000000;
				toReturn |= args[2] & 0b1111_1111_1111;
			}else
			{
				toReturn |= args[2] & 0b1111;
				
			}
			
			return toReturn;
		}
	}
	
	//Mnemonic | Data For Assembly | Mask For Execution
	public static final String[] opCodes = {
		//Branch Family
		"B_0000-101-0-0000-0000-0000-0000-0000-0000_0000-101-1-0000-0000-0000-0000-0000-0000",
		"BL_0000-101-1-0000-0000-0000-0000-0000-0000_0000-101-1-0000-0000-0000-0000-0000-0000",
		"BX_0000-0001-0010-1111-1111-1111-0001-0000_0000-1111-1111-111-1111-1111-1111-0000", //Use ONLY if we distinguish between THUMB and ARM state!
		
		//Coprocessor Family
		"STC_0000-110-0-0-0-0-0-0000-0000-0000-00000000_0000-111-0-0-0-0-1-0000-0000-0000-00000000",
		"LDC_0000-110-0-0-0-0-1-0000-0000-0000-00000000_0000-111-0-0-0-0-1-0000-0000-0000-00000000",
		"MCR_0000-1110-000-0-0000-0000-0000-000-1-0000_0000-1111-000-1-0000-0000-0000-000-1-0000",
		"MRC_0000-1110-000-1-0000-0000-0000-000-1-0000_0000-1111-000-1-0000-0000-0000-000-1-0000",
		"CDP_0000-1110-0000-0000-0000-0000-000-0-0000_0000-1111-0000-0000-0000-0000-000-1-0000",
		
		//Memory Operations Family
		"STM_0000-100-0-0-0-0-0-0000-0000-0000-0000-0000_0000-111-0-0-0-0-1-0000-0000-0000-0000-0000",
		"LDM_0000-100-0-0-0-0-1-0000-0000-0000-0000-0000_0000-111-0-0-0-0-1-0000-0000-0000-0000-0000",
		"STR_0000-01-0-0-0-0-0-0-0000-0000-0000-0000-0000_0000-11-0-0-0-0-0-1-0000-0000-0000-0000-0000",
		"LDR_0000-01-0-0-0-0-0-1-0000-0000-0000-0000-0000_0000-11-0-0-0-0-0-1-0000-0000-0000-0000-0000",
		"SWP_0000-00010-0-00-0000-0000-0000-1001-0000_0000-11111-0-11-0000-0000-1111-1111-0000",
		
		//Multiplication Family
		"MUL_0000-0000-0000-0000-0000-1001-0000-0000_0000-0000-0010-0000-0000-0000-1111-0000",
		"MLA_0000-0000-0010-0000-0000-1001-0000-0000_0000-0000-0010-0000-0000-0000-1111-0000",
		
		//PSR Operations Family
		"MRS_0000-00010-0-001111-0000-000000000000_0000-11111-0-111111-0000-111111111111",
		"MSR_0000-00010-0-1010011111-00000000-0000_0000-11111-0-1111111111-11111111-0000",
		
		//Interrupt Family
		"SWI_0000-1111-000000000000000000000000_0000-1111-000000000000000000000000",
		
		//Data Processing
		"AND_0000-00-0-0000-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"EOR_0000-00-0-0001-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"SUB_0000-00-0-0010-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"RSB_0000-00-0-0011-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"ADD_0000-00-0-0100-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"ADC_0000-00-0-0101-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"SBC_0000-00-0-0110-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"RSC_0000-00-0-0111-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"TST_0000-00-0-1000-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"TEQ_0000-00-0-1001-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"CMP_0000-00-0-1010-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"CMN_0000-00-0-1011-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"ORR_0000-00-0-1100-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"MOV_0000-00-0-1101-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"BIC_0000-00-0-1110-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"MVN_0000-00-0-1111-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
	};
	
	public static final String[] conditionCodes = {
		"EQ_0000",
		"NE_0001",
		"CS_0010",
		"CC_0011",
		"MI_0100",
		"PL_0101",
		"VS_0110",
		"VC_0111",
		"HI_1000",
		"LS_1001",
		"GE_1010",
		"LT_1011",
		"GT_1100",
		"LE_1101",
		"AL_1110",
	};
	
	public static void assemble(File toAssemble, File output) throws IOException
	{
		Scanner src = new Scanner(toAssemble);
		FileOutputStream os = new FileOutputStream(output);
		
		while(src.hasNextLine())
		{
			int finalCode = 0;
			
			String asmLine = src.nextLine().toUpperCase();
			String inst = asmLine.split(" ")[0];
			String condition = "";
			byte conditionCode = 0;
			int additionalCode = 0;
			
			parent : for(String tmpInst : opCodes)
			{
				tmpInst = tmpInst.replace("-", "");
				
				if(tmpInst.split("_")[0].equals(inst))
				{
					inst = tmpInst.split("_")[0];
					conditionCode = 0b1110;
					additionalCode = Integer.parseInt(tmpInst.split("_")[1], 2);
					break;
				}
				
				for(String tmpCond : conditionCodes)
				{
					tmpCond = tmpCond.replace("-", "");
					
					if((tmpInst.split("_")[0] + tmpCond.split("_")[0]).equals(inst))
					{
						inst = tmpInst.split("_")[0];
						condition = tmpCond.split("_")[0];
						conditionCode = Byte.parseByte(tmpCond.split("_")[1], 2);
						additionalCode = Integer.parseInt(tmpInst.split("_")[1], 2);
						break parent;
					}
				}
			}
			
			finalCode |= conditionCode;
			finalCode <<= 28;
			finalCode |= additionalCode;
			
			try {
				finalCode |= ZeroDayExploit.castTo(Instructions.class.getDeclaredMethod(inst, String.class).invoke(null, asmLine.replace(inst + condition, "")), Integer.class);
			} catch (IllegalAccessException | IllegalArgumentException
					| InvocationTargetException | NoSuchMethodException
					| SecurityException e) {
				e.printStackTrace();
			}
			
			os.write(new byte[]{(byte) (finalCode >> 24 & 0xFF), (byte) (finalCode >> 16 & 0xFF), (byte) (finalCode >> 8 & 0xff), (byte) (finalCode >> 0 & 0xff)});
		}
		
		os.close();
		src.close();
		
		System.err.println("Finished assembling " + toAssemble.getName() + " to " + output.getName());
	}
	
	public static String guessCondition(int opcode)
	{
		byte cond = (byte) (opcode >> 28 & 0xF);
		
		for(String tmpCond : conditionCodes)
		{
			if(Byte.parseByte(tmpCond.split("_")[1], 2) == cond)
				return tmpCond.split("_")[0];
		}
		
		return "AL";
	}
	
	public static void dissasemble(File inFile, File outFile) throws IOException
	{
		DataInputStream src = new DataInputStream(new FileInputStream(inFile));
		PrintStream os = new PrintStream(outFile);
		int tmpCode = 0;
		
		while(src.available() > 0)
		{
			tmpCode = src.readInt();
			os.println(AsmCore.guessCode(tmpCode) + guessCondition(tmpCode));
		}
		
		os.close();
		src.close();
	}
}
