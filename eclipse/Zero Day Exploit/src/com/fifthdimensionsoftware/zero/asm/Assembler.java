package com.fifthdimensionsoftware.zero.asm;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Scanner;

import com.fifthdimensionsoftware.zero.ZeroDayExploit;

public class Assembler
{
	public static class DeInstructions
	{
		public static String BX(int opcode)
		{
			return "R" + (opcode & 0b1111) + ", #" + ((opcode & 0b11110000) >> 4);
		}
		
		public static String SVC(int opcode)
		{
			return "#" + (opcode & 0b111111111111111111111111);
		}
		
		public static String BIC(int opcode)
		{
			return basic3Ops(opcode);
		}
		
		public static String AND(int opcode)
		{
			return basic3Ops(opcode);
		}
		
		public static String ORR(int opcode)
		{
			return basic3Ops(opcode);
		}
		
		public static String EOR(int opcode)
		{
			return basic3Ops(opcode);
		}
		
		public static String ADD(int opcode)
		{
			return basic3Ops(opcode);
		}
		
		public static String RSB(int opcode)
		{
			return basic3Ops(opcode);
		}
		
		public static String SUB(int opcode)
		{
			return basic3Ops(opcode);
		}
		
		public static String CTD(int opcode)
		{
			return "R" + (opcode & 0b1111);
		}
		
		public static String DSTR(int opcode)
		{
			if(((opcode >> 23) & 0b1) == 0b0)
				return ("R" + ((opcode >> 8) & 0b1111)) + ", " + ("R" + ((opcode >> 4) & 0b1111)) + ", " + ("R" + (opcode & 0b1111)) + ", #" + ((opcode >> 12) & 0b111_1111_1111);
			else
				return ("R" + ((opcode >> 8) & 0b1111)) + ", " + ("R" + ((opcode >> 4) & 0b1111)) + ", " + ("R" + (opcode & 0b1111)) + ", R" + ((opcode >> 12) & 0b1111);
		}
		
		public static String DLDR(int opcode)
		{
			return DSTR(opcode);
		}
		
		public static String CPM(int opcode)
		{
			return "#" + (opcode & 0b1111);
		}
		
		public static String PUSH(int opcode)
		{
			return "R" + (opcode & 0b1111);
		}
		
		public static String POP(int opcode)
		{
			return PUSH(opcode);
		}
		
		public static String MOV(int opcode)
		{
			return basic2Ops(opcode);
		}
		
		public static String MVN(int opcode)
		{
			return basic2Ops(opcode);
		}
		
		public static String CMN(int opcode)
		{
			return basic2Ops(opcode);
		}
		
		public static String CMP(int opcode)
		{
			return basic2Ops(opcode);
		}
		
		public static String TST(int opcode)
		{
			return basic2Ops(opcode);
		}
		
		public static String TEQ(int opcode)
		{
			return basic2Ops(opcode);
		}
		
		public static String STR(int opcode)
		{
			return basic3Ops(opcode);
		}
		
		public static String STRB(int opcode)
		{
			return basic3Ops(opcode);
		}
		
		public static String LDR(int opcode)
		{
			return basic3Ops(opcode);
		}
		
		public static String LDRB(int opcode)
		{
			return basic3Ops(opcode);
		}
		
		public static String SWP(int opcode)
		{
			String[] toReturn = new String[3];
			
			toReturn[0] = "R" + (opcode >> 16 & 0b1111);
			toReturn[1] = "R" + (opcode >> 12 & 0b1111);
				
			toReturn[2] = "R" + (opcode & 0b1111);
			
			return toReturn[0] + ", " + toReturn[1] + "," + toReturn[2];
		}
		
		public static String SWPB(int opcode)
		{
			return SWP(opcode);
		}
		
		public static String MUL(int opcode)
		{
			String[] toReturn = new String[3];
			
			toReturn[0] = "R" + (opcode >> 16 & 0b1111);
			toReturn[1] = "R" + (opcode >> 12 & 0b1111);
				
			toReturn[2] = "R" + (opcode & 0b1111);
			
			return toReturn[0] + ", " + toReturn[1] + ", " + toReturn[2];
		}
		
		public static String HLT(int opcode)
		{
			return "";
		}
		
		public static String B(int opcode)
		{
			return "#" + AsmCore.expandInt(opcode & 0b1111_1111_1111_1111_1111_1111, 24);
		}
		
		public static String BL(int opcode)
		{
			return B(opcode);
		}
		
		private static String basic2Ops(int opcode)
		{
			String[] ops = parseDataOp(opcode);
			
			return ops[1] + ", " + ops[2];
		}
		
		private static String basic3Ops(int opcode)
		{
			String[] ops = parseDataOp(opcode);
			
			return ops[0] + ", " + ops[1] + ", " + ops[2];
		}
		
		private static String[] parseDataOp(int opcode)
		{
			String[] toReturn = new String[3];
			
			toReturn[0] = "R" + (opcode >> 16 & 0b1111);
			toReturn[1] = "R" + (opcode >> 12 & 0b1111);
			
			if(((opcode & 0b10000_0_0000_0000_000000000000) >> 25) == 0b1)
			{
				toReturn[2] = "#" + AsmCore.expandInt(opcode & 0b1111_1111_1111, 12);
				
			}else
			{
				toReturn[2] = "R" + (opcode & 0b1111);
			}
			
			return toReturn;
		}
	}

	public static class Instructions
	{
		public static int SVC(String data)
		{
			return parseInt(data.replace(" ", "")) & 0b111111111111111111111111;
		}
		
		public static int BIC(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			
			return writeDataOp(args[2].startsWith("#"), parseInt(args[0]), parseInt(args[1]), parseInt(args[2]));
		}
		
		public static int AND(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			
			return writeDataOp(args[2].startsWith("#"), parseInt(args[0]), parseInt(args[1]), parseInt(args[2]));
		}
		
		public static int ORR(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			
			return writeDataOp(args[2].startsWith("#"), parseInt(args[0]), parseInt(args[1]), parseInt(args[2]));
		}
		
		public static int EOR(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			
			return writeDataOp(args[2].startsWith("#"), parseInt(args[0]), parseInt(args[1]), parseInt(args[2]));
		}
		
		public static int ADD(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			
			return writeDataOp(args[2].startsWith("#"), parseInt(args[0]), parseInt(args[1]), parseInt(args[2]));
		}
		
		public static int RSB(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			
			return writeDataOp(args[2].startsWith("#"), parseInt(args[0]), parseInt(args[1]), parseInt(args[2]));
		}
		
		public static int SUB(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			
			return writeDataOp(args[2].startsWith("#"), parseInt(args[0]), parseInt(args[1]), parseInt(args[2]));
		}
		
		public static int CTD(String data)
		{
			return parseInt(data.replace(" ", "")) & 0b1111;
		}
		
		public static int DSTR(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			int toReturn = 0;
			
			toReturn |= (parseInt(args[0]) & 0b1111) << 8;
			toReturn |= (parseInt(args[1]) & 0b1111) << 4;
			toReturn |= (parseInt(args[2]) & 0b1111);
			if(args[3].startsWith("#"))
				toReturn |= (parseInt(args[3]) & 0b111_1111_1111) << 12;
			else
			{
				toReturn |= (parseInt(args[3]) & 0b1111) << 12;
				toReturn |= 0b1 << 23;
			}
			
			return toReturn;
		}
		
		public static int DLDR(String data)
		{
			return DSTR(data);
		}
		
		public static int CPM(String data)
		{
			return parseInt(data.replace(" ", "")) & 0b1111;
		}
		
		public static int PUSH(String data)
		{
			return parseInt(data.replace(" ", "")) & 0b1111;
		}
		
		public static int POP(String data)
		{
			return PUSH(data);
		}
		
		public static int MUL(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			int toReturn = 0;
			
			toReturn |= (parseInt(args[0]) & 0b1111) << 16;
			toReturn |= (parseInt(args[1]) & 0b1111) << 12;
			toReturn |= (parseInt(args[2]) & 0b1111);
			
			return toReturn;
		}
		
		public static int TEQ(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			return writeDataOp(args[1].startsWith("#"), 0, parseInt(args[0]), parseInt(args[1]));
		}
		
		public static int TST(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			return writeDataOp(args[1].startsWith("#"), 0, parseInt(args[0]), parseInt(args[1]));
		}
		
		public static int CMN(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			return writeDataOp(args[1].startsWith("#"), 0, parseInt(args[0]), parseInt(args[1]));
		}
		
		public static int CMP(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			return writeDataOp(args[1].startsWith("#"), 0, parseInt(args[0]), parseInt(args[1]));
		}
		
		public static int STR(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			
			int toReturn = 0;
			toReturn |= (parseInt(args[0]) & 0b1111) << 16;
			toReturn |= (parseInt(args[1]) & 0b1111) << 12;
			if(!args[2].contains("R"))
			{
				toReturn |= 0b1_0_0_0_0_0_0000_0000_000000000000;
				toReturn |= parseInt(args[2]) & 0b1111_1111_1111;
			}else
			{
				toReturn |= parseInt(args[2]) & 0b1111;
				
			}
			
			return toReturn;
		}
		
		public static int STRB(String data)
		{
			return STR(data);
		}
		
		public static int LDR(String data)
		{
			return STR(data);
		}
		
		public static int LDRB(String data)
		{
			return LDR(data);
		}
		
		public static int HLT(String data)
		{
			return 0;
		}
		
		public static int B(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			
			return AsmCore.compressInt(parseInt(args[0].replace("#", "")), 24) & 0b1111_1111_1111_1111_1111_1111;
		}
		
		public static int BL(String data)
		{
			return B(data);
		}
		
		public static int BX(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			
			return (parseInt(args[0]) & 0b1111) | ((parseInt(args[1]) & 0b1111) << 4);
		}
		
		public static int MOV(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			int toReturn = 0;
			
			toReturn = writeDataOp(args[1].startsWith("#"), 0, parseInt(args[0]), parseInt(args[1]));
			
			return toReturn;
		}
		
		public static int SWP(String data)
		{
			String[] args = data.replace(" ", "").split(",");
			int toReturn = 0;
			
			toReturn |= (parseInt(args[0]) & 0b1111) << 16;
			toReturn |= (parseInt(args[1]) & 0b1111) << 12;
			
			toReturn |= parseInt(args[2]) & 0b1111;
			
			return toReturn;
		}
		
		public static int SWPB(String data)
		{
			return SWP(data);
		}
		
		public static int MVN(String data)
		{
			return MOV(data);
		}
		
		private static int writeDataOp(boolean imm, int...args)
		{
			int toReturn = 0;
			
			toReturn |= (args[0] & 0b1111) << 16;
			toReturn |= (args[1] & 0b1111) << 12;
			
			if(imm)
			{
				toReturn |= 0b1_0000_0_0000_0000_000000000000;
				toReturn |= AsmCore.compressInt(args[2], 12) & 0b1111_1111_1111;
			}else
				toReturn |= args[2] & 0b1111;
			
			return toReturn;
		}
		
		private static int parseInt(String data)
		{
			data = data.replace("#", "").replace("[", "").replace("]", "").replace("R", "");
			
			if(data.startsWith("0X"))
				return Integer.parseInt(data.replace("0X", ""), 16);
			if(data.startsWith("0B"))
				return Integer.parseInt(data.replace("0B", ""), 2);
			return Integer.parseInt(data);
		}
	}
	
	//Mnemonic | Data For Assembly | Mask For Execution
	public static final String[] opCodes = {
		//Processor Mode
		"DSTR_0000-1011-0000-0000-0000-0000-0000-0000_0000-1111-0000-0000-0000-0000-0000-0000",
		"DLDR_0000-1001-0000-0000-0000-0000-0000-0000_0000-1111-0000-0000-0000-0000-0000-0000",
		
		//Disk Counter
		"CTD_0000-0101-1111-1111-1111-1111-1111-0000_0000-1111-1111-1111-1111-1111-1111-0000",
		
		//Processor Mode
		"CPM_0000-1101-1111-1111-1111-1111-1111-0000_0000-1111-1111-1111-1111-1111-1111-0000",
		
		//Halt
		"HLT_0000-1111-1111-1111-1111-1111-1111-1111_0000-1111-1111-1111-1111-1111-1111-1111",
		
		//Stack Family
		"PUSH_0000-1110-0111-1111-1111-1111-1111-0000_0000-1111-1111-1111-1111-1111-1111-0000",
		"POP_0000-1110-1111-1111-1111-1111-1111-0000_0000-1111-1111-1111-1111-1111-1111-0000",
		
		//Branch Family
		"B_0000-101-0-0000-0000-0000-0000-0000-0000_0000-111-1-0000-0000-0000-0000-0000-0000",
		"BL_0000-101-1-0000-0000-0000-0000-0000-0000_0000-111-1-0000-0000-0000-0000-0000-0000",
		"BX_0000-0001-0010-1111-1111-1111-0000-0000_0000-1111-1111-1111-1111-1111-0000-0000", //Now exchanges modes while jumping
		
		//Coprocessor Family
		/*"STC_0000-110-0-0-0-0-0-0000-0000-0000-00000000_0000-111-0-0-0-0-1-0000-0000-0000-00000000",
		"LDC_0000-110-0-0-0-0-1-0000-0000-0000-00000000_0000-111-0-0-0-0-1-0000-0000-0000-00000000",
		"MCR_0000-1110-000-0-0000-0000-0000-000-1-0000_0000-1111-000-1-0000-0000-0000-000-1-0000",
		"MRC_0000-1110-000-1-0000-0000-0000-000-1-0000_0000-1111-000-1-0000-0000-0000-000-1-0000",
		"CDP_0000-1110-0000-0000-0000-0000-000-0-0000_0000-1111-0000-0000-0000-0000-000-1-0000",*/
		
		//Memory Operations Family
		"STR_0000-01-0-0-0-0-0-0-0000-0000-0000-0000-0000_0000-11-0-0-0-1-0-1-0000-0000-0000-0000-0000",
		"LDR_0000-01-0-0-0-0-0-1-0000-0000-0000-0000-0000_0000-11-0-0-0-1-0-1-0000-0000-0000-0000-0000",
		"STRB_0000-01-0-0-0-1-0-0-0000-0000-0000-0000-0000_0000-11-0-0-0-1-0-1-0000-0000-0000-0000-0000",
		"LDRB_0000-01-0-0-0-1-0-1-0000-0000-0000-0000-0000_0000-11-0-0-0-1-0-1-0000-0000-0000-0000-0000",
		"SWP_0000-00010-0-00-0000-0000-0000-1001-0000_0000-11111-1-11-0000-0000-1111-1111-0000",
		"SWPB_0000-00010-1-00-0000-0000-0000-1001-0000_0000-11111-1-11-0000-0000-1111-1111-0000",
		
		//Multiplication
		"MUL_0000-0000-0000-0000-0000-0000-1001-0000_0000-0000-0010-0000-0000-0000-1111-0000",
		//"MLA_0000-0000-0010-0000-0000-1001-0000-0000_0000-0000-0010-0000-0000-0000-1111-0000",
		
		//PSR Operations Family - Used to operate on the CPSR / SPSR
		/*"MRS_0000-00010-0-001111-0000-000000000000_0000-11111-0-111111-0000-111111111111",
		"MSR_0000-00010-0-1010011111-00000000-0000_0000-11111-0-1111111111-11111111-0000",*/
		
		//Interrupt
		"SVC_0000-1111-000000000000000000000000_0000-1111-000000000000000000000000",
		
		//Data Processing
		"EOR_0000-00-0-0001-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"SUB_0000-00-0-0010-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"RSB_0000-00-0-0011-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"ADD_0000-00-0-0100-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		//"ADC_0000-00-0-0101-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		//"SBC_0000-00-0-0110-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		//"RSC_0000-00-0-0111-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"TST_0000-00-0-1000-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"TEQ_0000-00-0-1001-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"CMP_0000-00-0-1010-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"CMN_0000-00-0-1011-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"ORR_0000-00-0-1100-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"MOV_0000-00-0-1101-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"BIC_0000-00-0-1110-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"MVN_0000-00-0-1111-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
		"AND_0000-00-0-0000-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000",
	};
	
	public static final String[] conditionCodes = {
		"EQ_0000",
		"NE_0001",
		"CS_0010",
		"CC_0011",
		"MI_0100",
		"PL_0101",
		"VS_0110",
		"VC_0111",
		"HI_1000",
		"LS_1001",
		"GE_1010",
		"LT_1011",
		"GT_1100",
		"LE_1101",
		"AL_1110",
	};
	
	public static void assemble(File toAssemble, File output) throws IOException
	{
		Scanner src = new Scanner(toAssemble);
		FileOutputStream os = new FileOutputStream(output);
		
		HashMap<String, Integer> labelMap = new HashMap<String, Integer>();
		HashMap<String, String> constMap = new HashMap<String, String>();
		
		int off = 0;
		
		while(src.hasNextLine())
		{
			String asmLine = src.nextLine().toUpperCase().trim().replace("\t", "");
			
			if(asmLine.endsWith(":") && asmLine.startsWith(":"))
			{
				labelMap.put(asmLine.replace(":", ""), off);
				System.err.println("Attatched label " + asmLine + " to address " + off);
			}
			
			if(asmLine.endsWith("?") && asmLine.startsWith("?"))
				constMap.put(asmLine.replace(" ", "").replace("?", "").split("=")[0], asmLine.replace(" ", "").replace("?", "").split("=")[1]);
			
			if(asmLine.startsWith(";") || asmLine.isEmpty() || (asmLine.endsWith(":") & asmLine.startsWith(":")) || (asmLine.endsWith("?") && asmLine.startsWith("?")))
				continue;
			
			off++;
		}
		
		src.close();
		src = new Scanner(toAssemble);
		off = 0;
		
		while(src.hasNextLine())
		{
			int finalCode = 0;
			
			String asmLine = src.nextLine().toUpperCase().trim().replace("\t", "");
			String inst = asmLine.split(" ")[0];
			String condition = "";
			int conditionCode = 0;
			int additionalCode = 0;
			
			if(asmLine.startsWith(";") || asmLine.isEmpty() || (asmLine.endsWith(":") & asmLine.startsWith(":")) || (asmLine.endsWith("?") && asmLine.startsWith("?")))
				continue;
			
			
			for(String label : labelMap.keySet())
			{
				if(asmLine.contains(":" + label + ":"))
				{
					System.err.println("Replaced instance of label " + label);
					asmLine = asmLine.replace(":" + label + ":", ""+ (labelMap.get(label) * 4 - off * 4));
				}
			}
			
			parent : for(String tmpInst : opCodes)
			{
				tmpInst = tmpInst.replace("-", "");
				
				if(tmpInst.split("_")[0].equals(inst))
				{
					inst = tmpInst.split("_")[0];
					conditionCode = 0b1110;
					additionalCode = Integer.parseInt(tmpInst.split("_")[1], 2);
					break;
				}
				
				for(String tmpCond : conditionCodes)
				{
					tmpCond = tmpCond.replace("-", "");
					
					if((tmpInst.split("_")[0] + tmpCond.split("_")[0]).equals(inst))
					{
						inst = tmpInst.split("_")[0];
						condition = tmpCond.split("_")[0];
						conditionCode = Integer.parseInt(tmpCond.split("_")[1], 2);
						additionalCode = Integer.parseInt(tmpInst.split("_")[1], 2);
						break parent;
					}
				}
			}
			
			finalCode |= conditionCode;
			finalCode <<= 28;
			finalCode |= additionalCode;
			
			for(String constVal : constMap.keySet())
			{
				if(asmLine.replace(inst + condition, "").contains(constVal))
				{
					System.err.println("Replaced instance of constant " + constVal);
					asmLine = asmLine.replace(inst + condition, "").replace(constVal, constMap.get(constVal));
				}
			}
			
			try {
				finalCode |= ZeroDayExploit.castTo(Instructions.class.getDeclaredMethod(inst, String.class).invoke(null, asmLine.replace(inst + condition, "")), Integer.class);
			} catch (IllegalAccessException | IllegalArgumentException
					| InvocationTargetException | NoSuchMethodException
					| SecurityException e) {
				e.printStackTrace();
			}
			
			os.write(new byte[]{(byte) (finalCode >> 24 & 0xFF), (byte) (finalCode >> 16 & 0xFF), (byte) (finalCode >> 8 & 0xff), (byte) (finalCode >> 0 & 0xff)});
			off++;
		}
		
		os.close();
		src.close();
		
		System.err.println("Finished assembling " + toAssemble.getName() + " to " + output.getName());
	}
	
	public static String guessCondition(int opcode)
	{
		byte cond = (byte) (opcode >> 28 & 0xF);
		
		for(String tmpCond : conditionCodes)
		{
			if(Byte.parseByte(tmpCond.split("_")[1], 2) == cond)
				return tmpCond.split("_")[0].equals("AL") ? "" : tmpCond.split("_")[0];
		}
		
		return "";
	}
	
	public static void disasemble(File inFile, File outFile) throws IOException
	{
		DataInputStream src = new DataInputStream(new FileInputStream(inFile));
		PrintStream os = new PrintStream(outFile);
		int tmpCode = 0;
		
		while(src.available() > 0)
		{
			tmpCode = src.readInt();
			try {
				os.println("\t" + AsmCore.guessCode(tmpCode) + guessCondition(tmpCode) + " " + ZeroDayExploit.castTo(DeInstructions.class.getDeclaredMethod(AsmCore.guessCode(tmpCode), int.class).invoke(null, tmpCode), String.class));
			} catch (IllegalAccessException | IllegalArgumentException
					| InvocationTargetException | NoSuchMethodException
					| SecurityException e) {
				e.printStackTrace();
			}
		}
		
		os.close();
		src.close();
		
		System.err.println("Finished disassembling " + inFile.getName() + " to " + outFile.getName());
	}
}
