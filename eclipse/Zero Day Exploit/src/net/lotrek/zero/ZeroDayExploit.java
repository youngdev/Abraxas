package net.lotrek.zero;

// ______ _______  ______  _____       ______  _______ __   __
//	____/ |______ |_____/ |     |      |     \ |_____|   \_/  
// /_____ |______ |    \_ |_____|      |_____/ |     |    |   
//                                                        
//  _______ _     _  _____          _____  _____ _______  
//  |______  \___/  |_____] |      |     |   |      |     
//  |______ _/   \_ |       |_____ |_____| __|__    |     

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Properties;
import java.util.Scanner;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileFilter;

import net.lotrek.zero.engine.Assembler;
import net.lotrek.zero.engine.Instructions;
import net.lotrek.zero.engine.Processor;
import net.lotrek.zero.engine.Register;
import net.lotrek.zero.graphics.GLComplex;
import net.lotrek.zero.graphics.GraphicsUtil;
import net.lotrek.zero.tools.GameUtil;
import net.lotrek.zero.tools.MultiplexOutputStream;
import net.lotrek.zero.tools.ZipUtil;

public class ZeroDayExploit
{
	private static HashMap<String, Boolean> globalKeys = new HashMap<String, Boolean>();
	public static String[] args;
	
	public static boolean getKey(String name)
	{
		return globalKeys.containsKey(name) ? globalKeys.get(name) : false;
	}
	
	public static void setKey(String name, boolean value)
	{
		globalKeys.put(name, value);
	}
	
	public static void main(String[] args)
	{
		for(String arg : args)
			globalKeys.put(arg, true);
		
		ZeroDayExploit.args = args;
		
		//Multiplex the terminal output
		try {
			MultiplexOutputStream.multiplexConsole(new FileOutputStream(new File("logFile.log"), false));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		
		//Initiate special opcodes
		if(getKey("--plugins"))
		{
			for(File item : new File("plugins").listFiles())
				loadPlugin("plugins/", item);
				/*if(item.isFile() && item.getName().endsWith(".bin"))
				{
					loadClasses(item.getAbsolutePath());
					Properties infoProp = new Properties();
					try {
						infoProp.load(ZipUtil.getStreamForFile("plugins/" + item.getName() + "/info"));
					} catch (IOException e) {
						e.printStackTrace();
					}
					
					Scanner src = new Scanner(ZipUtil.getStreamForFile("plugins/" + item.getName() + "/proc"));
					
					int oldStruct = Assembler.opCodes.size();
					
					while(src.hasNextLine())
						Assembler.opCodes.add(src.nextLine());
					
					src.close();
					
					isMod = true;
					
					System.out.println("Loaded " + infoProp.getProperty("author", "UNKNOWN") + "'s plugin \"" + infoProp.getProperty("name", item.getName()) + "\", added " + (Assembler.opCodes.size() - oldStruct) + " instructions");
				}*/
		}
		
		if(getKey("-i"))
		{
			if (!args[1].endsWith(".raw"))
				GraphicsUtil.genBitmap(args[1], args[2]);
			else
				GraphicsUtil.genImage(args[1], args[2]);
			System.exit(0);
		}
		
		if(getKey("-a") && args.length > 1)
		{
			try {
				Assembler.assemble(new File(args[1]), new File(args[2]));
			} catch (IOException e) {
				e.printStackTrace();
			}
			System.exit(0);
		}else if(getKey("-a") && args.length == 1)
		{
			JFileChooser fc = new JFileChooser();
			
			fc.setDialogTitle("Open assembly source");
			fc.setFileFilter(new FileFilter()
			{

				@Override
				public boolean accept(File arg0)
				{
					return arg0.getName().endsWith(".asm") || arg0.isDirectory();
				}

				@Override
				public String getDescription() {
					return "Assembly Source";
				}
				
			});
			fc.showOpenDialog(null);
			
			File src = fc.getSelectedFile();
			
			fc.setDialogTitle("Choose output file");
			fc.setFileFilter(new FileFilter()
			{

				@Override
				public boolean accept(File arg0)
				{
					return arg0.getName().endsWith(".bin") || arg0.getName().endsWith(".bios") || arg0.getName().endsWith(".disk") || arg0.getName().endsWith(".img") || !arg0.getName().contains(".") || arg0.isDirectory();
				}

				@Override
				public String getDescription() {
					return "Binary File";
				}
				
			});
			fc.showSaveDialog(null);
			
			File out = fc.getSelectedFile();
			
			try {
				Assembler.assemble(src, out);
			} catch (IOException e) {
				e.printStackTrace();
			}
			JOptionPane.showMessageDialog(null, "Finished assembly of " + src.getName());
			System.exit(0);
		}
		
		if(getKey("-d") && args.length > 1)
		{
			try {
				Assembler.disasemble(new File(args[1]), new File(args[2]));
			} catch (IOException e) {
				e.printStackTrace();
			}
			System.exit(0);
		}else if(getKey("-d") && args.length == 1)
		{
			JFileChooser fc = new JFileChooser();
			
			fc.setDialogTitle("Open binary source");
			fc.setFileFilter(new FileFilter()
			{

				@Override
				public boolean accept(File arg0)
				{
					return arg0.getName().endsWith(".bin") || arg0.getName().endsWith(".bios") || arg0.getName().endsWith(".disk") || arg0.getName().endsWith(".img") || !arg0.getName().contains(".") || arg0.isDirectory();
				}

				@Override
				public String getDescription() {
					return "Binary File";
				}
				
			});
			
			fc.showOpenDialog(null);
			
			File src = fc.getSelectedFile();
			
			fc.setDialogTitle("Choose output file");
			fc.setFileFilter(new FileFilter()
			{

				@Override
				public boolean accept(File arg0)
				{
					return arg0.getName().endsWith(".asm") || arg0.isDirectory();
				}

				@Override
				public String getDescription() {
					return "Assembly Source";
				}
				
			});
			fc.showSaveDialog(null);
			
			File out = fc.getSelectedFile();
			
			try {
				Assembler.disasemble(src, out);
			} catch (IOException e) {
				e.printStackTrace();
			}
			JOptionPane.showMessageDialog(null, "Finished disassembly of " + src.getName());
			System.exit(0);
		}
		
		//Update the library path to the new directory
		String osname = System.getProperty("os.name", "generic").toLowerCase().startsWith("windows") ? "win" : System.getProperty("os.name", "generic").toLowerCase().startsWith("mac") || System.getProperty("os.name", "generic").toLowerCase().startsWith("darwin") ? "mac" : "linux";
		
	    System.err.println("Loading native libraries from "+"/natives/"+osname);
	    
	    //TOUCHY CODE!!! - Adds the natives folder to the path, the hard way
	    try {
			final Field usrPathsField = ClassLoader.class.getDeclaredField("usr_paths");
			usrPathsField.setAccessible(true);
 
			//get array of paths
			final String[] paths = (String[])usrPathsField.get(null);
 
			//add the new path
			final String[] newPaths = Arrays.copyOf(paths, paths.length + 1);
			newPaths[newPaths.length-1] = new File("").getAbsolutePath()+"\\natives\\"+osname;
			usrPathsField.set(null, newPaths);
		} catch (NoSuchFieldException | SecurityException
				| IllegalArgumentException | IllegalAccessException e1) {
			e1.printStackTrace();
		}
	    
		System.setProperty("org.lwjgl.librarypath", new File("").getAbsolutePath()+"\\natives\\"+osname);
		
		try {
			Method method = URLClassLoader.class.getDeclaredMethod("addURL", new Class[]{URL.class});
			method.setAccessible(true);
			method.invoke(ClassLoader.getSystemClassLoader(), new Object[]{new File("lib.bin").toURI().toURL()});
		} catch (MalformedURLException | NoSuchMethodException
				| SecurityException | IllegalAccessException
				| IllegalArgumentException | InvocationTargetException e) {
			e.printStackTrace();
		}
		
		//Sanity Check
		boolean isClean = true;
		for(String item : Assembler.opCodes)
		{
			item = item.split("_")[0];
			try {
				Instructions.Disassembly.class.getDeclaredMethod(item, int.class);
				Instructions.Assembly.class.getDeclaredMethod(item, String.class);
				Instructions.Execution.class.getDeclaredMethod(item, int.class);
			} catch (NoSuchMethodException | SecurityException e) {
				System.err.println("Instruction " + item + " failed the sanity check");
				isClean = false;
			}
		}
		
		if(isClean)
			System.err.println("Passed the sanity check");
		
		//Start the game
		GLComplex.beginGL();
	}
	
	public static void throwFatal(String message)
	{
		System.err.println("Crash Report " + Calendar.getInstance().getTime().toString() + ":");
		System.err.println("\tCrash Message: " + message);
		System.err.println("\tCommand Line Arguments: " + Arrays.toString(args).replace("[", "").replace("]", ""));
		System.err.println("\tGame State: " + GameUtil.getState());
		System.err.println("\tLoaded Data Files: " + Arrays.toString(ZipUtil.getFiles()).replaceAll("\\[|\\]", ""));
		System.err.println("\tAlternate Files: " + Arrays.toString(ZipUtil.alternateFiles.toArray()).replaceAll("\\[|\\]", ""));
		System.err.println("\tProcessor State: " + (Processor.getInstance() == null ? "Unloaded" : "Loaded - in mode " + Processor.getInstance().getMode()));
		
		if(Processor.getInstance() != null)
		{
			System.err.println("\tRegister Dump:");
			for(Register item : Processor.getInstance().getRegisters().values())
				System.err.println("\t\t" + item.toString());
			
			try {
				System.err.println("\tDumping virtual memory...");
				long prevTime = System.currentTimeMillis();
				String name = Calendar.getInstance().getTime().toString().split("\\ ")[3].replace(":", "") + ".dmp";
				RandomAccessFile dump = new RandomAccessFile(new File(name), "rw");
				dump.setLength(Processor.getInstance().memory.length);
				dump.write(Processor.getInstance().memory);
				dump.close();
				System.err.println("\tVirual memory dumped to " + name + " in " + (System.currentTimeMillis() - prevTime) + " milliseconds");
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		
		GLComplex.getContainer().exit();
	}
	
	public static <T> T castTo(Object toCast, Class<T> clazz)
	{
		return clazz.cast(toCast);
	}
	
	public static String getPath()
	{
		String osname = System.getProperty("os.name", "generic").toLowerCase().startsWith("windows") ? "win" : System.getProperty("os.name", "generic").toLowerCase().startsWith("mac") || System.getProperty("os.name", "generic").toLowerCase().startsWith("darwin") ? "mac" : "linux";
		
		try {
			if(osname.equals("win"))
				return URLDecoder.decode(ZeroDayExploit.class.getProtectionDomain().getCodeSource().getLocation().getPath().substring(1), "UTF-8");
			else
				return URLDecoder.decode(ZeroDayExploit.class.getProtectionDomain().getCodeSource().getLocation().getPath(), "UTF-8");
		}catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		return "";
	}
	
	public static boolean loadClasses(String path)
	{
		try {
			Method method = URLClassLoader.class.getDeclaredMethod("addURL", new Class[]{URL.class});
			method.setAccessible(true);
			method.invoke(ClassLoader.getSystemClassLoader(), new Object[]{new File(path).toURI().toURL()});
			return true;
		} catch (MalformedURLException | NoSuchMethodException
				| SecurityException | IllegalAccessException
				| IllegalArgumentException | InvocationTargetException e) {
			return false;
		}
	}
	
	public static void loadPlugin(String base, File item)
	{
		if(item.isFile() && item.getName().endsWith(".bin"))
		{
			loadClasses(item.getAbsolutePath());
			Properties infoProp = new Properties();
			try {
				infoProp.load(ZipUtil.getStreamForFile(base + item.getName() + "/info"));
			} catch (IOException e) {
				e.printStackTrace();
			}
			
			Scanner src = new Scanner(ZipUtil.getStreamForFile(base + item.getName() + "/proc"));
			
			int oldStruct = Assembler.opCodes.size();
			
			while(src.hasNextLine())
			{
				String line = src.nextLine();
				Assembler.opCodes.remove(Assembler.opMap.get(line.split("_")[0]));
				Assembler.opCodes.add(line);
				Assembler.opMap.put(line.split("_")[0], line);
			}
			
			src.close();
			
			System.out.println("Loaded " + infoProp.getProperty("author", "UNKNOWN") + "'s plugin \"" + infoProp.getProperty("name", item.getName()) + "\", added " + (Assembler.opCodes.size() - oldStruct) + " instructions");
		}
	}
}
