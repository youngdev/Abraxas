package net.lotrek.zero.tools;

import static net.lotrek.zero.ZeroDayExploit.castTo;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Properties;
import java.util.Stack;

import net.lotrek.zero.ZeroDayExploit;
import net.lotrek.zero.engine.Assembler;
import net.lotrek.zero.engine.Processor;
import net.lotrek.zero.graphics.GLComplex;
import net.lotrek.zero.graphics.GraphicsUtil;
import net.lotrek.zero.graphics.LifeUtil;
import net.lotrek.zero.graphics.RenderAction;
import net.lotrek.zero.story.StoryCore;

import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;
import org.lwjgl.opengl.Display;
import org.newdawn.slick.AppGameContainer;
import org.newdawn.slick.Color;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;
import org.newdawn.slick.gui.AbstractComponent;
import org.newdawn.slick.gui.TextField;

public class GameUtil
{
	private static int gameState = 0;
	public static Window newsWindow = new Window(GraphicsUtil.getScreenWidth()
			/ 2 - (GraphicsUtil.getScreenWidth() / 3), 0,
			(GraphicsUtil.getScreenWidth() / 3) * 2, 170, GraphicsUtil.amber,
			"News", true),
			saveSelect = new Window(GraphicsUtil.getScreenWidth() / 2 - 320,
					GraphicsUtil.getScreenHeight() / 2 - 25, 640, 50,
					GraphicsUtil.amber, "Save Selection", true),
			saveFiles = new Window(0, 0, 200, GraphicsUtil.getScreenHeight() - 1,
					GraphicsUtil.amber, "Save Files", true),
			confirmBox = new Window(
					GraphicsUtil.getScreenWidth() / 2 - 100,
					((saveSelect.y - (newsWindow.y + newsWindow.height)) / 2 + (newsWindow.y + newsWindow.height)) - 50,
					200, 100, GraphicsUtil.amber, "Confirm Entry", false),
			asmWindow = new Window(GraphicsUtil.getScreenWidth()
					/ 2 - (GraphicsUtil.getScreenWidth() / 3), GraphicsUtil.getScreenHeight() - 171,
					(GraphicsUtil.getScreenWidth() / 3) * 2, 80, GraphicsUtil.amber,
					"Hardware Assembler", true);
	public static String fileList = "";
	public static int DWheel, DX, DY;
	public static Stack<RenderAction<?>> renderQueue = new Stack<RenderAction<?>>();
	
	public static Properties gameSave = new Properties();
	
	private static boolean doExit = false;
	
	public static class Window
	{
		public int alpha = 100, x, y, width, height;
		public String title;
		public Color color;
		public boolean visible, startDrag;
		
		private HashMap<String, AbstractComponent> componentMap = new HashMap<String, AbstractComponent>();
		
		public Window(int xParam, int yParam, int widthParam, int heightParam, Color colorParam, String titleParam, boolean isVisible)
		{
			this.x = xParam;
			this.y = yParam;
			this.width = widthParam;
			this.height = heightParam;
			this.color = colorParam;
			this.title = titleParam;
			this.visible = isVisible;
		}
		
		public void addComponent(String name, AbstractComponent c, Method method, Object...params)
		{
			if(method != null)
				try {
					method.invoke(c, params);
				} catch (IllegalAccessException | IllegalArgumentException
						| InvocationTargetException e) {
					e.printStackTrace();
				}
			
			c.setLocation(x + c.getX(), y + c.getY());
			componentMap.put(name, c);
		}
		
		public AbstractComponent getComponent(String name)
		{
			return componentMap.get(name);
		}
		
		public void render(Graphics g, Method...renderMethods)
		{
			if (visible)
			{
				if (Mouse.isButtonDown(0)
						&& MouseUtil.withinBounds(this.x + width - 15, this.x
								+ this.width - 5, this.y + 5, this.y + 15)
						&& !startDrag)
					System.exit(0);
				if ((Mouse.isButtonDown(0) && MouseUtil.withinBounds(this.x,
						this.x + this.width, this.y, this.y + 20))
						|| this.startDrag) {

					this.x += DX;
					this.y -= DY;

					for (AbstractComponent comp : componentMap.values())
						comp.setLocation(comp.getX() + DX, comp.getY() - DY);

					this.startDrag = true;
				}
				if (!Mouse.isButtonDown(0))
					this.startDrag = false;
				if (startDrag && ZeroDayExploit.getKey("--debug")) {
					int DW = DWheel;

					//Resize
					if (Keyboard.isKeyDown(Keyboard.KEY_1))
						this.width += DW / 60;
					if (Keyboard.isKeyDown(Keyboard.KEY_2))
						this.height += DW / 60;
					if (Keyboard.isKeyDown(Keyboard.KEY_3))
						this.alpha += DW / 120;

					this.alpha = this.alpha > 255 ? 255 : this.alpha;
					this.alpha = this.alpha < 0 ? 0 : this.alpha;
				}
				g.setColor(new Color(0, 0, 0, this.alpha));
				g.fillRect(x, y, width, height);
				g.setColor(color);
				g.drawRect(x, y, width, height);
				g.fillRect(x, y, width, 20);
				for (Method method : renderMethods)
					try {
						method.invoke(null, this.x, this.y, this.width,
								this.height, g);
					} catch (IllegalAccessException | IllegalArgumentException
							| InvocationTargetException e1) {
						e1.printStackTrace();
					}
				for (AbstractComponent comp : componentMap.values())
					try {
						comp.render(GLComplex.getContainer(), g);
					} catch (SlickException e) {
						e.printStackTrace();
					}
				g.setColor(Color.black);
				g.drawString(title, x, y);
				g.fillRect(x + width - 15, y + 5, 10, 10);
				g.setColor(new Color(0, 0, 0, this.alpha));
				///Scan Lines
				if (!(ZeroDayExploit.getKey("--debug") && Keyboard
						.isKeyDown(Keyboard.KEY_Q)))
					for (int tmpY = y % 2 == 0 ? y : y + 1; tmpY <= height + y; tmpY += 2)
						g.fillRect(x, tmpY, width + 1, 1);
				g.setColor(Color.white);
				//Debug info
				if (ZeroDayExploit.getKey("--debug")
						&& !Keyboard.isKeyDown(Keyboard.KEY_Z))
					g.drawString("(" + x + ", " + y + ") : " + width + " X "
							+ height + " : Alpha components at " + this.alpha,
							x, y - 20);
			}
		}
	}
	
	public static void initPregame()
	{
		doExit = false;
		
		if(gameState == 0)
		{
			fileList = "";
			if(ZeroDayExploit.getKey("--life")){
				LifeUtil.startLife();
				System.err.println("Conway's life simulation enabled");
			}
			
			if(ZeroDayExploit.getKey("--debug"))
				System.err.println("Debug mode enabled");
			
			GraphicsUtil.initParticles();
			
			gameState = 1;
			if(saveSelect.getComponent("FILENAME") == null)
				try {
					saveSelect.addComponent("FILENAME", new TextField(GLComplex.getContainer(), GLComplex.getContainer().getDefaultFont(), 10, 25, saveSelect.width - 20, 20), TextField.class.getDeclaredMethod("setBackgroundColor", new Class<?>[]{Color.class}), Color.transparent);
					asmWindow.addComponent("inFile", new TextField(GLComplex.getContainer(), GLComplex.getContainer().getDefaultFont(), 10, 25, asmWindow.width - 20, 20), TextField.class.getDeclaredMethod("setBackgroundColor", new Class<?>[]{Color.class}), Color.transparent);
					asmWindow.addComponent("outFile", new TextField(GLComplex.getContainer(), GLComplex.getContainer().getDefaultFont(), 10, asmWindow.height - 25, asmWindow.width - 20, 20), TextField.class.getDeclaredMethod("setBackgroundColor", new Class<?>[]{Color.class}), Color.transparent);
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
			
			for(File file : new File("saves").listFiles(new FilenameFilter()
			{
				@Override
				public boolean accept(File arg0, String arg1) {
					return arg1.endsWith(".sav");
				}
			}))
				fileList += file.getName().split("\\.")[0] + "\n";
			
			try {
				GraphicsUtil.fadeInMethod(GameUtil.class.getDeclaredMethod("renderGUI", AppGameContainer.class, Graphics.class), GLComplex.getContainer().getGraphics(), 1, 2);
			} catch (NoSuchMethodException | SecurityException e) {
				e.printStackTrace();
			}
			
		}else
			ZeroDayExploit.throwFatal("Attemped to initialize the pregame from an invalid state!");
		
		if(ZeroDayExploit.getKey("-ld"))
			initRuntime(ZeroDayExploit.args[1]);
	}
	
	public static void initRuntime(String saveFile)
	{	
		try {
			GraphicsUtil.fadeOutMethod(GameUtil.class.getDeclaredMethod("renderGUI", AppGameContainer.class, Graphics.class), GLComplex.getContainer().getGraphics(), 1, 2);
		} catch (NoSuchMethodException | SecurityException e2) {
			e2.printStackTrace();
		}
		
		GLComplex.getContainer().getGraphics().clear();
		Display.update();
		GLComplex.getContainer().getGraphics().clear();
		Display.update();
		
		gameState = 2;
		
//		System.out.println("INIT RUNTIME");
		
		if(!new File("saves/" + saveFile).exists())
			try {
				gameSave.clear();
				gameSave.setProperty("bios", "saves/"+saveFile.split("\\.")[0]+".bios");
				gameSave.setProperty("disks", "saves/"+saveFile.split("\\.")[0]+".disk");
				gameSave.setProperty("story", "story.bin");
				gameSave.setProperty("time", TimeUtil.getLockedTimeString());
				gameSave.store(new FileOutputStream(new File("saves/"+saveFile)), "");
				
				InputStream is = FileUtil.getFile("res.bin/default.bios");
				FileOutputStream os = new FileOutputStream(new File("saves/"+saveFile.split("\\.")[0]+".bios"));
				
				while(is.available() > 0)
					os.write(is.read());
				
				os.flush();
				os.close();
				
				is = FileUtil.getFile("res.bin/default.disk");
				os = new FileOutputStream(new File("saves/"+saveFile.split("\\.")[0]+".disk"));
				
				while(is.available() > 0)
					os.write(is.read());
				
				os.flush();
				os.close();
				
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		
		saveFile = "saves/"+saveFile;
		try {
			gameSave.load(FileUtil.getFile(saveFile));
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		final String threadSave = saveFile;
		
		System.err.println("Loaded " + saveFile + " and began execution");
		System.err.println("\tBios File: " + gameSave.getProperty("bios", "bios"));
		System.err.println("\tDisk" + (gameSave.getProperty("disks").split(";").length > 1 ? "s" : "") + ": " + Arrays.toString(gameSave.getProperty("disks").split(";")).replaceAll("\\[|\\]", ""));
		
		TimeUtil.initTime(gameSave.getProperty("time"));
		
		new Thread()
		{
			public void run()
			{
				this.setName("PLAYER");
				StoryCore.clear();
				Processor.setPlayer(new Processor(gameSave.getProperty("bios", "bios"), 268435456, gameSave.getProperty("disks").split(";")));
				
				new Thread() {
					public void run()
					{
						this.setName("Time");
						while(GameUtil.gameState == 2)
							try {
								Thread.sleep(1000);
								TimeUtil.doTimeTick();
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
					}
				}.start();
				
				new Thread() {
					public void run()
					{
						this.setName("STORY");
						StoryCore.beginStory(gameSave, threadSave);
//						System.out.println("THREAD COMPLETE");
					}
				}.start();
				
				Processor.getInstance().execute(0);
			}
		}.start();
	}
	
	public static void exitRuntime()
	{
		try {
			GLComplex.getContainer().getGraphics().clear();
		} catch (RuntimeException e)
		{
			doExit = true;
			return;
		}
		
		if(gameState == 2)
		{
			Processor.killAll();
			
			System.gc();
			gameState = 0;
			if(!ZeroDayExploit.getKey("-ld"))
				initPregame();
			else
				System.exit(0);
		}else
			ZeroDayExploit.throwFatal("Attemped to exit the runtime when it was probably not initialized");
	}
	
	public static void throwNonFatal(String message)
	{
		System.err.println("Processor threw an error: " + message);
		exitRuntime();
	}
	
	public static String getState()
	{
		switch(gameState)
		{
		case 0:
			return "none - 0";
		case 1:
			return "pregame - 1";
		case 2:
			return "ingame - 2";
		default:
			return "ABNORMAL - " + gameState;
		}
	}
	
	private static int rotate = 0, rx, ry;
	private static boolean queueClear = false, blockUpdate = false;
	
	public static void setRotate(int x, int y, int angle)
	{
		rotate = angle;
		rx = x;
		ry = y;
	}
	
	public static void queueClear()
	{
		queueClear = true;
	}
	
	public static void block(boolean toBlock)
	{
		blockUpdate = toBlock;
		
//		System.out.println(blockUpdate ? "Blocked rendering" : "Unblocked rendering");
	}
	
	public static void renderGUI(AppGameContainer c, Graphics g)
	{
		if(gameState == 1)
		{
			DWheel = Mouse.getDWheel();
			DX = Mouse.getDX();
			DY = Mouse.getDY();
			
			if(ZeroDayExploit.getKey("--debug"))
				c.setShowFPS(!Keyboard.isKeyDown(Keyboard.KEY_Z));
			
			g.clear();
			
			if(ZeroDayExploit.getKey("--life"))
				LifeUtil.render(g, GraphicsUtil.amber);
			
			GraphicsUtil.renderParticles(DX, DY, GraphicsUtil.amber, g);
			
			saveSelect.render(g);
			newsWindow.render(g);
			
			try {
				newsWindow.render(g, GraphicsUtil.class.getDeclaredMethod("renderNews", int.class, int.class, int.class, int.class, Graphics.class));
				saveFiles.render(g, GraphicsUtil.class.getDeclaredMethod("renderFiles", int.class, int.class, int.class, int.class, Graphics.class));
				asmWindow.render(g, GraphicsUtil.class.getDeclaredMethod("renderASM", int.class, int.class, int.class, int.class, Graphics.class));
				confirmBox.render(g, GraphicsUtil.class.getDeclaredMethod("renderMessage", int.class, int.class, int.class, int.class, Graphics.class));
			} catch (NoSuchMethodException | SecurityException e) {
				e.printStackTrace();
			}
			
			if(Keyboard.isKeyDown(Keyboard.KEY_RETURN) && saveSelect.getComponent("FILENAME").hasFocus() && !confirmBox.visible && !castTo(saveSelect.getComponent("FILENAME"), TextField.class).getText().isEmpty())
				confirmBox.visible = true;
			
			if(Keyboard.isKeyDown(Keyboard.KEY_RETURN) && asmWindow.getComponent("outFile").hasFocus() && !castTo(asmWindow.getComponent("outFile"), TextField.class).getText().isEmpty() & !castTo(asmWindow.getComponent("inFile"), TextField.class).getText().isEmpty())
			{
				castTo(asmWindow.getComponent("outFile"), TextField.class).setFocus(false);
				castTo(asmWindow.getComponent("inFile"), TextField.class).setFocus(false);
				new Thread() {
					public void run() {
						try {
							Assembler.assemble(
									new File(castTo(
											asmWindow.getComponent("inFile"),
											TextField.class).getText()),
									new File(castTo(
											asmWindow.getComponent("outFile"),
											TextField.class).getText()));
							GraphicsUtil.asm = true;
						} catch (IOException e) {
							e.printStackTrace();
							GraphicsUtil.asm = false;
						}
						castTo(asmWindow.getComponent("outFile"), TextField.class).setText("");
						castTo(asmWindow.getComponent("inFile"), TextField.class).setText("");
					}
				}.start();
				
			}
		}
		else if(gameState == 2)
		{
			c.setClearEachFrame(false);
			c.setShowFPS(false);
			
			while(!renderQueue.isEmpty() && !blockUpdate)
			{
				if(rotate != 0)
					g.rotate(rx, ry, rotate);
				RenderAction<?> tmp = renderQueue.pop();
				
				if(queueClear) {
					g.clear();
					Display.update();
					g.clear();
					Display.update();
					queueClear = false;
				}
				
				tmp.invoke();
				if(rotate != 0)
				{
					g.rotate(rx, ry, -rotate);
					rotate = 0;
				}
			}
			
			if(doExit)
			{
				doExit = false;
				exitRuntime();
			}
		}
	}
}
