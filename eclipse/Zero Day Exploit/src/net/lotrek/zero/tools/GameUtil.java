package net.lotrek.zero.tools;

import static net.lotrek.zero.Abraxas.castTo;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Properties;
import java.util.concurrent.LinkedBlockingQueue;

import net.lotrek.zero.Abraxas;
import net.lotrek.zero.engine.Engine;
import net.lotrek.zero.graphics.GLComplex;
import net.lotrek.zero.graphics.GraphicsUtil;
import net.lotrek.zero.graphics.LifeUtil;
import net.lotrek.zero.graphics.RenderAction;
import net.lotrek.zero.story.StoryCore;

import org.lwjgl.BufferUtils;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL12;
import org.newdawn.slick.AppGameContainer;
import org.newdawn.slick.Color;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.SlickException;
import org.newdawn.slick.gui.AbstractComponent;
import org.newdawn.slick.gui.TextField;
import org.newdawn.slick.opengl.TextureImpl;

public class GameUtil
{
	public static enum ErrorCode
	{
		instructionAccess(0),
		memoryAccess(1),
		nop(2),
		;
		
		public int id;
		
		ErrorCode(int id)
		{
			this.id = id;
		}
	}
	
	private static int gameState = 0;
	public static Window newsWindow = new Window(GraphicsUtil.getScreenWidth()
			/ 2 - (GraphicsUtil.getScreenWidth() / 3), 0,
			(GraphicsUtil.getScreenWidth() / 3) * 2, 170, GraphicsUtil.amber,
			"News", true),
			saveSelect = new Window(GraphicsUtil.getScreenWidth() / 2 - 320,
					GraphicsUtil.getScreenHeight() / 2 - 25, 640, 50,
					GraphicsUtil.amber, "Save Selection", true),
			saveFiles = new Window(0, 0, 200, GraphicsUtil.getScreenHeight() - 1,
					GraphicsUtil.amber, "Save Files", true),
			confirmBox = new Window(
					GraphicsUtil.getScreenWidth() / 2 - 100,
					((saveSelect.y - (newsWindow.y + newsWindow.height)) / 2 + (newsWindow.y + newsWindow.height)) - 50,
					200, 100, GraphicsUtil.amber, "Confirm Entry", false),
			asmWindow = new Window(GraphicsUtil.getScreenWidth()
					/ 2 - (GraphicsUtil.getScreenWidth() / 3), GraphicsUtil.getScreenHeight() - 171,
					(GraphicsUtil.getScreenWidth() / 3) * 2, 80, GraphicsUtil.amber,
					"Hardware Assembler", true);
	public static String fileList = "";
	public static int DWheel, DX, DY;
	public static LinkedBlockingQueue<RenderAction<?>> renderQueue = new LinkedBlockingQueue<RenderAction<?>>();
	public static String mouseText = "", startLater = "";
	
	public static Properties gameSave = new Properties();
	
	public static boolean doExit = false;
	
	public static class Window
	{
		public int alpha = 100, x, y, width, height;
		public String title;
		public Color color;
		public boolean visible, startDrag;
		
		private HashMap<String, AbstractComponent> componentMap = new HashMap<String, AbstractComponent>();
		
		public Window(int xParam, int yParam, int widthParam, int heightParam, Color colorParam, String titleParam, boolean isVisible)
		{
			this.x = xParam;
			this.y = yParam;
			this.width = widthParam;
			this.height = heightParam;
			this.color = colorParam;
			this.title = titleParam;
			this.visible = isVisible;
		}
		
		public void addComponent(String name, AbstractComponent c, Method method, Object...params)
		{
			if(method != null)
				try {
					method.invoke(c, params);
				} catch (IllegalAccessException | IllegalArgumentException
						| InvocationTargetException e) {
					e.printStackTrace();
				}
			
			c.setLocation(x + c.getX(), y + c.getY());
			componentMap.put(name, c);
		}
		
		public AbstractComponent getComponent(String name)
		{
			return componentMap.get(name);
		}
		
		public void render(Graphics g, Method...renderMethods)
		{
			if (visible)
			{
				if (Mouse.isButtonDown(0)
						&& MouseUtil.withinBounds(this.x + width - 15, this.x
								+ this.width - 5, this.y + 5, this.y + 15)
						&& !startDrag)
					System.exit(0);
				if ((Mouse.isButtonDown(0) && MouseUtil.withinBounds(this.x,
						this.x + this.width, this.y, this.y + 20))
						|| this.startDrag) {

					this.x += DX;
					this.y -= DY;

					for (AbstractComponent comp : componentMap.values())
						comp.setLocation(comp.getX() + DX, comp.getY() - DY);

					this.startDrag = true;
				}
				if (!Mouse.isButtonDown(0))
					this.startDrag = false;
				if (startDrag && Abraxas.getKey("--debug")) {
					int DW = DWheel;

					//Resize
					if (Keyboard.isKeyDown(Keyboard.KEY_1))
						this.width += DW / 60;
					if (Keyboard.isKeyDown(Keyboard.KEY_2))
						this.height += DW / 60;
					if (Keyboard.isKeyDown(Keyboard.KEY_3))
						this.alpha += DW / 120;

					this.alpha = this.alpha > 255 ? 255 : this.alpha;
					this.alpha = this.alpha < 0 ? 0 : this.alpha;
				}
				g.setColor(new Color(0, 0, 0, this.alpha));
				g.fillRect(x, y, width, height);
				g.setColor(color);
				g.drawRect(x, y, width, height);
				g.fillRect(x, y, width, 20);
				for (Method method : renderMethods)
					try {
						method.invoke(null, this.x, this.y, this.width,
								this.height, g);
					} catch (IllegalAccessException | IllegalArgumentException
							| InvocationTargetException e1) {
						e1.printStackTrace();
					}
				for (AbstractComponent comp : componentMap.values())
					try {
						comp.render(GLComplex.getContainer(), g);
					} catch (SlickException e) {
						e.printStackTrace();
					}
				g.setColor(Color.black);
				g.drawString(title, x, y);
				g.fillRect(x + width - 15, y + 5, 10, 10);
				g.setColor(new Color(0, 0, 0, this.alpha));
				///Scan Lines
				if (!(Abraxas.getKey("--debug") && Keyboard
						.isKeyDown(Keyboard.KEY_Q)))
					for (int tmpY = y % 2 == 0 ? y : y + 1; tmpY <= height + y; tmpY += 2)
						g.fillRect(x, tmpY, width + 1, 1);
				g.setColor(Color.white);
				//Debug info
				if (Abraxas.getKey("--debug")
						&& !Keyboard.isKeyDown(Keyboard.KEY_Z))
					g.drawString("(" + x + ", " + y + ") : " + width + " X "
							+ height + " : Alpha components at " + this.alpha,
							x, y - 20);
			}
		}
	}
	
	public static void initPregame()
	{
		doExit = false;
		
		if(gameState == 0)
		{
			fileList = "";
			if(Abraxas.getKey("--life")){
				LifeUtil.startLife();
				System.err.println("Conway's life simulation enabled");
			}
			
			if(Abraxas.getKey("--debug"))
				System.err.println("Debug mode enabled");
			
			GraphicsUtil.initParticles();
			
			gameState = 1;
			if(saveSelect.getComponent("FILENAME") == null)
				try {
					saveSelect.addComponent("FILENAME", new TextField(GLComplex.getContainer(), GLComplex.getContainer().getDefaultFont(), 10, 25, saveSelect.width - 20, 20), TextField.class.getDeclaredMethod("setBackgroundColor", new Class<?>[]{Color.class}), Color.transparent);
					asmWindow.addComponent("inFile", new TextField(GLComplex.getContainer(), GLComplex.getContainer().getDefaultFont(), 10, 25, asmWindow.width - 20, 20), TextField.class.getDeclaredMethod("setBackgroundColor", new Class<?>[]{Color.class}), Color.transparent);
					asmWindow.addComponent("outFile", new TextField(GLComplex.getContainer(), GLComplex.getContainer().getDefaultFont(), 10, asmWindow.height - 25, asmWindow.width - 20, 20), TextField.class.getDeclaredMethod("setBackgroundColor", new Class<?>[]{Color.class}), Color.transparent);
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
			
			if(!new File(FileUtil.baseDir + "saves").exists())
				Abraxas.throwFatal("Unable to find \"" + (FileUtil.baseDir + "saves") + "\"");
			
			for(File file : new File(FileUtil.baseDir + "saves").listFiles(new FilenameFilter()
			{
				@Override
				public boolean accept(File arg0, String arg1) {
					return arg1.endsWith(".sav");
				}
			}))
				fileList += file.getName().split("\\.")[0] + "\n";
			
			try {
				GraphicsUtil.fadeInMethod(GameUtil.class.getDeclaredMethod("renderGUI", AppGameContainer.class, Graphics.class), GLComplex.getContainer().getGraphics(), 1, 2);
			} catch (NoSuchMethodException | SecurityException e) {
				e.printStackTrace();
			}
			
		}else
			Abraxas.throwFatal("Attemped to initialize the pregame from an invalid state!");
		
		if(Abraxas.getKey("-ld"))
			initRuntime(Abraxas.args[1]);
		
		if(!startLater.isEmpty())
			initRuntime(startLater);
	}
	
	public static String saveFile;
	
	public static void initRuntime(String saveFile)
	{	
		GameUtil.saveFile = saveFile;
		
		try {
			GraphicsUtil.fadeOutMethod(GameUtil.class.getDeclaredMethod("renderGUI", AppGameContainer.class, Graphics.class), GLComplex.getContainer().getGraphics(), 1, 2);
		} catch (NoSuchMethodException | SecurityException e2) {
			e2.printStackTrace();
		}
		
		GLComplex.getContainer().getGraphics().clear();
		Display.update();
		GLComplex.getContainer().getGraphics().clear();
		Display.update();
		
		gameState = 2;
		
//		System.out.println("INIT RUNTIME");
		
		if(!new File(FileUtil.baseDir + "saves/" + saveFile).exists())
			try {
				gameSave.clear();
				gameSave.setProperty("bios", "saves/"+saveFile.split("\\.")[0]+".bios");
				gameSave.setProperty("disks", "saves/"+saveFile.split("\\.")[0]+".disk");
				gameSave.setProperty("story", "story.bin");
				gameSave.setProperty("time", TimeUtil.getLockedTimeString());
				gameSave.store(new FileOutputStream(new File(FileUtil.baseDir + "saves/"+saveFile)), "");
				
				InputStream is = FileUtil.getFile("res.bin/default.bios");
				FileOutputStream os = new FileOutputStream(new File(FileUtil.baseDir + "saves/"+saveFile.split("\\.")[0]+".bios"));
				
				MultiplexOutputStream.writeInputToOutput(is, os, true);
				
				os.flush();
				os.close();
				
				is = FileUtil.getFile("res.bin/default.disk");
				os = new FileOutputStream(new File(FileUtil.baseDir + "saves/"+saveFile.split("\\.")[0]+".disk"));
				
				MultiplexOutputStream.writeInputToOutput(is, os, true);
				
				os.flush();
				os.close();
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		
		saveFile = "saves/"+saveFile;
		try {
			gameSave.load(FileUtil.getFile(saveFile));
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		final String threadSave = saveFile;
		
		System.err.println("Loaded " + saveFile + " and began execution");
		System.err.println("\tBios File: " + gameSave.getProperty("bios", "bios"));
		System.err.println("\tDisk" + (gameSave.getProperty("disks").split(";").length > 1 ? "s" : "") + ": " + Arrays.toString(gameSave.getProperty("disks").split(";")).replaceAll("\\[|\\]", ""));
		
		TimeUtil.initTime(gameSave.getProperty("time"));
		
		Engine.setPlayer(Engine.createGlobalEngine(gameSave.getProperty("bios", "bios"), 268435456, gameSave.getProperty("disks").split(";")));
		Engine.getPlayer().checkSanity();
		
//		new Thread()
		{
//			public void run()
			{
//				this.setName("PLAYER");
				StoryCore.clear();
//				NetworkCore.setAddress(NetworkCore.getAddress(NetworkCore.getRemoteAddress()));
//				Processor.setPlayer(new Processor(gameSave.getProperty("bios", "bios"), 268435456, gameSave.getProperty("disks").split(";")));
				
				new Thread() {
					public void run()
					{
						this.setName("Time");
						while(GameUtil.gameState == 2)
							try {
								Thread.sleep(1000);
								TimeUtil.doTimeTick();
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
					}
				}.start();
				
				new Thread() {
					public void run()
					{
						this.setName("STORY");
						StoryCore.beginStory(gameSave, FileUtil.baseDir + threadSave);
//						System.out.println("THREAD COMPLETE");
					}
				}.start();
				
//				Processor.getInstance().execute(0);
			}
		}//.start();
		
		Engine.getPlayer().start("PLAYER");
	}
	
	public static void exitRuntime()
	{
		try {
			GLComplex.getContainer().getGraphics().clear();
		} catch (RuntimeException e)
		{
			doExit = true;
			return;
		}
		
		if(gameState == 2)
		{
			Engine.terminateAll();
			
			System.gc();
			gameState = 0;
			if(!startLater.isEmpty())
			{
				GLComplex.getContainer().pause();
				TextureImpl.unbind();
				GLComplex.stop();
			}else
			if(!Abraxas.getKey("-ld"))
				initPregame();
			else
				System.exit(0);
		}else
			Abraxas.throwFatal("Attemped to exit the runtime when it was probably not initialized");
	}
	
	public static void throwNonFatal(ErrorCode error)
	{
		Engine.getPlayer().interrupt(0, true, error.id);
	}
	
	public static String getState()
	{
		switch(gameState)
		{
		case 0:
			return "none - 0";
		case 1:
			return "pregame - 1";
		case 2:
			return "ingame - 2";
		default:
			return "ABNORMAL - " + gameState;
		}
	}
	
	private static int rotate = 0, rx, ry;
	private static boolean queueClear = false, blockUpdate = false, queueScreenshot = false;
	
	public static void setRotate(int x, int y, int angle)
	{
		rotate = angle;
		rx = x;
		ry = y;
	}
	
	public static void queueClear()
	{
		queueClear = true;
	}
	
	public static void queueScreenshot()
	{
		queueScreenshot = true;
	}
	
	public static void block(boolean toBlock)
	{
		blockUpdate = toBlock;
	}
	
	private static volatile boolean isVideo;
	
	public static boolean isPlayingVideo()
	{
		return isVideo;
	}
	
	private static ByteBuffer lastFrame;
	private static Color lastColor;
	
	public static void playVideo(String file)
	{
//		Processor.suspendAll(true);
		Engine.suspendAll(true);
		
		VideoUtil.setVideo(file);
		
		lastFrame = BufferUtils.createByteBuffer(Display.getWidth() * Display.getHeight() * 3);
        GL11.glReadPixels(0, 0, Display.getWidth(), Display.getHeight(), GL11.GL_RGB, GL11.GL_UNSIGNED_BYTE, lastFrame);
        
        lastColor = GLComplex.getContainer().getGraphics().getColor();
		GLComplex.getContainer().getGraphics().setColor(Color.white);
		
		while(!VideoUtil.getPlayer().isBuffered())
		{
			GLComplex.getContainer().getGraphics().clear();
			GLComplex.getContainer().getGraphics().drawString(VideoUtil.getPlayer().getBufferedFrames() + "%", 10, 10);
			Display.update();
		}
		
		isVideo = true;
	}
	
	public static void renderGUI(AppGameContainer c, Graphics g)
	{
		if(Engine.getPlayer() != null)
			if(Engine.getPlayer().isTerminated())
				exitRuntime();
		
		if(isVideo)
		{
			VideoUtil.render();
			TextureImpl.unbind();
			if(!(isVideo = VideoUtil.getPlayer().isPlaying()))
			{
//				Processor.suspendAll(false);
				Engine.suspendAll(false);
				g.clear();
				
				int textue = GL11.glGenTextures();
				
				GL11.glBindTexture(GL11.GL_TEXTURE_2D, textue);
			    
				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);

				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
		    
				lastFrame.limit(lastFrame.capacity());
				
				GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGB, Display.getWidth(), Display.getHeight(), 0, GL11.GL_RGB, GL11.GL_UNSIGNED_BYTE, lastFrame);
				
				GL11.glBegin(GL11.GL_QUADS);
				{
					GL11.glTexCoord2f(0, 1);
					GL11.glVertex2f(0, 0);

					GL11.glTexCoord2f(1, 1);
					GL11.glVertex2f(Display.getWidth(), 0);

					GL11.glTexCoord2f(1, 0);
					GL11.glVertex2f(Display.getWidth(), Display.getHeight());

					GL11.glTexCoord2f(0, 0);
					GL11.glVertex2f(0, Display.getHeight());
				}
				GL11.glEnd();
				
				Display.update();
				
				GL11.glBegin(GL11.GL_QUADS);
				{
					GL11.glTexCoord2f(0, 1);
					GL11.glVertex2f(0, 0);

					GL11.glTexCoord2f(1, 1);
					GL11.glVertex2f(Display.getWidth(), 0);

					GL11.glTexCoord2f(1, 0);
					GL11.glVertex2f(Display.getWidth(), Display.getHeight());

					GL11.glTexCoord2f(0, 0);
					GL11.glVertex2f(0, Display.getHeight());
				}
				GL11.glEnd();
				
				GL11.glDeleteTextures(textue);
				
				TextureImpl.unbind();
				
				g.setColor(lastColor);
				
				VideoUtil.resetVideo();
			}
			return;
		}
		
		if(queueScreenshot)
		{
			queueScreenshot = false;
			GraphicsUtil.takeScreenShot(0, 0, GraphicsUtil.getScreenWidth(),
					GraphicsUtil.getScreenHeight(), "Screenshot-"
							+ Calendar.getInstance().getTime().toString().split("\\ ")[3].replace(":", "")
							+ ".png");
		}
		
		if(gameState == 1)
		{
			DWheel = Mouse.getDWheel();
			DX = Mouse.getDX();
			DY = Mouse.getDY();
			
			if(Abraxas.getKey("--debug"))
				c.setShowFPS(!Keyboard.isKeyDown(Keyboard.KEY_Z));
			
			g.clear();
			
			if(Abraxas.getKey("--life"))
				LifeUtil.render(g, GraphicsUtil.amber);
			
			GraphicsUtil.renderParticles(DX, DY, GraphicsUtil.amber, g);
			
			saveSelect.render(g);
			newsWindow.render(g);
			
			try {
				newsWindow.render(g, GraphicsUtil.class.getDeclaredMethod("renderNews", int.class, int.class, int.class, int.class, Graphics.class));
				saveFiles.render(g, GraphicsUtil.class.getDeclaredMethod("renderFiles", int.class, int.class, int.class, int.class, Graphics.class));
				asmWindow.render(g, GraphicsUtil.class.getDeclaredMethod("renderASM", int.class, int.class, int.class, int.class, Graphics.class));
				confirmBox.render(g, GraphicsUtil.class.getDeclaredMethod("renderMessage", int.class, int.class, int.class, int.class, Graphics.class));
			} catch (NoSuchMethodException | SecurityException e) {
				e.printStackTrace();
			}
			
			g.setColor(GraphicsUtil.amber);
			g.drawString(mouseText.toUpperCase(), Mouse.getX() + 20, MouseUtil.getY() + 20);
			
			/*g.setColor(new Color(0, 0, 0, 100));
			///Scan Lines
			if (!(ZeroDayExploit.getKey("--debug") && Keyboard
					.isKeyDown(Keyboard.KEY_Q)))
				for (int tmpY = (MouseUtil.getY() + 20) % 2 == 0 ? (MouseUtil.getY() + 20) : (MouseUtil.getY() + 20) + 1; tmpY <= c.getDefaultFont().getHeight(mouseText.toUpperCase()) + (MouseUtil.getY() + 20); tmpY += 2)
					g.fillRect((Mouse.getX() + 20), tmpY, c.getDefaultFont().getWidth(mouseText.toUpperCase()) + 1, 1);*/
			
			if(Keyboard.isKeyDown(Keyboard.KEY_RETURN) && saveSelect.getComponent("FILENAME").hasFocus() && !confirmBox.visible && !castTo(saveSelect.getComponent("FILENAME"), TextField.class).getText().isEmpty())
				confirmBox.visible = true;
			
			if(Keyboard.isKeyDown(Keyboard.KEY_RETURN) && asmWindow.getComponent("outFile").hasFocus() && !castTo(asmWindow.getComponent("outFile"), TextField.class).getText().isEmpty() & !castTo(asmWindow.getComponent("inFile"), TextField.class).getText().isEmpty())
			{
				castTo(asmWindow.getComponent("outFile"), TextField.class).setFocus(false);
				castTo(asmWindow.getComponent("inFile"), TextField.class).setFocus(false);
				new Thread() {
					public void run() {
						try {
							/*Assembler.assemble(
									new File(castTo(
											asmWindow.getComponent("inFile"),
											TextField.class).getText()),
									new File(castTo(
											asmWindow.getComponent("outFile"),
											TextField.class).getText()));*/
							Engine.createGlobalEngine().generateCode(
									new File(castTo(
											asmWindow.getComponent("inFile"),
											TextField.class).getText()).getAbsolutePath(),
									new File(castTo(
											asmWindow.getComponent("outFile"),
											TextField.class).getText()).getAbsolutePath());
							GraphicsUtil.asm = true;
						} catch (IOException e) {
							e.printStackTrace();
							GraphicsUtil.asm = false;
						}
						castTo(asmWindow.getComponent("outFile"), TextField.class).setText("");
						castTo(asmWindow.getComponent("inFile"), TextField.class).setText("");
					}
				}.start();
				
			}
		}
		else if(gameState == 2)
		{
			c.setClearEachFrame(false);
			c.setShowFPS(false);
			
			while(!renderQueue.isEmpty() && !blockUpdate)
			{
				if(rotate != 0)
					g.rotate(rx, ry, rotate);
				RenderAction<?> tmp = renderQueue.poll();
				
				if(queueClear) {
					g.clear();
					Display.update();
					g.clear();
					Display.update();
					queueClear = false;
				}
				
				tmp.invoke();
				if(rotate != 0)
				{
					g.rotate(rx, ry, -rotate);
					rotate = 0;
				}
			}
			
			if(doExit)
			{
				doExit = false;
				exitRuntime();
			}
		}
	}
}
