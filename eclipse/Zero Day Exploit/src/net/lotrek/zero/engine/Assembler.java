package net.lotrek.zero.engine;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;

import net.lotrek.zero.ZeroDayExploit;
import net.lotrek.zero.graphics.GraphicsUtil;
import net.lotrek.zero.tools.FileUtil;

public class Assembler
{
	public static ArrayList<String> opCodes = new ArrayList<String>();
	public static HashMap<String, String> opMap = new HashMap<String, String>();
	public static ArrayList<String> conditionCodes = new ArrayList<String>();
	
	static
	{
		Scanner src = new Scanner(FileUtil.getFile("res.bin/proc"));
		
		while(src.hasNextLine())
		{
			String line = src.nextLine();
			if(!line.startsWith("//") && line.length() != 7 && !line.isEmpty())
			{
				opCodes.add(line);
				opMap.put(line.split("_")[0], line);
			}
			else if(line.length() == 7)
				conditionCodes.add(line);
		}
		
		src.close();
	}
	
	 /*= {
		
		//Shifts
		"LSL_0000-0110-1111-0000-0000-0000-0000-0000_0000-1110-1111-0000-0000-0000-0000-0000_false",
		"LSR_0000-0110-1011-0000-0000-0000-0000-0000_0000-1110-1111-0000-0000-0000-0000-0000_false",
		"ASR_0000-0110-1101-0000-0000-0000-0000-0000_0000-1110-1111-0000-0000-0000-0000-0000_false",
		
		//Disk Operations
		"DSTR_0000-1011-0000-0000-0000-0000-0000-0000_0000-1111-0000-0000-0000-0000-0000-0000_true",
		"DLDR_0000-1001-0000-0000-0000-0000-0000-0000_0000-1111-0000-0000-0000-0000-0000-0000_true",
		
		//Disk Counter
		"CTD_0000-0101-1111-1111-1111-1111-1111-0000_0000-1111-1111-1111-1111-1111-1111-0000_false",
		
		//Processor Mode
		"CPM_0000-1101-1111-1111-1111-1111-1111-0000_0000-1111-1111-1111-1111-1111-1111-0000_true",
		
		//Halt
		"HLT_0000-1111-1111-1111-1111-1111-1111-1111_0000-1111-1111-1111-1111-1111-1111-1111_true",
		
		//Stack Family
		"PUSH_0000-1110-0111-1111-1111-1111-1111-0000_0000-1111-1111-1111-1111-1111-1111-0000_false",
		"POP_0000-1110-1111-1111-1111-1111-1111-0000_0000-1111-1111-1111-1111-1111-1111-0000_false",
		
		//Security
		"SEC_0000-1110-1011-1111-1111-0000-0000-0000_0000-1111-1111-1111-1111-0000-0000-0000_true",
		
		//Quantum Drive
		"QNTM_0000-1110-1101-1111-1111-1111-1111-0000_0000-1111-1111-1111-1111-1111-1111-0000_true",
		"GQTM_0000-1110-1100-1111-1111-1111-1111-0000_0000-1111-1111-1111-1111-1111-1111-0000_false",
		
		//Branch Family
		"B_0000-101-0-0000-0000-0000-0000-0000-0000_0000-111-1-0000-0000-0000-0000-0000-0000_true",
		"BL_0000-101-1-0000-0000-0000-0000-0000-0000_0000-111-1-0000-0000-0000-0000-0000-0000_true",
		"BX_0000-0001-0010-1111-1111-1111-0000-0000_0000-1111-1111-1111-1111-1111-0000-0000_true", //Now exchanges modes while jumping
		
		//Memory Operations Family
		"STR_0000-01-0-1-0-0-0-0-0000-0000-0000-0000-0000_0000-11-0-1-0-1-0-1-0000-0000-0000-0000-0000_false",
		"LDR_0000-01-0-1-0-0-0-1-0000-0000-0000-0000-0000_0000-11-0-1-0-1-0-1-0000-0000-0000-0000-0000_false",
		"STRB_0000-01-0-1-0-1-0-0-0000-0000-0000-0000-0000_0000-11-1-1-0-1-0-1-0000-0000-0000-0000-0000_false",
		"LDRB_0000-01-0-1-0-1-0-1-0000-0000-0000-0000-0000_0000-11-1-1-0-1-0-1-0000-0000-0000-0000-0000_false",
		"SWP_0000-00010-0-00-0000-0000-0000-1001-0000_0000-11111-1-11-0000-0000-1111-1111-0000_false",
		"SWPB_0000-00010-1-00-0000-0000-0000-1001-0000_0000-11111-1-11-0000-0000-1111-1111-0000_false",
		
		//Multiplication / division
		"MUL_0000-11-0-0110-1-0000-0000-0000-0000-0000_0000-11-0-1111-1-0000-0000-0000-0000-0000_false",
		"DIV_0000-01-0-1001-1-0000-0000-0000-0000-0000_0000-11-0-1111-1-0000-0000-0000-0000-0000_false",
		
		//Interrupt
		"SVC_0000-1111-000000000000000000000000_0000-1111-000000000000000000000000_false",
		
		//Graphics Operations
		"CLR_0000-0000-1111-1001-0000-0000-0000-0000_0000-1111-1111-1111-0000-0000-0000-0000_true",
		"DRAW_0000-0000-0111-1001-0000-0000-0000-0000_0000-1111-1111-1111-0000-0000-0000-0000_true",
		"FILL_0000-0000-1011-1001-0000-0000-0000-0000_0000-1111-1111-1111-0000-0000-0000-0000_true",
		"RECT_0000-0000-1101-1001-0000-0000-0000-0000_0000-1111-1111-1111-0000-0000-0000-0000_true",
		"OVL_0000-0000-0110-1001-0000-0000-0000-0000_0000-1111-1111-1111-0000-0000-0000-0000_true",
		"COLOR_0000-0000-1010-1001-0000-0000-0000-0000_0000-1111-1111-1111-0000-0000-0000-0000_true",
		"GCOLOR_0000-0000-1100-1001-0000-0000-0000-0000_0000-1111-1111-1111-0000-0000-0000-0000_true",
		"TEXT_0000-0000-0100-1001-0000-0000-0000-0000_0000-1111-1111-1111-0000-0000-0000-0000_true",
		"MOUSE_0000-0000-1000-1001-0000-0000-0000-0000_0000-1111-1111-1111-0000-0000-0000-0000_true",
		"ROT_0000-0000-1001-1001-0000-0000-0000-0000_0000-1111-1111-1111-0000-0000-0000-0000_true",
		"SCR_0000-0000-0010-1001-0000-0000-0000-0000_0000-1111-1111-1111-0000-0000-0000-0000_true",
		"BLK_0000-0000-0001-1001-0000-0000-0000-0000_0000-1111-1111-1111-0000-0000-0000-0000_true",
		"UBLK_0000-0000-0101-1001-0000-0000-0000-0000_0000-1111-1111-1111-0000-0000-0000-0000_true",
		//END
		
		//Data Processing
		"EOR_0000-00-0-0001-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000_false",
		"SUB_0000-00-0-0010-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000_false",
		"RSB_0000-00-0-0011-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000_false",
		"ADD_0000-00-0-0100-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000_false",
		"TST_0000-00-0-1000-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000_false",
		"TEQ_0000-00-0-1001-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000_false",
		"CMP_0000-00-0-1010-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000_false",
		"CMN_0000-00-0-1011-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000_false",
		"ORR_0000-00-0-1100-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000_false",
		"MOV_0000-00-0-1101-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000_false",
		"BIC_0000-00-0-1110-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000_false",
		"MVN_0000-00-0-1111-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000_false",
		"AND_0000-00-0-0000-0-0000-0000-0000-0000-0000_0000-11-0-1111-0-0000-0000-0000-0000-0000_false",
	};*/
	
	 /*= {
		"EQ_0000",
		"NE_0001",
		"CS_0010",
		"CC_0011",
		"MI_0100",
		"PL_0101",
		"VS_0110",
		"VC_0111",
		"HI_1000",
		"LS_1001",
		"GE_1010",
		"LT_1011",
		"GT_1100",
		"LE_1101",
		"AL_1110",
	};*/
	
	public static void assemble(File toAssemble, File output) throws IOException
	{
		Scanner src = new Scanner(toAssemble);
		FileOutputStream os = new FileOutputStream(output);
		
		HashMap<String, Integer> labelMap = new HashMap<String, Integer>();
		HashMap<String, String> constMap = new HashMap<String, String>();
		
		int off = 0;
		
		while(src.hasNextLine())
		{
			String asmLine = src.nextLine().toUpperCase().trim().replace("\t", "");
			
			if(asmLine.startsWith("$ ") && asmLine.endsWith(" $"))
			{
				int pad = Integer.parseInt(asmLine.replace("$ ", "").replace(" $", ""));
				
				off = off <= pad ? pad : off;
				continue;
			}
			
			if(asmLine.startsWith("# ") && asmLine.endsWith(" #"))
			{
				asmLine = asmLine.replace("# ", "").replace(" #", "");
				
				if(asmLine.toLowerCase().endsWith(".asm"))
					off += assemble(new File(asmLine), (OutputStream)null);
				else if(asmLine.toLowerCase().endsWith(".bmp"))
					off += GraphicsUtil.countBitmapBytes(asmLine) / 4 + (GraphicsUtil.countBitmapBytes(asmLine) % 4 == 0 ? 0 : 1);
				else
				{
					FileInputStream is = new FileInputStream(new File(asmLine));
					int tmpOff = 0;
					while(is.available() > 0)
					{
						is.read();
						tmpOff++;
					}
					off += tmpOff / 4 + (tmpOff % 4 == 0 ? 0 : 1);
					is.close();
						
				}
				continue;
			}
			
			if(asmLine.startsWith("\"") && asmLine.endsWith("\""))
			{
				asmLine = asmLine.substring(1, asmLine.length() - 1);
				off += asmLine.getBytes().length / 4 + (asmLine.getBytes().length % 4 == 0 ? 0 : 1);
				continue;
			}
			
			if(asmLine.startsWith("0X ") && asmLine.endsWith(" X0"))
			{
				asmLine = asmLine.replace("_", "").replace("0X ", "").replace(" X0", "");
				off += asmLine.split(" ").length / 4 + (asmLine.split(" ").length % 4 == 0 ? 0 : 1);
				continue;
			}
			
			if(asmLine.endsWith(":") && asmLine.startsWith(":"))
			{
				labelMap.put(asmLine.replace(":", ""), off);
				System.err.println("Attatched label " + asmLine + " to address " + off);
			}
			
			if(asmLine.endsWith("?") && asmLine.startsWith("?"))
				constMap.put(asmLine.replace(" ", "").replace("?", "").split("=")[0], asmLine.replace(" ", "").replace("?", "").split("=")[1]);
			
			if(asmLine.startsWith(";") || asmLine.isEmpty() || (asmLine.endsWith(":") & asmLine.startsWith(":")) || (asmLine.endsWith("?") && asmLine.startsWith("?")))
				continue;
			
			off++;
		}
		
		src.close();
		src = new Scanner(toAssemble);
		off = 0;
		
		while(src.hasNextLine())
		{
			int finalCode = 0;
			
			String asmLine = src.nextLine().trim().replace("\t", "");
			String inst = asmLine.split(" ")[0].replace("_", "").toUpperCase();
			String condition = "";
			int conditionCode = 0;
			int additionalCode = 0;
			
			if(asmLine.startsWith("$ ") && asmLine.endsWith(" $"))
			{
				int pad = Integer.parseInt(asmLine.replace("$ ", "").replace(" $", ""));
				
				int size = pad - off;
				
				if(off <= pad)
				{
					off = pad;
					os.write(new byte[size * 4]);
					System.err.println("Padded up to address " + pad * 4 + " : " + size * 4 + " bytes");
				}
				
				continue;
			}
			
			if(asmLine.startsWith("# ") && asmLine.endsWith(" #"))
			{
				asmLine = asmLine.replace("# ", "").replace(" #", "");
				
				if(asmLine.toLowerCase().endsWith(".asm"))
				{
					System.err.println("Assembled \"" + asmLine + "\" within");
					off += assemble(new File(asmLine), os);
				}
				else if(asmLine.toLowerCase().endsWith(".bmp"))
				{
					System.err.println("Compiled bitmap \"" + asmLine + "\" within");
					off += GraphicsUtil.countBitmapBytes(asmLine) / 4 + (GraphicsUtil.countBitmapBytes(asmLine) % 4 == 0 ? 0 : 1);
					GraphicsUtil.genBitmap(asmLine, os);
				}
				else
				{
					System.err.println("Added file \"" + asmLine + "\" within");
					FileInputStream is = new FileInputStream(new File(asmLine));
					int tmpOff = 0;
					while(is.available() > 0)
					{
						os.write(is.read());
						tmpOff++;
					}
					off += tmpOff / 4 + (tmpOff % 4 == 0 ? 0 : 1);
					os.write(new byte[4 - (tmpOff % 4)]);
					is.close();
						
				}
				continue;
			}
			
			if(asmLine.startsWith("\"") && asmLine.endsWith("\""))
			{
				asmLine = asmLine.substring(1, asmLine.length() - 1);
				System.err.println("Encoded string \"" + asmLine + "\", length of " + asmLine.getBytes().length + " bytes, overflow of " + ( 4 - (asmLine.getBytes().length % 4)) + " bytes");
				os.write(asmLine.getBytes());
				off += asmLine.getBytes().length / 4 + (4 - (asmLine.getBytes().length % 4) == 0 ? 0 : 1);
				
				if(asmLine.getBytes().length % 4 > 0)
					os.write(new byte[4 - (asmLine.getBytes().length % 4)]);
				continue;
			}
			
			asmLine = asmLine.toUpperCase().replace("_", "");
			
			if(asmLine.startsWith("0X ") && asmLine.endsWith(" X0"))
			{
				int tmpOff = 0;
				
				asmLine = asmLine.replace("_", "").replace("0X ", "").replace(" X0", "");
				
				for(String unit : asmLine.split(" "))
				{
					os.write(Integer.parseInt(unit, 16));
					tmpOff++;
				}
				
				System.err.println("Encoded data 0x " + asmLine + " x0, length of " + tmpOff + " bytes, overflow of " + (4 - (tmpOff % 4)) + " bytes");
				
				if(tmpOff % 4 > 0)
					os.write(new byte[4 - (tmpOff % 4)]);
				
				off += tmpOff / 4 + (tmpOff % 4 > 0 ? 1 : 0);
				continue;
			}
			
			if(asmLine.startsWith(";") || asmLine.isEmpty() || (asmLine.endsWith(":") & asmLine.startsWith(":")) || (asmLine.endsWith("?") && asmLine.startsWith("?")))
				continue;
			
			
			for(String label : labelMap.keySet())
			{
				if(asmLine.contains(":" + label + ":"))
				{
					System.err.println("Replaced instance of label " + label);
					asmLine = asmLine.replace(":" + label + ":", ""+ (labelMap.get(label) * 4 - off * 4));
				}
			}
			
			String data = "";
			
			//parent : for(String tmpInst : opCodes)
			String tmpInst = opMap.get(inst);
			{
				tmpInst = tmpInst.replace("-", "");
				
				if(tmpInst.split("_")[0].equals(inst))
				{
					data = tmpInst;
					inst = tmpInst.split("_")[0];
					conditionCode = 0b1110;
					additionalCode = Integer.parseInt(tmpInst.split("_")[1], 2);
					break;
				}
				
				for(String tmpCond : conditionCodes)
				{
					tmpCond = tmpCond.replace("-", "");
					
					if((tmpInst.split("_")[0] + tmpCond.split("_")[0]).equals(inst))
					{
						data = tmpInst;
						inst = tmpInst.split("_")[0];
						condition = tmpCond.split("_")[0];
						conditionCode = Integer.parseInt(tmpCond.split("_")[1], 2);
						additionalCode = Integer.parseInt(tmpInst.split("_")[1], 2);
						break;
					}
				}
			}
			
			finalCode |= conditionCode;
			finalCode <<= 28;
			finalCode |= additionalCode;
			
			for(String constVal : constMap.keySet())
			{
				if(asmLine.replace(inst + condition, "").contains(constVal))
				{
					System.err.println("Replaced instance of constant " + constVal);
					asmLine = asmLine.replace(inst + condition, "").replace(constVal, constMap.get(constVal));
				}
			}
			
			try {
				finalCode |= ZeroDayExploit.castTo(AsmCore.guessHost(data, 0).getDeclaredMethod(inst, String.class).invoke(null, asmLine.replace(inst + condition, "")), Integer.class);
			} catch (IllegalAccessException | IllegalArgumentException
					| InvocationTargetException | NoSuchMethodException
					| SecurityException e) {
				System.err.println("Encountered unknown instruction \"" + inst + "\", ignoring");
				continue;
			}
			
			os.write(new byte[]{(byte) (finalCode >> 24 & 0xFF), (byte) (finalCode >> 16 & 0xFF), (byte) (finalCode >> 8 & 0xff), (byte) (finalCode >> 0 & 0xff)});
			off++;
		}
		
		os.close();
		src.close();
		
		System.err.println("Finished assembling " + toAssemble.getName() + " to " + output.getName());
	}
	
	public static int assemble(File toAssemble, OutputStream output) throws IOException
	{
		Scanner src = new Scanner(toAssemble);
		OutputStream os = output;
		
		HashMap<String, Integer> labelMap = new HashMap<String, Integer>();
		HashMap<String, String> constMap = new HashMap<String, String>();
		
		int off = 0;
		
		while(src.hasNextLine())
		{
			String asmLine = src.nextLine().toUpperCase().trim().replace("\t", "");
			
			if(asmLine.startsWith("$ ") && asmLine.endsWith(" $"))
			{
				int pad = Integer.parseInt(asmLine.replace("$ ", "").replace(" $", ""));
				
				off = off <= pad ? pad : off;
				continue;
			}
			
			if(asmLine.startsWith("# ") && asmLine.endsWith(" #"))
			{
				asmLine = asmLine.replace("# ", "").replace(" #", "");
				
				if(asmLine.toLowerCase().endsWith(".asm"))
					off += assemble(new File(asmLine), (OutputStream)null);
				else if(asmLine.toLowerCase().endsWith(".bmp"))
					off += GraphicsUtil.countBitmapBytes(asmLine) / 4 + (GraphicsUtil.countBitmapBytes(asmLine) % 4 == 0 ? 0 : 1);
				else
				{
					FileInputStream is = new FileInputStream(new File(asmLine));
					int tmpOff = 0;
					while(is.available() > 0)
					{
						is.read();
						tmpOff++;
					}
					off += tmpOff / 4 + (tmpOff % 4 == 0 ? 0 : 1);
					is.close();
						
				}
				continue;
			}
			
			if(asmLine.startsWith("\"") && asmLine.endsWith("\""))
			{
				asmLine = asmLine.substring(1, asmLine.length() - 1);
				off += asmLine.getBytes().length / 4 + (asmLine.getBytes().length % 4 == 0 ? 0 : 1);
				continue;
			}
			
			if(asmLine.startsWith("0X ") && asmLine.endsWith(" X0"))
			{
				asmLine = asmLine.replace("_", "").replace("0X ", "").replace(" X0", "");
				off += asmLine.split(" ").length / 4 + (asmLine.split(" ").length % 4 == 0 ? 0 : 1);
				continue;
			}
			
			if(asmLine.endsWith(":") && asmLine.startsWith(":"))
			{
				labelMap.put(asmLine.replace(":", ""), off);
				System.err.println("Attatched label " + asmLine + " to address " + off);
			}
			
			if(asmLine.endsWith("?") && asmLine.startsWith("?"))
				constMap.put(asmLine.replace(" ", "").replace("?", "").split("=")[0], asmLine.replace(" ", "").replace("?", "").split("=")[1]);
			
			if(asmLine.startsWith(";") || asmLine.isEmpty() || (asmLine.endsWith(":") & asmLine.startsWith(":")) || (asmLine.endsWith("?") && asmLine.startsWith("?")))
				continue;
			
			off++;
		}
		
		src.close();
		src = new Scanner(toAssemble);
		off = 0;
		
		while(src.hasNextLine())
		{
			int finalCode = 0;
			
			String asmLine = src.nextLine().trim().replace("\t", "");
			String inst = asmLine.split(" ")[0].replace("_", "").toUpperCase();
			String condition = "";
			int conditionCode = 0;
			int additionalCode = 0;
			
			if(asmLine.startsWith("$ ") && asmLine.endsWith(" $"))
			{
				int pad = Integer.parseInt(asmLine.replace("$ ", "").replace(" $", ""));
				
				int size = pad - off;
				
				if(off <= pad)
				{
					off = pad;
					if(os != null)
						os.write(new byte[size * 4]);
					System.err.println("Padded up to address " + pad * 4 + " : " + size * 4 + " bytes");
				}
				
				continue;
			}
			
			if(asmLine.startsWith("# ") && asmLine.endsWith(" #"))
			{
				asmLine = asmLine.replace("# ", "").replace(" #", "");
				
				if(asmLine.toLowerCase().endsWith(".asm"))
				{
					System.err.println("Assembled \"" + asmLine + "\" within");
					off += assemble(new File(asmLine), os);
				}
				else if(asmLine.toLowerCase().endsWith(".bmp"))
				{
					System.err.println("Compiled bitmap \"" + asmLine + "\" within");
					off += GraphicsUtil.countBitmapBytes(asmLine) / 4 + (GraphicsUtil.countBitmapBytes(asmLine) % 4 == 0 ? 0 : 1);
					GraphicsUtil.genBitmap(asmLine, os);
				}
				else
				{
					System.err.println("Added file \"" + asmLine + "\" within");
					FileInputStream is = new FileInputStream(new File(asmLine));
					int tmpOff = 0;
					while(is.available() > 0)
					{
						if(os != null)
							os.write(is.read());
						else
							is.read();
						tmpOff++;
					}
					off += tmpOff / 4 + (tmpOff % 4 == 0 ? 0 : 1);
					if(os != null)
						os.write(new byte[4 - (tmpOff % 4)]);
					is.close();
						
				}
				continue;
			}
			
			if(asmLine.startsWith("\"") && asmLine.endsWith("\""))
			{
				asmLine = asmLine.substring(1, asmLine.length() - 1);
				System.err.println("Encoded string \"" + asmLine + "\", length of " + asmLine.getBytes().length + " bytes, overflow of " + ( 4 - (asmLine.getBytes().length % 4)) + " bytes");
				if(os != null)
					os.write(asmLine.getBytes());
				off += asmLine.getBytes().length / 4 + (4 - (asmLine.getBytes().length % 4) == 0 ? 0 : 1);
				
				if(asmLine.getBytes().length % 4 > 0)
					if(os != null)
						os.write(new byte[4 - (asmLine.getBytes().length % 4)]);
				continue;
			}
			
			asmLine = asmLine.toUpperCase().replace("_", "");
			
			if(asmLine.startsWith("0X ") && asmLine.endsWith(" X0"))
			{
				int tmpOff = 0;
				
				asmLine = asmLine.replace("_", "").replace("0X ", "").replace(" X0", "");
				
				for(String unit : asmLine.split(" "))
				{
					if(os != null)
						os.write(Integer.parseInt(unit, 16));
					tmpOff++;
				}
				
				System.err.println("Encoded data 0x " + asmLine + " x0, length of " + tmpOff + " bytes, overflow of " + (4 - (tmpOff % 4)) + " bytes");
				
				if(tmpOff % 4 > 0)
					if(os != null)
						os.write(new byte[4 - (tmpOff % 4)]);
				
				off += tmpOff / 4 + (tmpOff % 4 > 0 ? 1 : 0);
				continue;
			}
			
			if(asmLine.startsWith(";") || asmLine.isEmpty() || (asmLine.endsWith(":") & asmLine.startsWith(":")) || (asmLine.endsWith("?") && asmLine.startsWith("?")))
				continue;
			
			
			for(String label : labelMap.keySet())
			{
				if(asmLine.contains(":" + label + ":"))
				{
					System.err.println("Replaced instance of label " + label);
					asmLine = asmLine.replace(":" + label + ":", ""+ (labelMap.get(label) * 4 - off * 4));
				}
			}
			
			String data = "";
			
			//parent : for(String tmpInst : opCodes)
			String tmpInst = opMap.get(inst);
			{
				tmpInst = tmpInst.replace("-", "");
				
				if(tmpInst.split("_")[0].equals(inst))
				{
					data = tmpInst;
					inst = tmpInst.split("_")[0];
					conditionCode = 0b1110;
					additionalCode = Integer.parseInt(tmpInst.split("_")[1], 2);
					break;
				}
				
				for(String tmpCond : conditionCodes)
				{
					tmpCond = tmpCond.replace("-", "");
					
					if((tmpInst.split("_")[0] + tmpCond.split("_")[0]).equals(inst))
					{
						data = tmpInst;
						inst = tmpInst.split("_")[0];
						condition = tmpCond.split("_")[0];
						conditionCode = Integer.parseInt(tmpCond.split("_")[1], 2);
						additionalCode = Integer.parseInt(tmpInst.split("_")[1], 2);
						break;
					}
				}
			}
			
			finalCode |= conditionCode;
			finalCode <<= 28;
			finalCode |= additionalCode;
			
			for(String constVal : constMap.keySet())
			{
				if(asmLine.replace(inst + condition, "").contains(constVal))
				{
					System.err.println("Replaced instance of constant " + constVal);
					asmLine = asmLine.replace(inst + condition, "").replace(constVal, constMap.get(constVal));
				}
			}
			
			try {
				finalCode |= ZeroDayExploit.castTo(AsmCore.guessHost(data, 0).getDeclaredMethod(inst, String.class).invoke(null, asmLine.replace(inst + condition, "")), Integer.class);
			} catch (IllegalAccessException | IllegalArgumentException
					| InvocationTargetException | NoSuchMethodException
					| SecurityException e) {
				System.err.println("Encountered unknown instruction \"" + inst + "\", ignoring");
				continue;
			}
			
			if(os != null)
				os.write(new byte[]{(byte) (finalCode >> 24 & 0xFF), (byte) (finalCode >> 16 & 0xFF), (byte) (finalCode >> 8 & 0xff), (byte) (finalCode >> 0 & 0xff)});
			off++;
		}
		
		src.close();
		
		System.err.println("Finished assembling " + toAssemble.getName() + " inline");
		
		return off;
	}

	public static String guessCondition(int opcode)
	{
		byte cond = (byte) (opcode >> 28 & 0xF);
		
		for(String tmpCond : conditionCodes)
		{
			if(Byte.parseByte(tmpCond.split("_")[1], 2) == cond)
				return tmpCond.split("_")[0].equals("AL") ? "" : tmpCond.split("_")[0];
		}
		
		return "";
	}
	
	public static void disasemble(File inFile, File outFile) throws IOException
	{
		DataInputStream src = new DataInputStream(new FileInputStream(inFile));
		PrintStream os = new PrintStream(outFile);
		int tmpCode = 0;
		
		while(src.available() > 0)
		{
			tmpCode = src.readInt();
			try {
				String data = AsmCore.guessData(tmpCode);
				os.println("\t" + AsmCore.guessCode(data) + (guessCondition(tmpCode).isEmpty() ? guessCondition(tmpCode) : "_" + guessCondition(tmpCode)) + " " + ZeroDayExploit.castTo(AsmCore.guessHost(data, 1).getDeclaredMethod(AsmCore.guessCode(tmpCode), int.class).invoke(null, tmpCode), String.class));
			} catch (IllegalAccessException | IllegalArgumentException
					| InvocationTargetException | NoSuchMethodException
					| SecurityException e) {
				e.printStackTrace();
			}
		}
		
		os.close();
		src.close();
		
		System.err.println("Finished disassembling " + inFile.getName() + " to " + outFile.getName());
	}
}
