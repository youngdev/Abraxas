package net.lotrek.zero.engine;

import net.lotrek.zero.tools.GameUtil;

public class AsmCore
{
	public static boolean isCondition(int opcode)
	{
		byte cond = (byte) (opcode >> 28 & 0xF);
		
		boolean[] cpsr = decodeCPSR(Processor.getInstance().getRegisterPerMode(18).getValue());
		int N = 0, Z = 1, C = 2, V = 3;
		
		switch(cond)
		{
		case 0b0000: //EQ
			return cpsr[Z];
		case 0b0001: //NE
			return !cpsr[Z];
		case 0b0010: //CS
			return cpsr[C];
		case 0b0011: //CC
			return !cpsr[C];
		case 0b0100: //MI
			return cpsr[N];
		case 0b0101: //PL
			return !cpsr[N];
		case 0b0110: //VS
			return cpsr[V];
		case 0b0111: //VC
			return !cpsr[V];
		case 0b1000: //HI
			return cpsr[C] && !cpsr[Z];
		case 0b1001: //LS
			return !cpsr[C] || cpsr[Z];
		case 0b1010: //GE
			return cpsr[N] == cpsr[V];
		case 0b1011: //LT
			return cpsr[N] != cpsr[V];
		case 0b1100: //GT
			return !cpsr[Z] && (cpsr[N] == cpsr[V]);
		case 0b1101: //LE
			return cpsr[Z] || (cpsr[N] != cpsr[V]);
		case 0b1110: //AL - ignored
			return true;
		default:
			GameUtil.throwNonFatal("Encountered unrecognized condition code \"" + Integer.toBinaryString(cond) + "\" : " + Integer.toBinaryString(opcode));
			return false;
		}
	}
	
	public static boolean[] decodeCPSR(int cpsr)
	{
		return new boolean[]{(cpsr >> 31 & 0b1) == 1, (cpsr >> 30 & 0b1) == 1, (cpsr >> 29 & 0b1) == 1, (cpsr >> 28 & 0b1) == 1};
	}
	
	public static String guessData(int opcode)
	{
		for(String nm : Assembler.opCodes)
			if((opcode & Integer.parseInt(nm.replace("-", "").split("_")[2], 2)) == Integer.parseInt(nm.replace("-", "").split("_")[1], 2) && Integer.parseInt(nm.replace("-", "").split("_")[2], 2) != 0)
				return nm;
		return "NOP";
	}
	
	public static String guessCode(int opcode)
	{
		for(String nm : Assembler.opCodes)
		{
			nm = nm.replace("-", "");
			
			if((opcode & Integer.parseInt(nm.split("_")[2], 2)) == Integer.parseInt(nm.split("_")[1], 2) && Integer.parseInt(nm.split("_")[2], 2) != 0)
				return nm.split("_")[0];
		}
		return "NOP";
	}
	
	public static String guessCode(String opcode)
	{
		return opcode.split("_")[0];
	}
	
	public static boolean detectSanity(int opcode)
	{
		for(String nm : Assembler.opCodes)
		{
			nm = nm.replace("-", "");
			
			if((opcode & Integer.parseInt(nm.split("_")[2], 2)) == Integer.parseInt(nm.split("_")[1], 2) && Integer.parseInt(nm.split("_")[2], 2) != 0)
				return true;
		}
		return false;
	}
	
	public static boolean detectSanity(String opcode)
	{
		return !opcode.contains("NOP");
	}
	
	public static boolean guessSecure(int opcode)
	{
		for(String nm : Assembler.opCodes)
		{
			nm = nm.replace("-", "");
			
			if((opcode & Integer.parseInt(nm.split("_")[2], 2)) == Integer.parseInt(nm.split("_")[1], 2) && Integer.parseInt(nm.split("_")[2], 2) != 0)
				return Boolean.parseBoolean(nm.split("_")[3]);
		}
		
		return false;
	}
	
	public static boolean guessPlayer(int opcode)
	{
		for(String nm : Assembler.opCodes)
		{
			nm = nm.replace("-", "");
			
			if((opcode & Integer.parseInt(nm.split("_")[2], 2)) == Integer.parseInt(nm.split("_")[1], 2) && Integer.parseInt(nm.split("_")[2], 2) != 0)
				return Boolean.parseBoolean(nm.split("_")[4]);
		}
		
		return false;
	}
	
	public static boolean guessSecure(String opcode)
	{
		return Boolean.parseBoolean(opcode.split("_")[3]);
	}
	
	public static boolean guessPlayer(String opcode)
	{
		return Boolean.parseBoolean(opcode.split("_")[4]);
	}
	
	public static Class<?> guessHost(String opcode, int src)
	{
		switch(src)
		{
		case 0:
			opcode += "$Assembly";
			break;
		case 1:
			opcode += "$Disassembly";
			break;
		case 2:
			opcode += "$Execution";
			break;
		}
		
		try {
			return Class.forName(opcode.split("_")[5]);
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
			return Instructions.Execution.class;
		}
	}
	
	//DO NOT LOOSE THESE!!!
	public static int compressInt(int value, int numBits)
	{
		int toReturn = 0;
		
		int tmpMask = 0;
		
		for(int loop = 0; loop < numBits; loop++)
			tmpMask |= 0xF << loop;
		
		if(value < 0)
			toReturn |= ((value & tmpMask) ) | (1 << numBits);
		else
			toReturn |= value & ~(1 << numBits);
		
		return toReturn;
	}
	
	public static int expandInt(int value, int numBits)
	{
		int toReturn = 0;
		
		int tmpMask = 0;
		
		for(int loop = 0; loop < numBits; loop++)
			tmpMask |= 0b1 << loop;
		
		toReturn = value & tmpMask;
		if(((toReturn & (1 << (numBits - 1))) >> (numBits - 1)) == 0b1)
		{
			toReturn |= ~tmpMask;
			toReturn = ~toReturn;
			toReturn += 1;
			toReturn = -toReturn;
		}
		
		return toReturn;
	}
	
	public static int fromBytes(byte[] bytes)
	{
		int toReturn = 0;
		int tmpInt = bytes[0] & 0b1111_1111;
		toReturn |= tmpInt;
		toReturn <<= 8;
		tmpInt = bytes[1] & 0b1111_1111;
		toReturn |= tmpInt;
		toReturn <<= 8;
		tmpInt = bytes[2] & 0b1111_1111;
		toReturn |= tmpInt;
		toReturn <<= 8;
		tmpInt = bytes[3] & 0b1111_1111;
		toReturn |= tmpInt;
		
		return toReturn;
	}
	
	public static byte[] toBytes(int value)
	{
		byte[] toReturn = new byte[4];
		
		toReturn[0] = (byte) ((value & 0b1111_1111_0000_0000_0000_0000_0000_0000) >> 24);
		toReturn[1] = (byte) ((value & 0b1111_1111_0000_0000_0000_0000) >> 16);
		toReturn[2] = (byte) ((value & 0b1111_1111_0000_0000) >> 8);
		toReturn[3] = (byte) ((value & 0b1111_1111));
		
		return toReturn;
	}
	
	public static void setCPSR(boolean N, boolean Z, boolean C, boolean V)
	{
		Register cpsr = Processor.getInstance().getRegisterPerMode(18);
		
//		System.out.println("Before : " + Integer.toBinaryString(cpsr.getValue()));
		
		if(N)
			cpsr.setValue(cpsr.getValue() | (0b1 << 31));
		else
			cpsr.setValue(cpsr.getValue() & ~(0b1 << 31));
		if(Z)
			cpsr.setValue(cpsr.getValue() | (0b1 << 30));
		else
			cpsr.setValue(cpsr.getValue() & ~(0b1 << 30));
		if(C)
			cpsr.setValue(cpsr.getValue() | (0b1 << 29));
		else
			cpsr.setValue(cpsr.getValue() & ~(0b1 << 29));
		if(V)
			cpsr.setValue(cpsr.getValue() | (0b1 << 28));
		else
			cpsr.setValue(cpsr.getValue() & ~(0b1 << 28));
		
//		System.out.println("After : " + Integer.toBinaryString(cpsr.getValue()));
	}
}
