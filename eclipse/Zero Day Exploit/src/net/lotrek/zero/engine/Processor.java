package net.lotrek.zero.engine;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.InvocationTargetException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.concurrent.LinkedBlockingQueue;

import net.lotrek.zero.ZeroDayExploit;
import net.lotrek.zero.graphics.GLComplex;
import net.lotrek.zero.graphics.RenderAction;
import net.lotrek.zero.story.Event;
import net.lotrek.zero.story.StoryCore;
import net.lotrek.zero.tools.FileUtil;
import net.lotrek.zero.tools.GameUtil;
import net.lotrek.zero.tools.MemoryUtil;

import org.newdawn.slick.Color;
import org.newdawn.slick.Graphics;

public class Processor
{
	public static enum ProcessorMode {
		USR(0b1000), FIQ(0b0100), SUP(0b0010), ABT(0b0001), IRQ(0b1001), UNDEF(0b0101), SYS(0b0011);
		
		public byte id;
		
		private ProcessorMode(int id)
		{
			this.id = (byte) id;
		}
	}
	
	public LinkedList<RandomAccessFile> disks = new LinkedList<RandomAccessFile>();
	private RandomAccessFile bios;
	public byte[] memory;
	public byte[] memorySec;
	public final String threadID = Thread.currentThread().getName();
	
	private HashMap<String, Register> globalRegsiters = new HashMap<String, Register>();
	private LinkedBlockingQueue<Byte> netQueue = new LinkedBlockingQueue<Byte>();
	private static Processor playerInstance;
	private static HashMap<String, Processor> servers = new HashMap<String, Processor>();
	private ProcessorMode mode = ProcessorMode.UNDEF;
	private boolean toExit, suspended;
	public volatile boolean canExit;
	private int toIntrupt = -1, toAbort = -1;
	
	public Processor(String biosFile, int memLength, String...diskFiles)
	{
		this.memory = new byte[memLength];
		this.memorySec = new byte[memLength / 4];
		
		this.globalRegsiters.clear();
		Register.initializeRegisters(globalRegsiters);
		
		servers.put(threadID, this);
		
		try {
			this.bios = new RandomAccessFile(new File(FileUtil.baseDir + biosFile), "rw");
			for(String file : diskFiles)
				this.disks.push(new RandomAccessFile(new File(FileUtil.baseDir + file), "rw"));
			
			MemoryUtil.loadFile(0, 0, 0xA545, getBiosImage());
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public static Processor getInstance()
	{
		return servers.get(Thread.currentThread().getName());
	}
	
	public static Processor getInstance(String name)
	{
		return servers.get(name);
	}
	
	public static boolean isPlayer()
	{
		return playerInstance == getInstance();
	}
	
	public static void setPlayer(Processor inst)
	{
		playerInstance = inst;
	}
	
	public static Processor getPlayer()
	{
		return playerInstance;
	}
	
	public static void killAll()
	{
		
		for(Processor item : servers.values())
		{
			item.haltProcessor();
			while(!item.canExit);
		}
		servers.clear();
		playerInstance = null;
		System.gc();
	}
	
	public void suspend(boolean toSuspend)
	{
		this.suspended = toSuspend;
	}
	
	public int addDisk(String name)
	{
		try {
			this.disks.add(new RandomAccessFile(new File(FileUtil.baseDir + name), "rw"));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		
		return this.disks.size() - 1;
	}
	
	public void removeDisk(int id)
	{
		this.disks.remove(id);
	}
	
	public HashMap<String, Register> getRegisters()
	{
		return globalRegsiters;
	}
	
	public void queueIntrupt(int id)
	{
		this.toIntrupt = id;
	}
	
	public void queueAbort()
	{
		this.toAbort = 0;
	}
	
	public byte[] getMemorySegment(int start, int length)
	{
		byte[] toReturn = new byte[length];
		
		for (int index = 0; index < toReturn.length; index++)
			toReturn[index] = this.getMemory(start + index);
		
		return toReturn;
	}
	
	public void setMemorySegment(int start, byte...data)
	{
		for (int index = 0; index < data.length; index++)
			this.setMemory(start + index, data[index]);
	}
	
	public byte getMemory(int addr)
	{
		if((this.mode == ProcessorMode.USR && this.getSec(addr)) || this.mode != ProcessorMode.USR)
			return this.memory[addr];
		else
			return 0;
	}
	
	public void setMemory(int addr, byte data)
	{
		if((this.mode == ProcessorMode.USR && !this.getSec(addr)) || this.mode != ProcessorMode.USR)
			this.memory[addr] = data;
	}
	
	public void secureRegion(int start, int length, boolean isSecure)
	{
		if(this.mode != ProcessorMode.USR)
		{
			for(int loop = 0; loop < length; loop++)
				this.setSec(start + loop, isSecure);
		}
	}
	
	public boolean getSec(int addr)
	{
		return ((memorySec[addr / 4] >> (addr % 4)) & 0b1) == 0b1;
	}
	
	public void setSec(int addr, boolean toSet)
	{
		if(toSet)
			memorySec[addr / 4] |= 0b1 << (addr % 4);
		else
			memorySec[addr / 4] &= ~(0b1 << (addr % 4));
	}
	
	public RandomAccessFile getBiosImage()
	{
		return this.bios;
	}
	
	public Register getRegisterPerMode(int id)
	{
		if(id == 18)
			return globalRegsiters.get("cpsr");
		
		if(id == 15)
			return globalRegsiters.get("pc");
		
		if(id == 12)
			return globalRegsiters.get("ivt");
		
		if(this.mode != ProcessorMode.SYS)
			return globalRegsiters.get("r" + id + "_" +this.mode.name());
		else
			return globalRegsiters.get("r" + id + "_" + ProcessorMode.USR.name());
	}
	
	public Register getRegisterWithMode(int id, int mode)
	{
		ProcessorMode tmpMode = this.mode;
		
		for(ProcessorMode loopMode : ProcessorMode.values())
			if(loopMode.id == mode)
				tmpMode = loopMode;
		
		if(id == 18)
			return globalRegsiters.get("cpsr");
		
		if(id == 15)
			return globalRegsiters.get("pc");
		
		if(id == 12)
			return globalRegsiters.get("ivt");
		
		if(this.mode != ProcessorMode.SYS)
			return globalRegsiters.get("r" + id + "_" + tmpMode.name());
		else
			return globalRegsiters.get("r" + id + "_" + ProcessorMode.USR.name());
	}
	
	public Register getRegisterWithMode(int id, ProcessorMode mode)
	{
		if(id == 18)
			return globalRegsiters.get("cpsr");
		
		if(id == 15)
			return globalRegsiters.get("pc");
		
		if(id == 12)
			return globalRegsiters.get("ivt");
		
		if(this.mode != ProcessorMode.SYS)
			return globalRegsiters.get("r" + id + "_" + mode.name());
		else
			return globalRegsiters.get("r" + id + "_" + ProcessorMode.USR.name());
	}
	
	public void setMode(ProcessorMode newMode)
	{
		this.mode = newMode;
//		System.out.println("Mode updated to " + newMode.name());
	}
	
	public ProcessorMode getMode()
	{
		return this.mode;
	}
	
	public void haltProcessor()
	{
//		System.err.println("HALT " + Thread.currentThread().getName());
		
		toExit = true;
		
		if(isPlayer())
			StoryCore.haltStory();
	}
	
	public RandomAccessFile getDisk(int id)
	{
		return disks.get(id);
	}
	
	public void pushNetwork(byte ... data)
	{
//		System.out.println("Pushed " + data.length + " bytes to the network interface : " + Arrays.toString(data));
		
		for(byte item : data)
			this.netQueue.add(item);
	}
	
	public byte[] popNetwork(int length)
	{
		byte[] b = new byte[length];
		
		for (int i = 0; i < b.length; i++)
			b[i] = this.netQueue.poll();
		
//		System.out.println("Popped " + length + " bytes from the network interface : " + Arrays.toString(b));
		
		return b;
	}
	
	public int bufferLength()
	{
		return netQueue.size();
	}
	
	public void clearBuffer()
	{
		netQueue.clear();
	}
	
	private int instructionCount = 0;
	
	//The method to end all methods
	public void execute(int position)
	{
		Event.GoalEvent.hasEnded.remove(threadID);
		
		this.suspend(isPlayer());
		
		this.getRegisterPerMode(15).setValue(position);
		while(!toExit && AsmCore.fromBytes(this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4)) != 0 && !StoryCore.doHalt())
		{
			if(suspended)
				continue;
			
			int inst = AsmCore.fromBytes(this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4));
			String data = AsmCore.guessData(inst);
			
			if (AsmCore.detectSanity(data) && (AsmCore.isCondition(inst) && (AsmCore.guessSecure(data) ? this.getMode() != ProcessorMode.USR : true) && (AsmCore.guessPlayer(data) ? isPlayer() : true)))
				try {
					if(ZeroDayExploit.getKey("--trace") && !AsmCore.guessCode(inst).contains("B"))
						System.out.println(this.threadID + " : " + AsmCore.guessCode(inst) + " : " + (Assembler.guessCondition(inst).isEmpty() ? "AL" : Assembler.guessCondition(inst)) + " : " + Integer.toBinaryString(inst) + " : " + this.getRegisterPerMode(14) + " : " + this.getRegisterPerMode(15));
					AsmCore.guessHost(data, 2).getDeclaredMethod(AsmCore.guessCode(data), int.class).invoke(null, inst);
				} catch (IllegalAccessException | IllegalArgumentException
						| InvocationTargetException | NoSuchMethodException
						| SecurityException e) {
					System.err.println("Processor halted while attempting " + AsmCore.guessCode(inst));
					e.printStackTrace();
					this.haltProcessor();
				}
			else if(AsmCore.guessSecure(data) ? this.getMode() == ProcessorMode.USR : false)
			{
				GameUtil.throwNonFatal(GameUtil.ErrorCode.instructionAccess);
			}
			
			this.getRegisterPerMode(15).setValue(this.getRegisterPerMode(15).getValue() + 4);
			
			if(this.toIntrupt >= 0)
			{
				if (this.mode != ProcessorMode.FIQ && this.mode != ProcessorMode.IRQ) {
					int tmpAddr = Processor.getInstance().getRegisterPerMode(15)
							.getValue();
					Processor.getInstance().getRegisterPerMode(15).setValue(
							AsmCore.fromBytes(Processor.getInstance()
									.getMemorySegment(Processor.getInstance()
											.getRegisterPerMode(12).getValue()
											+ (this.toIntrupt * 4), 4)));
					Processor.getInstance().setMode(ProcessorMode.FIQ);
					Processor.getInstance().getRegisterPerMode(14).setValue(
							tmpAddr - 4);
				}
				this.toIntrupt = -1;
//				System.out.println("INTRUTPT : " + Processor.instance.getRegisterPerMode(15).getValue() + " POINTER : " + Processor.instance.getRegisterPerMode(12).getValue());
			}
			
			if(this.toAbort >= 0)
			{
				int tmpAddr = Processor.getInstance().getRegisterPerMode(15)
						.getValue();
				Processor.getInstance().getRegisterPerMode(15).setValue(
						AsmCore.fromBytes(Processor.getInstance()
								.getMemorySegment(Processor.getInstance()
										.getRegisterPerMode(12).getValue()
										+ (this.toAbort * 4), 4)));
				Processor.getInstance().setMode(ProcessorMode.ABT);
				Processor.getInstance().getRegisterPerMode(14).setValue(
						tmpAddr - 4);
				this.toAbort = -1;
//				System.out.println("INTRUTPT : " + Processor.instance.getRegisterPerMode(15).getValue() + " POINTER : " + Processor.instance.getRegisterPerMode(12).getValue());
			}
			
			if((this.instructionCount >= (this.getRegisterPerMode(18).getValue() & 0b1111_1111_1111_1111_1111_1111_1111)) && (this.getRegisterPerMode(18).getValue() & 0b1111_1111_1111_1111_1111_1111_1111) != 0)
			{
				this.toIntrupt = 1;
				this.instructionCount = 0;
			}
			
			instructionCount++;
		}
		
		if(AsmCore.fromBytes(this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4)) == 0 && ZeroDayExploit.getKey("--trace") && !this.toExit)
			System.out.println(this.threadID + " : EXIT : Processor halted due to a NULL opcode");
		
//		System.err.println(StoryCore.doHalt() + " TERMINATE " + Thread.currentThread().getName()+ " : " + getInstance(playerInstance.threadID));
		
		if(ZeroDayExploit.getKey("--dump") && this.memory != null && isPlayer())
		{
			GameUtil.doExit = false;
			
			try {
				GameUtil.queueClear();
				GameUtil.renderQueue.add(new RenderAction<Graphics>(Graphics.class.getDeclaredMethod("setColor", Color.class), GLComplex.getContainer().getGraphics(), true, Color.white));
//				GameUtil.renderQueue.add(new RenderAction<Graphics>(Graphics.class.getDeclaredMethod("clear"), GLComplex.getContainer().getGraphics(), true));
				GameUtil.renderQueue.add(new RenderAction<Graphics>(Graphics.class.getDeclaredMethod("drawString", String.class, float.class, float.class), GLComplex.getContainer().getGraphics(), true, "Processor terminated\nDumping virtual memory to \"" + new SimpleDateFormat("MM_dd_yyyy-HH_mm_ss_SSS").format(Calendar.getInstance().getTime()) + "-" + GameUtil.saveFile.split("\\.")[0] + ".dmp\", sized at " + this.memory.length + " bytes", 10, 10));
				} catch (NoSuchMethodException | SecurityException e) {
				e.printStackTrace();
			}
			try {
				System.err.println("Dumping virtual memory...");
				long prevTime = System.currentTimeMillis();
				String name = new SimpleDateFormat("MM_dd_yyyy-HH_mm_ss_SSS").format(Calendar.getInstance().getTime()) + "-" + GameUtil.saveFile.split("\\.")[0] + ".dmp";
				FileOutputStream os = new FileOutputStream(new File(name));
				os.write(Processor.getInstance().memory);
				os.close();
				long time = System.currentTimeMillis() - prevTime;
				System.err.println("Virual memory dumped to " + name + " in " + time + " milliseconds, pulling " + (float)this.memory.length / (float)time + " b/ms");
				
			} catch (IOException e) {
				e.printStackTrace();
			}
			
			GameUtil.doExit = true;
		}
		
		this.haltProcessor();

		this.bios = null;
		this.disks.clear();
		this.memory = null;
		this.setMode(ProcessorMode.UNDEF);
		Event.GoalEvent.hasEnded.add(threadID);
		
		if(isPlayer())
			GameUtil.exitRuntime();
		
		this.canExit = true;
		
	}
}