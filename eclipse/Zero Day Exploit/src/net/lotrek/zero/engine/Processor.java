package net.lotrek.zero.engine;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.LinkedList;

import net.lotrek.zero.ZeroDayExploit;
import net.lotrek.zero.story.StoryCore;
import net.lotrek.zero.tools.GameUtil;
import net.lotrek.zero.tools.MemoryUtil;

public class Processor
{	
	public static enum ProcessorMode {
		USR(0b1000), FIQ(0b0100), SUP(0b0010), ABT(0b0001), IRQ(0b1001), UNDEF(0b0101), SYS(0b0011);
		
		public byte id;
		
		private ProcessorMode(int id)
		{
			this.id = (byte) id;
		}
	}
	
	public LinkedList<RandomAccessFile> disks = new LinkedList<RandomAccessFile>();
	private RandomAccessFile bios;
	public byte[] memory;// = new byte[268435456];
	public byte[] memorySec;// = new byte[memory.length / 4];
	public final String threadID = Thread.currentThread().getName();
	
	private HashMap<String, Register> globalRegsiters = new HashMap<String, Register>();
	private static Processor playerInstance;
	private static HashMap<String, Processor> servers = new HashMap<String, Processor>();
	private ProcessorMode mode = ProcessorMode.UNDEF;
	private boolean toExit, suspended;
	public volatile boolean canExit;
	private int toIntrupt = -1;
	
	public Processor(String biosFile, int memLength, String...diskFiles)
	{
		this.memory = new byte[memLength];
		this.memorySec = new byte[memLength / 4];
		
		this.globalRegsiters.clear();
		Register.initializeRegisters(globalRegsiters);
		
		servers.put(threadID, this);
		
//		System.err.println("INIT " + threadID + " " + (isPlayer() ? "I AM THE DANGER" : "I AM NOBODY"));
		
		try {
			this.bios = new RandomAccessFile(new File(biosFile), "rw");
			for(String file : diskFiles)
				this.disks.push(new RandomAccessFile(new File(file), "rw"));
			
			MemoryUtil.loadFile(0, 0, 0xA545, getBiosImage());
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public static Processor getInstance()
	{
		return servers.get(Thread.currentThread().getName());
	}
	
	public static Processor getInstance(String name)
	{
		return servers.get(name);
	}
	
	public static boolean isPlayer()
	{
		return playerInstance == getInstance();
	}
	
	public static void setPlayer(Processor inst)
	{
//		System.out.println(inst.threadID + " IS THE DANGER");
		playerInstance = inst;
	}
	
	public static Processor getPlayer()
	{
		return playerInstance;
	}
	
	public static void killAll()
	{
		for(Processor item : servers.values())
		{
			item.haltProcessor();
			while(!item.canExit);
		}
		servers.clear();
		playerInstance = null;
		System.gc();
	}
	
	public void suspend(boolean toSuspend)
	{
		this.suspended = toSuspend;
	}
	
	public int addDisk(String name)
	{
		try {
			this.disks.add(new RandomAccessFile(new File(name), "rw"));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		
		return this.disks.size() - 1;
	}
	
	public void removeDisk(int id)
	{
		this.disks.remove(id);
	}
	
	public HashMap<String, Register> getRegisters()
	{
		return globalRegsiters;
	}
	
	public void queueIntrupt(int id)
	{
		this.toIntrupt = id;
	}
	
	public byte[] getMemorySegment(int start, int length)
	{
		byte[] toReturn = new byte[length];
		
		for (int index = 0; index < toReturn.length; index++)
			toReturn[index] = this.getMemory(start + index);
		
		return toReturn;
	}
	
	public void setMemorySegment(int start, byte...data)
	{
		for (int index = 0; index < data.length; index++)
			this.setMemory(start + index, data[index]);
	}
	
	public byte getMemory(int addr)
	{
		if((this.mode == ProcessorMode.USR && this.getSec(addr)) || this.mode != ProcessorMode.USR)
			return this.memory[addr];
		else
			return 0;
	}
	
	public void setMemory(int addr, byte data)
	{
		if((this.mode == ProcessorMode.USR && !this.getSec(addr)) || this.mode != ProcessorMode.USR)
			this.memory[addr] = data;
	}
	
	public void secureRegion(int start, int length, boolean isSecure)
	{
		if(this.mode != ProcessorMode.USR)
		{
			for(int loop = 0; loop < length; loop++)
				this.setSec(start + loop, isSecure);
		}
	}
	
	public boolean getSec(int addr)
	{
		return ((memorySec[addr / 4] >> (addr % 4)) & 0b1) == 0b1;
	}
	
	public void setSec(int addr, boolean toSet)
	{
		if(toSet)
			memorySec[addr / 4] |= 0b1 << (addr % 4);
		else
			memorySec[addr / 4] &= ~(0b1 << (addr % 4));
	}
	
	public RandomAccessFile getBiosImage()
	{
		return this.bios;
	}
	
	public Register getRegisterPerMode(int id)
	{
		if(id == 18)
			return globalRegsiters.get("cpsr");
		
		if(id == 15)
			return globalRegsiters.get("pc");
		
		if(id == 12)
			return globalRegsiters.get("ivt");
		
		if(this.mode != ProcessorMode.SYS)
			return globalRegsiters.get("r" + id + "_" +this.mode.name());
		else
			return globalRegsiters.get("r" + id + "_" + ProcessorMode.USR.name());
	}
	
	public void setMode(ProcessorMode newMode)
	{
		this.mode = newMode;
//		System.out.println("Mode updated to " + newMode.name());
	}
	
	public ProcessorMode getMode()
	{
		return this.mode;
	}
	
	public void haltProcessor()
	{
//		System.err.println("HALT " + Thread.currentThread().getName());
		
		toExit = true;
		
		if(isPlayer())
			StoryCore.haltStory();
	}
	
	public RandomAccessFile getDisk(int id)
	{
		return disks.get(id);
	}
	
	private int instructionCount = 0;
	
	//The method to end all methods
	public void execute(int position)
	{
		this.suspend(isPlayer());
		
		this.getRegisterPerMode(15).setValue(position);
		while(!toExit && AsmCore.fromBytes(this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4)) != 0 && !StoryCore.doHalt())
		{
			if(suspended)
				continue;
			
			int inst = AsmCore.fromBytes(this.getMemorySegment(this.getRegisterPerMode(15).getValue(), 4));
			String data = AsmCore.guessData(inst);
			
			if (AsmCore.detectSanity(data) && (AsmCore.isCondition(inst) && (AsmCore.guessSecure(data) ? this.getMode() != ProcessorMode.USR : true) && (AsmCore.guessPlayer(data) ? isPlayer() : true)))
				try {
					if(ZeroDayExploit.getKey("--trace") && !AsmCore.guessCode(inst).equals("B"))
						System.out.println(this.threadID + " : " + AsmCore.guessCode(inst) + " : " + (Assembler.guessCondition(inst).isEmpty() ? "AL" : Assembler.guessCondition(inst)) + " : " + Integer.toBinaryString(inst) + " : " + this.getRegisterPerMode(14) + " : " + this.getRegisterPerMode(15));
					Instructions.Execution.class.getDeclaredMethod(AsmCore.guessCode(data), int.class).invoke(null, inst);
				} catch (IllegalAccessException | IllegalArgumentException
						| InvocationTargetException | NoSuchMethodException
						| SecurityException e) {
					System.err.println("Processor halted while attempting " + AsmCore.guessCode(inst));
					e.printStackTrace();
					this.haltProcessor();
				}
			else if(AsmCore.guessSecure(data) ? this.getMode() == ProcessorMode.USR : false)
			{
				GameUtil.throwNonFatal("Security exception on " + AsmCore.guessCode(inst) + " instruction");
			}
//				System.out.println("Ignored a" + (AsmCore.guessCode(inst).startsWith("A") || AsmCore.guessCode(inst).startsWith("E") || AsmCore.guessCode(inst).startsWith("I") || AsmCore.guessCode(inst).startsWith("O") || AsmCore.guessCode(inst).startsWith("U") ? "n " : " ") + AsmCore.guessCode(inst) + " instruction due to condition codes");
			this.getRegisterPerMode(15).setValue(this.getRegisterPerMode(15).getValue() + 4);
			
			if(this.toIntrupt >= 0)
			{
				if (this.mode != ProcessorMode.FIQ && this.mode != ProcessorMode.IRQ) {
					int tmpAddr = Processor.getInstance().getRegisterPerMode(15)
							.getValue();
					Processor.getInstance().getRegisterPerMode(15).setValue(
							AsmCore.fromBytes(Processor.getInstance()
									.getMemorySegment(Processor.getInstance()
											.getRegisterPerMode(12).getValue()
											+ (this.toIntrupt * 4), 4)));
					//				Processor.instance.getRegisterPerMode(14).setValue(tmpAddr - 4);
					Processor.getInstance().setMode(ProcessorMode.FIQ);
					Processor.getInstance().getRegisterPerMode(14).setValue(
							tmpAddr - 4);
				}
				this.toIntrupt = -1;
//				System.out.println("INTRUTPT : " + Processor.instance.getRegisterPerMode(15).getValue() + " POINTER : " + Processor.instance.getRegisterPerMode(12).getValue());
			}
			
			if((this.instructionCount >= (this.getRegisterPerMode(18).getValue() & 0b1111_1111_1111_1111_1111_1111_1111)) && (this.getRegisterPerMode(18).getValue() & 0b1111_1111_1111_1111_1111_1111_1111) != 0)
			{
				this.toIntrupt = 1;
				this.instructionCount = 0;
			}
			
			instructionCount++;
		}
		
//		System.err.println(StoryCore.doHalt() + " TERMINATE " + Thread.currentThread().getName()+ " : " + getInstance(playerInstance.threadID));
		
		this.haltProcessor();

		this.bios = null;
		this.disks.clear();
		this.memory = null;
		this.setMode(ProcessorMode.UNDEF);
		
		if(isPlayer())
			GameUtil.exitRuntime();
		
		this.canExit = true;
	}
}