package net.lotrek.zero.engine;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;

import org.lwjgl.input.Mouse;
import org.newdawn.slick.Color;
import org.newdawn.slick.Graphics;

import net.lotrek.zero.Abraxas;
import net.lotrek.zero.graphics.GLComplex;
import net.lotrek.zero.graphics.GraphicsUtil;
import net.lotrek.zero.graphics.RenderAction;
import net.lotrek.zero.network.NetworkCore;
import net.lotrek.zero.tools.FileUtil;
import net.lotrek.zero.tools.GameUtil;
import net.lotrek.zero.tools.MouseUtil;
import net.lotrek.zero.tools.MultiplexOutputStream;

public final class APPLETONx32 extends Engine
{
	private HashMap<Integer, Byte> memory;
	private HashMap<Integer, Boolean> security;
	private int memSize;
	private volatile boolean shouldTerminate, shouldSuspend;
	private int[][] registers = new int[5][17];
	private Mode currentMode = Mode.SUPERVISOR;
	private ArrayList<RandomAccessFile> disks = new ArrayList<RandomAccessFile>();
	private int quantumLength, quantumCount, r15 = 0, intID = -1;
	private Number[] intArgs;
	private String address;
	private Thread executionThread = new Thread()
	{
		public void run()
		{
			registerEngine(address);
			
			net.lotrek.zero.story.Event.GoalEvent.hasEnded.remove(Util.getProc().getName());
			
			if(isPlayer())
				Util.getProc().setSuspended(true);
			
			while(!shouldTerminate)
			{
				if(quantumLength > 0)
				{
					quantumCount++;
					
					if(quantumCount > quantumLength)
					{
						Util.getProc().interrupt(0, false);
						quantumCount = 0;
					}
				}else
					quantumCount = 0;
				execute();
			}
			
			executionThread = null;
			
			unregisterEngine();
			
			net.lotrek.zero.story.Event.GoalEvent.hasEnded.add(Util.getProc().getName());
		}
	};
	
	public static enum Mode
	{
		SUPERVISOR(0),
		SYSTEM(1),
		USER(2),
		INTERRUPT(3),
		ABORT(4),
		;
		
		public int id;
		
		Mode(int id)
		{
			this.id = id;
		}
		
		public int getRegister(APPLETONx32 proc, int register, int[][] registers)
		{
			if(register == 15)
				return proc.r15;
			return registers[id][register];
		}
		
		public void setRegister(APPLETONx32 proc, int register, int value, int[][] registers)
		{
			if(register == 15)
			{
				proc.r15 = value;
				return;
			}
			registers[id][register] = value;
		}
		
		public static Mode getModeForID(int id)
		{
			for(Mode mode : Mode.values())
				if(mode.id == id)
					return mode;
			return Util.getProc().currentMode;
		}
	}
	
	public static class Instructions
	{
		public static ArrayList<String> proc;
		public static String[] cond = {"EQ",
			"NE",
			"CS",
			"CC",
			"MI",
			"PL",
			"VS",
			"VC",
			"HI",
			"LS",
			"GE",
			"LT",
			"GT",
			"LE",
			"AL"};
		
		public static void init()
		{
			if(proc == null)
			{
				proc = new ArrayList<String>();
				
				Scanner procReader = new Scanner(FileUtil.getFile("res.bin/PROCx32"));
				
				while(procReader.hasNextLine())
					proc.add(procReader.nextLine());
				
				procReader.close();
			}
		}
		
		public static class Execution
		{
			public static void LSL(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int[] values = Util.expandStandardOpcode(opcode);
				int op1 = proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) << values[2]);
				Util.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") << " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void LSR(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int[] values = Util.expandStandardOpcode(opcode);
				int op1 = proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) >> values[2]);
				Util.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") >> " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void ASR(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int[] values = Util.expandStandardOpcode(opcode);
				int op1 = proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) >>> values[2]);
				Util.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") >>> " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void DSTR(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int memStart = proc.getRegisterForMode((opcode >> 16) & 0xf), diskStart = proc.getRegisterForMode((opcode >> 12) & 0xf), length = proc.getRegisterForMode((opcode >> 8) & 0xf), id = (((opcode >> 12) & 1) == 0) ? proc.getRegisterForMode((opcode >> 0) & 0xf) : Util.expandInt(((opcode >> 0) & 0xf), 4);
				
				Util.printDebug("memStart: " + memStart + " diskStart: " + diskStart + " length: " + length + " id: " + id);
				
				try {
					byte[] read = proc.getMemoryRange(memStart, length);
					proc.disks.get(id).seek(diskStart);
					proc.disks.get(id).write(read);
				} catch (IOException e) {
				}
			}
			
			public static void DLDR(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int memStart = proc.getRegisterForMode((opcode >> 16) & 0xf), diskStart = proc.getRegisterForMode((opcode >> 12) & 0xf), length = proc.getRegisterForMode((opcode >> 8) & 0xf), id = (((opcode >> 20) & 1) == 0) ? proc.getRegisterForMode((opcode >> 0) & 0xf) : ((opcode >> 0) & 0xf);
				
				Util.printDebug("memStart: " + memStart + " diskStart: " + diskStart + " length: " + length + " id: " + id);
				
				try {
					byte[] read = new byte[length];
					proc.disks.get(id).seek(diskStart);
					proc.disks.get(id).read(read);
					proc.setMemoryRange(memStart, read);
				} catch (IOException e) {
				}
			}
			
			public static void CTD(int opcode)
			{
				Util.getProc().setRegisterForMode(opcode & 0xf, Util.getProc().disks.size());
				Util.printDebug("r" + (opcode & 0xf) + " <- " + Util.getProc().disks.size());
			}
			
			public static void CPM(int opcode)
			{
				Mode toSet = Util.getProc().currentMode;
				
				for(Mode mode : APPLETONx32.Mode.values())
					if(mode.id == (opcode & 0xf))
					{
						toSet = mode;
						break;
					}
				
				Util.getProc().currentMode = toSet;
				
				Util.printDebug("Set processor mode to " + Util.getProc().currentMode.name());
			}
			
			public static void HLT(int opcode)
			{
				Util.getProc().terminate();
				Util.forceDebug(Engine.getEngine().getName() + " terminated");
			}
			
			public static void PUSH(int opcode)
			{
				int val = Util.getProc().getRegisterForMode(13), off = Util.fromBytes(Util.getProc().getMemoryRange(val, 4));
				
				Util.getProc().setMemoryRange(val + off, Util.toBytes(Util.getProc().getRegisterForMode(opcode & 0xf)));
				Util.getProc().setMemoryRange(val, Util.toBytes(off + 4));
				
				Util.printDebug("Pushed " + Util.getProc().getRegisterForMode(opcode & 0xf) + " (r" + (opcode & 0xf) + ") stack 0x" + Integer.toHexString(val) + " in offset " + off);
			}
			
			public static void POP(int opcode)
			{
				int val = Util.getProc().getRegisterForMode(13), off = Util.fromBytes(Util.getProc().getMemoryRange(val, 4)) - 4;
				
				Util.getProc().setRegisterForMode(opcode & 0xf, Util.fromBytes(Util.getProc().getMemoryRange(val + off, 4)));
				Util.getProc().setMemoryRange(val, Util.toBytes(off));
				
				Util.printDebug("Popped " + Util.getProc().getRegisterForMode(opcode & 0xf) + " from stack 0x" + Integer.toHexString(val) + " at offset " + off + " into r" + (opcode & 0xf));
			}
			
			public static void SEC(int opcode)
			{
				int start = Util.getProc().getRegisterForMode((opcode >> 16) & 0xf), length = Util.getProc().getRegisterForMode((opcode >> 12) & 0xf);
				boolean toSecure = ((opcode >> 20) & 1) == 0 ? (opcode & 0xf) == 1 : Util.getProc().getRegisterForMode(opcode & 0xf) == 1;
			
				Util.getProc().setSecurityRange(start, length, toSecure);
				
				Util.printDebug("Secured from 0x" + Integer.toHexString(start) + " to 0x" + Integer.toHexString(start + length) + " (" + length + " bytes total)");
			}
			
			public static void QNTM(int opcode)
			{
				Util.getProc().quantumLength = ((opcode >> 20) & 1) == 0 ? Util.expandInt(opcode & 0xfffff, 20) : Util.getProc().getRegisterForMode(opcode & 0xf);
				
				Util.printDebug("Updated quantum length to " + Util.getProc().quantumLength + (((opcode >> 20) & 1) == 1 ? " (r" + (opcode & 0xf) + ")" : ""));
			}
			
			public static void GQTM(int opcode)
			{
				Util.getProc().setRegisterForMode(opcode & 0xf, Util.getProc().quantumLength);
				
				Util.printDebug("r" + (opcode & 0xf) + " <- " + Util.getProc().quantumLength);
			}
			
			public static void B(int opcode)
			{
				Util.getProc().setRegisterForMode(15, Util.getProc().getRegisterForMode(15) + Util.expandInt(opcode & 0x1fffff, 21) - 4);
				
				Util.printDebug("Jumped " + Util.expandInt(opcode & 0x1fffff, 21) + " bytes away and ended up at 0x" + Util.getProc().getRegisterForMode(15));
			}
			
			public static void BL(int opcode)
			{
				Util.getProc().setRegisterForMode(14, Util.getProc().getRegisterForMode(15));
				Util.getProc().setRegisterForMode(15, Util.getProc().getRegisterForMode(15) + Util.expandInt(opcode & 0x1fffff, 21) - 4);
				
				Util.printDebug("Jumped " + Util.expandInt(opcode & 0x1fffff, 21) + " bytes away and ended up at 0x" + Util.getProc().getRegisterForMode(15) + ", left a link to 0x" + Util.getProc().getRegisterForMode(14));
			}
			
			public static void BX(int opcode)
			{
				int toReturn = Util.getProc().getRegisterForMode(15);
				Util.getProc().setRegisterForMode(15, Util.getProc().getRegisterForMode(opcode & 0xf) - 4);
				//Util.getProc().setRegisterForMode(15, Util.getProc().getRegisterForMode(15) + Util.expandInt(opcode & 0x7ffff, 17) - 4);
				Util.getProc().setRegisterForMode(14, toReturn);
				
				Util.printDebug("Jumped to " + Util.getProc().getRegisterForMode(15) + ", left a link to 0x" + Util.getProc().getRegisterForMode(14) + ", switched mode to " + Util.getProc().currentMode.name());
				
				Util.getProc().currentMode = Mode.getModeForID((opcode >> 17) & 0xf);
			}
			
			public static void STR(int opcode)
			{
				int base = Util.getProc().getRegisterForMode((opcode >> 17) & 0xf), toSet = Util.getProc().getRegisterForMode((opcode >> 13) & 0xf), offset = Util.expandInt(opcode & 0x1fff, 13);
				
				Util.getProc().setMemoryRange(base + offset, Util.toBytes(toSet));
				
				Util.printDebug("Stored 0x" + Integer.toHexString(toSet) + " (r" + ((opcode >> 13) & 0xf) + ") to address 0x" + Integer.toHexString(base + offset));
			}
			
			public static void LDR(int opcode)
			{
				int base = Util.getProc().getRegisterForMode((opcode >> 17) & 0xf), toSet = (opcode >> 13) & 0xf, offset = Util.expandInt(opcode & 0x1fff, 13);
				
				Util.getProc().setRegisterForMode(toSet, Util.fromBytes(Util.getProc().getMemoryRange(base + offset, 4)));
				
				Util.printDebug("Loaded 0x" + Integer.toHexString(Util.getProc().getRegisterForMode(toSet)) + " to r" + toSet +" from address 0x" + Integer.toHexString(base + offset));
			}
			
			public static void STRB(int opcode)
			{
				int base = Util.getProc().getRegisterForMode((opcode >> 17) & 0xf), toSet = Util.getProc().getRegisterForMode((opcode >> 13) & 0xf) & 0xff, offset = Util.expandInt(opcode & 0x1fff, 13);
				
				Util.getProc().setMemory(base + offset, (byte) toSet);
				
				Util.printDebug("Stored 0x" + Integer.toHexString(toSet) + " (r" + ((opcode >> 13) & 0xf) + ") to address 0x" + Integer.toHexString(base + offset));
			}
			
			public static void LDRB(int opcode)
			{
				int base = Util.getProc().getRegisterForMode((opcode >> 17) & 0xf), toSet = (opcode >> 13) & 0xf, offset = Util.expandInt(opcode & 0x1fff, 13);
				
				Util.getProc().setRegisterForMode(toSet, Util.getProc().getMemory(base + offset));
				
				Util.printDebug("Loaded 0x" + Integer.toHexString(Util.getProc().getRegisterForMode(toSet)) + " to r" + toSet +" from address 0x" + Integer.toHexString(base + offset));
			}
			
			public static void SWP(int opcode)
			{
				int base = Util.getProc().getRegisterForMode((opcode >> 17) & 0xf), toSet = (opcode >> 13) & 0xf, offset = Util.expandInt(opcode & 0x1fff, 13), oldVal = Util.getProc().getRegisterForMode(toSet);
				
				Util.getProc().setRegisterForMode(toSet, Util.fromBytes(Util.getProc().getMemoryRange(base + offset, 4)));
				Util.getProc().setMemoryRange(base + offset, Util.toBytes(oldVal));
				
				Util.printDebug("Swapped 0x" + Integer.toHexString(oldVal) + " (r" + toSet + ") with address 0x" + Integer.toHexString(base + offset));
			}
			
			public static void SWPB(int opcode)
			{
				int base = Util.getProc().getRegisterForMode((opcode >> 17) & 0xf), toSet = (opcode >> 13) & 0xf, offset = Util.expandInt(opcode & 0x1fff, 13), oldVal = Util.getProc().getRegisterForMode(toSet) & 0xf;
				
				Util.getProc().setRegisterForMode(toSet, Util.getProc().getMemory(base + offset));
				Util.getProc().setMemory(base + offset, (byte) oldVal);
				
				Util.printDebug("Swapped 0x" + Integer.toHexString(oldVal) + " (r" + toSet + ") with address 0x" + Integer.toHexString(base + offset));
			}
			
			public static void MUL(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int[] values = Util.expandStandardOpcode(opcode);
				int op1 = proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) * values[2]);
				Util.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") * " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void DIV(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int[] values = Util.expandStandardOpcode(opcode);
				int op1 = proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) / values[2]);
				Util.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") / " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void SVC(int opcode)
			{
				Util.getProc().interrupt(opcode & 0xff, false);
				
				Util.printDebug("Called interrupt " + (opcode & 0xff));
			}
			
			public static void CLR(int opcode)
			{
				GameUtil.queueClear();
				Util.printDebug("Queued screen clear");
			}
			
			private static boolean fill = false;
			
			public static void DRAW(int opcode)
			{
				fill = false;
				
				Util.printDebug("Set mode to draw");
			}
			
			public static void FILL(int opcode)
			{
				fill = true;
				
				Util.printDebug("Set mode to fill");
			}
			
			public static void RECT(int opcode)
			{
				int x = Util.getProc().getRegisterForMode(opcode & 0xf), y = Util.getProc().getRegisterForMode((opcode >> 4) & 0xf), w = Util.getProc().getRegisterForMode((opcode >> 8) & 0xf), h = Util.getProc().getRegisterForMode((opcode >> 12) & 0xf);
				
				Util.printDebug("x:" + x + " y:" + y + " w:" + w + " h:" + h);
				
				try {
					GameUtil.renderQueue.add(new RenderAction<Graphics>(Graphics.class.getDeclaredMethod((fill ? "fill" : "draw") + "Rect", float.class, float.class, float.class, float.class), GLComplex.getContainer().getGraphics(), true, x, y, w, h));
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
			}
			
			public static void OVL(int opcode)
			{
				int x = Util.getProc().getRegisterForMode(opcode & 0xf), y = Util.getProc().getRegisterForMode((opcode >> 4) & 0xf), w = Util.getProc().getRegisterForMode((opcode >> 8) & 0xf), h = Util.getProc().getRegisterForMode((opcode >> 12) & 0xf);
				
				Util.printDebug("x:" + x + " y:" + y + " w:" + w + " h:" + h);
				
				try {
					GameUtil.renderQueue.add(new RenderAction<Graphics>(Graphics.class.getDeclaredMethod((fill ? "fill" : "draw") + "Oval", float.class, float.class, float.class, float.class), GLComplex.getContainer().getGraphics(), true, x, y, w, h));
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
			}
			
			public static void COLOR(int opcode)
			{
				int value = Util.getProc().getRegisterForMode(opcode & 0xf);
				Color toSet = new Color((value >> 24) & 0xff, (value >> 16) & 0xff, (value >> 8) & 0xff, (value >> 0) & 0xff);
				
				Util.printDebug("Set color to (" + toSet.r + ", " + toSet.g + ", " + toSet.b + ", " + toSet.a + ") (r" + (opcode & 0xf) + ")"); 
				
				try {
					GameUtil.renderQueue.add(new RenderAction<Graphics>(Graphics.class.getDeclaredMethod("setColor", Color.class), GLComplex.getContainer().getGraphics(), true, toSet));
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
			}
			
			public static void GCOLOR(int opcode)
			{
				Util.getProc().setRegisterForMode(opcode & 0xf, (GLComplex.getContainer().getGraphics().getColor().getRedByte() << 24) | (GLComplex.getContainer().getGraphics().getColor().getGreenByte() << 16) | (GLComplex.getContainer().getGraphics().getColor().getBlueByte() << 8) | (GLComplex.getContainer().getGraphics().getColor().getAlphaByte() << 0));
				
				Util.printDebug("Color pulled at (" + GLComplex.getContainer().getGraphics().getColor().getRed() + ", " + GLComplex.getContainer().getGraphics().getColor().getGreen() + ", " + GLComplex.getContainer().getGraphics().getColor().getBlue() + ") -> r" + (opcode & 0xf));
			}
			
			public static void TEXT(int opcode)
			{
				float x = Util.getProc().getRegisterForMode(opcode & 0xf), y = Util.getProc().getRegisterForMode((opcode >> 4) & 0xf), off = Util.getProc().getRegisterForMode((opcode >> 8) & 0xf);
				
				byte[] textBytes = {};
				
				byte[] oldBytes = textBytes;
				textBytes = new byte[textBytes.length + 1];
				System.arraycopy(oldBytes, 0, textBytes, 0, oldBytes.length);
				textBytes[oldBytes.length] = Util.getProc().getMemory((int) (off + oldBytes.length));
				
				while(textBytes[textBytes.length - 1] != 0)
				{
					oldBytes = textBytes;
					textBytes = new byte[textBytes.length + 1];
					System.arraycopy(oldBytes, 0, textBytes, 0, oldBytes.length);
					textBytes[oldBytes.length] = Util.getProc().getMemory((int) (off + oldBytes.length));
				}
				
				Util.printDebug("Displayed string \"" + new String(textBytes).substring(0, textBytes.length - 1) + "\" at " + x + " (r" + (opcode & 0xf) +"), " + y + " (r" + ((opcode >> 4) & 0xf) + ") from address 0x" + Integer.toHexString((int) off) + " (r" + ((opcode >> 8) & 0xf) + ")");
				
				try {
					GameUtil.renderQueue.add(new RenderAction<Graphics>(Graphics.class.getDeclaredMethod("drawString", String.class, float.class, float.class), GLComplex.getContainer().getGraphics(), true, new String(textBytes, "UTF-8").replace((char) 13, '\n'), x, y));
				} catch (NoSuchMethodException | SecurityException | UnsupportedEncodingException e) {
					e.printStackTrace();
				}
			}
			
			public static void MOUSE(int opcode)
			{
				Util.getProc().setRegisterForMode(opcode & 0xf, Mouse.getX());
				Util.getProc().setRegisterForMode((opcode >> 4) & 0xf, MouseUtil.getY());
				
				Util.printDebug("r" + (opcode & 0xf) + " <- " + Util.getProc().getRegisterForMode(opcode & 0xf) + " r" + ((opcode >> 4) & 0xf) + " <- " + Util.getProc().getRegisterForMode((opcode >> 4) & 0xf));
			}
			
			public static void ROT(int opcode)
			{
				int x = Util.getProc().getRegisterForMode(opcode & 0xf), y = Util.getProc().getRegisterForMode((opcode >> 4) & 0xf), o = Util.getProc().getRegisterForMode((opcode >> 8) & 0xf);
				
				GameUtil.setRotate(x, y, o);
				
				Util.printDebug("Set mode to draw");
			}
			
			public static void SCR(int opcode)
			{
				Util.getProc().setRegisterForMode(opcode & 0xf, GraphicsUtil.getScreenWidth());
				Util.getProc().setRegisterForMode((opcode >> 4) & 0xf, GraphicsUtil.getScreenHeight());
				
				Util.printDebug("[r" + (opcode & 0xf) +  ", r" + ((opcode >> 4) & 0xf) + "] <- [" + GraphicsUtil.getScreenWidth() + ", " + GraphicsUtil.getScreenHeight() + "]");
			}
			
			public static void BLK(int opcode)
			{
				GameUtil.block(true);
				
				Util.printDebug("Blocked rendering");
			}
			
			public static void UBLK(int opcode)
			{
				GameUtil.block(false);
				
				Util.printDebug("Unblocked rendering");
			}
			
			public static void EOR(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int[] values = Util.expandStandardOpcode(opcode);
				int op1 = proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) ^ values[2]);
				Util.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") ^ " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void SUB(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int[] values = Util.expandStandardOpcode(opcode);
				int op1 = proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) - values[2]);
				Util.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") - " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void RSB(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int[] values = Util.expandStandardOpcode(opcode);
				int op1 = proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], values[2] - proc.getRegisterForMode(values[1]));
				Util.printDebug("r" + values[0] + " <- " + values[2] + " - " + op1 + " (r" + values[1] + ") = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void ADD(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int[] values = Util.expandStandardOpcode(opcode);
				int op1 = proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) + values[2]);
				Util.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") + " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void TST(int opcode)
			{
				int[] ops = Util.expandStandardOpcode(opcode);
				int op1 = Util.getProc().getRegisterForMode(ops[1]);
				
				Util.printDebug(op1 + " & " + ops[2] + " = " + (op1 & ops[2]));
				
				op1 &= ops[2];
				Util.setCPSR(op1 < 0, op1 == 0, false, false);
			}
			
			public static void TEQ(int opcode)
			{
				int[] ops = Util.expandStandardOpcode(opcode);
				int op1 = Util.getProc().getRegisterForMode(ops[1]);
				
				Util.printDebug(op1 + " ^ " + ops[2] + " = " + (op1 & ops[2]));
				
				op1 ^= ops[2];
				Util.setCPSR(op1 < 0, op1 == 0, false, false);
			}
			
			public static void CMP(int opcode)
			{
				int[] ops = Util.expandStandardOpcode(opcode);
				int op1 = Util.getProc().getRegisterForMode(ops[0]);
				
				Util.printDebug(op1 + " (r" + ops[0] + ") - " + ops[2] + " = " + (op1 - ops[2]));
				
				op1 -= ops[2];
				Util.setCPSR(op1 < 0, op1 == 0, false, false);
			}
			
			public static void CMN(int opcode)
			{
				int[] ops = Util.expandStandardOpcode(opcode);
				int op1 = Util.getProc().getRegisterForMode(ops[1]);
				
				Util.printDebug(op1 + " + " + ops[2] + " = " + (op1 & ops[2]));
				
				op1 += ops[2];
				Util.setCPSR(op1 < 0, op1 == 0, false, false);
			}
			
			public static void ORR(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int[] values = Util.expandStandardOpcode(opcode);
				int op1 = proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) | values[2]);
				Util.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") | " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void MOV(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int[] values = Util.expandStandardOpcode(opcode);
				
				proc.setRegisterForMode(values[0], values[2]);
				Util.printDebug("r" + values[0] + " <- " + values[2]);
			}
			
			public static void BIC(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int[] values = Util.expandStandardOpcode(opcode);
				int op1 = proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) & ~values[2]);
				Util.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") & " + ~values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void MVN(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int[] values = Util.expandStandardOpcode(opcode);
				
				proc.setRegisterForMode(values[0], ~values[2]);
				Util.printDebug("r" + values[0] + " <- " + ~values[2]);
			}
			
			public static void AND(int opcode)
			{
				APPLETONx32 proc = Util.getProc();
				int[] values = Util.expandStandardOpcode(opcode);
				int op1 = proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) & values[2]);
				Util.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") & " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void MVX(int opcode)
			{
				int value = Util.getProc().getRegisterForMode((opcode >> 8) & 0xf), mode = (opcode >> 4) & 0xf;
				
				Mode.getModeForID(mode).setRegister(Util.getProc(), opcode & 0xf, value, Util.getProc().registers);
				Util.printDebug("Moved " + value + " (r" + ((opcode >> 8) & 0xf) + ") to " + Mode.getModeForID(mode).name() + "'s r" + (opcode & 0xf));
			}
			
			public static void SND(int opcode)
			{
				int ip = Util.getProc().getRegisterForMode(opcode & 0xf), start = Util.getProc().getRegisterForMode((opcode >> 4) & 0xf), length = Util.getProc().getRegisterForMode((opcode >> 8) & 0xf);
				
				Util.printDebug("Sent " + length + " bytes of data from 0x" + Integer.toHexString(start) + " to " + NetworkCore.getAddress(ip));
				
				Util.getProc().sendNetworkData(Util.getProc().getMemoryRange(start, length), ip);
			}
			
			public static void RCV(int opcode)
			{
				int start = Util.getProc().getRegisterForMode((opcode >> 4) & 0xf), length = Util.getProc().getRegisterForMode((opcode >> 0) & 0xf);
				
				Util.getProc().setMemoryRange(start, Util.getProc().popNetworkData(length));
				
				Util.printDebug("Recieved " + length + " bytes of data into 0x" + Integer.toHexString(start));
			}
			
			public static void SIZ(int opcode)
			{
				Util.getProc().setRegisterForMode(opcode & 0xf, Util.getProc().networkBufferSize());
				
				Util.printDebug("r" + (opcode & 0xf) + " <- " + Util.getProc().getRegisterForMode(opcode & 0xf));
			}
			
			public static void DMP(int opcode)
			{
				Util.getProc().clearNetworkBuffer();
				
				Util.printDebug("Cleared network buffer");
			}
			
			public static void IP(int opcode)
			{
				Util.getProc().setRegisterForMode(opcode & 0xf, Util.getProc().getAddress());
				
				Util.printDebug("r" + (opcode & 0xf) + " <- " + NetworkCore.getAddress(Util.getProc().getAddress()));
			}
		}
		
		public static class Assembly
		{
			public static int LSL(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int LSR(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int ASR(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int DSTR(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= Util.parseInt(data.split(" ")[0]) << 16;
				toReturn |= Util.parseInt(data.split(" ")[1]) << 12;
				toReturn |= Util.parseInt(data.split(" ")[2]) << 8;
				toReturn |= data.split(" ")[3].startsWith("#") ? Util.compressInt(Util.parseInt(data.split(" ")[3]), 12) | (1 << 20) : Util.parseInt(data.split(" ")[3]);
				
				return toReturn;
			}
			
			public static int DLDR(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= Util.parseInt(data.split(" ")[0]) << 16;
				toReturn |= Util.parseInt(data.split(" ")[1]) << 12;
				toReturn |= Util.parseInt(data.split(" ")[2]) << 8;
				toReturn |= data.split(" ")[3].startsWith("#") ? (Util.parseInt(data.split(" ")[3]) & 0xf) | (1 << 20) : Util.parseInt(data.split(" ")[3]);
				return toReturn;
			}
			
			public static int CTD(String data)
			{
				data = data.toLowerCase().replace("r", "");
				
				return Util.parseInt(data);
			}
			
			public static int CPM(String data)
			{
				data = data.toLowerCase().replace("r", "");
				
				return Util.parseInt(data) & 0xf;
			}
			
			public static int HLT(String data)
			{
				return 0;
			}
			
			public static int PUSH(String data)
			{
				data = data.toLowerCase().replace("r", "");
				
				return Util.parseInt(data) & 0xf;
			}
			
			public static int POP(String data)
			{
				data = data.toLowerCase().replace("r", "");
				
				return Util.parseInt(data) & 0xf;
			}
			
			public static int SEC(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= Util.parseInt(data.split(" ")[0]) << 16;
				toReturn |= Util.parseInt(data.split(" ")[1]) << 12;
				toReturn |= data.split(" ")[2].startsWith("#") ? Util.compressInt(Util.parseInt(data.split(" ")[2]), 12) | (1 << 20) : Util.parseInt(data.split(" ")[2]);
				
				return toReturn;
			}
			
			public static int QNTM(String data)
			{
				data = data.toLowerCase().replace("r", "");
				
				return Util.parseInt(data) & 0xf;
			}
			
			public static int GQTM(String data)
			{
				data = data.toLowerCase().replace("r", "");
				
				return Util.parseInt(data) & 0xf;
			}
			
			public static int B(String data)
			{
				return Util.compressInt(Util.parseInt(data), 21) & 0x1fffff;
			}
			
			public static int BL(String data)
			{
				return Util.compressInt(Util.parseInt(data), 21) & 0x1fffff;
			}
			
			public static int BX(String data)
			{
				return Util.compressInt(Util.parseInt(data.split(" ")[0]), 17) | ((Util.parseInt(data.split(" ")[1]) & 0xf) << 17);
			}
			
			public static int STR(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= Util.parseInt(data.split(" ")[0]) << 17;
				toReturn |= Util.parseInt(data.split(" ")[1]) << 13;
				toReturn |= Util.compressInt(Util.parseInt(data.split(" ")[2]), 17);
				
				return toReturn;
			}
			
			public static int LDR(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= Util.parseInt(data.split(" ")[0]) << 17;
				toReturn |= Util.parseInt(data.split(" ")[1]) << 13;
				toReturn |= Util.compressInt(Util.parseInt(data.split(" ")[2]), 13);
				
				return toReturn;
			}
			
			public static int STRB(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= Util.parseInt(data.split(" ")[0]) << 17;
				toReturn |= Util.parseInt(data.split(" ")[1]) << 13;
				toReturn |= Util.compressInt(Util.parseInt(data.split(" ")[2]), 17);
				
				return toReturn;
			}
			
			public static int LDRB(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= Util.parseInt(data.split(" ")[0]) << 17;
				toReturn |= Util.parseInt(data.split(" ")[1]) << 13;
				toReturn |= Util.compressInt(Util.parseInt(data.split(" ")[2]), 17);
				
				return toReturn;
			}
			
			public static int SWP(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= Util.parseInt(data.split(" ")[0]) << 17;
				toReturn |= Util.parseInt(data.split(" ")[1]) << 13;
				toReturn |= Util.compressInt(Util.parseInt(data.split(" ")[2]), 17);
				
				return toReturn;
			}
			
			public static int SWPB(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= Util.parseInt(data.split(" ")[0]) << 17;
				toReturn |= Util.parseInt(data.split(" ")[1]) << 13;
				toReturn |= Util.compressInt(Util.parseInt(data.split(" ")[2]), 17);
				
				return toReturn;
			}
			
			public static int MUL(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int DIV(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int SVC(String data)
			{
				data.toLowerCase().replace("#", "");
				return Util.compressInt(Util.parseInt(data), 21);
			}
			
			public static int CLR(String data)
			{
				return 0;
			}
			
			public static int DRAW(String data)
			{
				return 0;
			}
			
			public static int FILL(String data)
			{
				return 0;
			}
			
			public static int RECT(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return Util.parseInt(data.split(" ")[0]) | (Util.parseInt(data.split(" ")[1]) << 4) | (Util.parseInt(data.split(" ")[2]) << 8) | (Integer.parseInt(data.split(" ")[3]) << 12);
			}
			
			public static int OVL(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return Util.parseInt(data.split(" ")[0]) | (Util.parseInt(data.split(" ")[1]) << 4) | (Util.parseInt(data.split(" ")[2]) << 8) | (Integer.parseInt(data.split(" ")[3]) << 12);
			}
			
			public static int COLOR(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return Util.parseInt(data);
			}
			
			public static int GCOLOR(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return Util.parseInt(data);
			}
			
			public static int TEXT(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return Util.parseInt(data.split(" ")[0]) | (Integer.parseInt(data.split(" ")[1]) << 4) | (Integer.parseInt(data.split(" ")[2]) << 8);
			}
			
			public static int MOUSE(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return Util.parseInt(data.split(" ")[0]) | (Util.parseInt(data.split(" ")[1]) << 4);
			}
			
			public static int ROT(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return Util.parseInt(data);
			}
			
			public static int SCR(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return Util.parseInt(data.split(" ")[0]) | (Util.parseInt(data.split(" ")[0]) << 4);
			}
			
			public static int BLK(String data)
			{
				return 0;
			}
			
			public static int UBLK(String data)
			{
				return 0;
			}
			
			public static int EOR(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int SUB(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int RSB(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int ADD(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int TST(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int TEQ(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int CMP(String data)
			{
				String[] strgs = data.split(" ");
				int[] args = {Util.parseInt(strgs[0]), 0, Util.parseInt(strgs[1])};
				
				int toReturn = 0;
				
				toReturn |= (args[0] & 0xf) << 16;
				toReturn |= (args[1] & 0xf) << 12;
				
				if(strgs[1].startsWith("#"))
				{
					toReturn |= Util.compressInt(args[2], 11);
				}
				else
				{
					toReturn |= 1 << 20;
					toReturn |= args[2] & 0xf;
				}
				
				return toReturn & 0x1fffff;
			}
			
			public static int CMN(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int ORR(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int MOV(String data)
			{
				String[] strgs = data.split(" ");
				int[] args = {Util.parseInt(strgs[0]), 0, Util.parseInt(strgs[1])};
				
				int toReturn = 0;
				
				toReturn |= (args[0] & 0xf) << 16;
				toReturn |= (args[1] & 0xf) << 12;
				
				if(strgs[1].startsWith("#"))
				{
					toReturn |= Util.compressInt(args[2], 12);
				}
				else
				{
					toReturn |= 1 << 20;
					toReturn |= args[2] & 0xf;
				}
				
				return toReturn & 0x1fffff;
			}
			
			public static int BIC(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int MVN(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int AND(String data)
			{
				return Util.compactStandardOpcode(data);
			}
			
			public static int MVX(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= Util.parseInt(data.split(" ")[0]) << 8;
				toReturn |= Util.parseInt(data.split(" ")[1]) & 0xf;
				toReturn |= (Util.parseInt(data.split(" ")[2]) & 0xf) << 4;
				
				return toReturn;
			}
			
			public static int SND(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= Util.parseInt(data.split(" ")[2]) << 8;
				toReturn |= Util.parseInt(data.split(" ")[1]) << 4;
				toReturn |= Util.parseInt(data.split(" ")[0]) << 0;
				
				return toReturn;
			}
			
			public static int RCV(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= Util.parseInt(data.split(" ")[0]) << 4;
				toReturn |= Util.parseInt(data.split(" ")[1]) << 0;
				
				return toReturn;
			}
			
			public static int SIZ(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= Util.parseInt(data.split(" ")[0]) << 0;
				
				return toReturn;
			}
			
			public static int DMP(String data)
			{
				return 0;
			}
			
			public static int IP(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= Util.parseInt(data.split(" ")[0]) << 0;
				
				return toReturn;
			}
		}
	}
	
	public static class Util
	{
		public static int compressInt(int value, int numBits)
		{
			int toReturn = 0;
			
			int tmpMask = 0;
			
			for(int loop = 0; loop < numBits; loop++)
				tmpMask |= 0xF << loop;
			
			if(value < 0)
				toReturn |= ((value & tmpMask) ) | (1 << numBits);
			else
				toReturn |= value & ~(1 << numBits);
			
			return toReturn;
		}
		
		public static int expandInt(int value, int numBits)
		{
			int toReturn = 0, tmpMask = 0;
			
			for(int loop = 0; loop < numBits; loop++)
				tmpMask |= 0b1 << loop;
			
			toReturn = value & tmpMask;
			if(((toReturn & (1 << (numBits - 1))) >> (numBits - 1)) == 0b1)
			{
				toReturn |= ~tmpMask;
				toReturn = ~toReturn;
				toReturn += 1;
				toReturn = -toReturn;
			}
			
			return toReturn;
		}
		
		public static int fromBytes(byte[] bytes)
		{
			int toReturn = 0;
			int tmpInt = bytes[0] & 0b1111_1111;
			toReturn |= tmpInt;
			toReturn <<= 8;
			tmpInt = bytes[1] & 0b1111_1111;
			toReturn |= tmpInt;
			toReturn <<= 8;
			tmpInt = bytes[2] & 0b1111_1111;
			toReturn |= tmpInt;
			toReturn <<= 8;
			tmpInt = bytes[3] & 0b1111_1111;
			toReturn |= tmpInt;
			
			return toReturn;
		}
		
		public static byte[] toBytes(int value)
		{
			byte[] toReturn = new byte[4];
			
			toReturn[0] = (byte) ((value & 0b1111_1111_0000_0000_0000_0000_0000_0000) >> 24);
			toReturn[1] = (byte) ((value & 0b1111_1111_0000_0000_0000_0000) >> 16);
			toReturn[2] = (byte) ((value & 0b1111_1111_0000_0000) >> 8);
			toReturn[3] = (byte) ((value & 0b1111_1111));
			
			return toReturn;
		}
		
		public static int[] expandStandardOpcode(int instruction)
		{
			APPLETONx32 proc = getProc();
			int[] toReturn = new int[3];
			
			toReturn[0] = (instruction >> 16) & 0xf;
			toReturn[1] = (instruction >> 12) & 0xf;
			toReturn[2] = (((instruction >> 20) & 1) == 1) ? proc.getRegisterForMode((instruction >> 0) & 0xf) : expandInt(((instruction >> 0) & 0x7ff), 11);
			
			return toReturn;
		}
		
		public static int compactStandardOpcode(String data)
		{
			String[] strgs = data.split(" ");
			int[] args = {parseInt(strgs[0]), parseInt(strgs[1]), parseInt(strgs[2])};
			
			int toReturn = 0;
			
			toReturn |= (args[0] & 0xf) << 16;
			toReturn |= (args[1] & 0xf) << 12;
			
			if(strgs[2].startsWith("#"))
			{
				toReturn |= compressInt(args[2], 12);
			}
			else
			{
				toReturn |= 1 << 20;
				toReturn |= args[2] & 0xf;
			}
			
			return toReturn & 0x1fffff;
		}
		
		public static APPLETONx32 getProc()
		{
			return getEngine(APPLETONx32.class);
		}
		
		public static void printDebug(String message)
		{
			if(Abraxas.getKey("--trace"))
			{
				String instruction = Thread.currentThread().getStackTrace()[2].getMethodName();
				System.out.println("[" + Util.getProc().getName() + " : " + instruction + "] " + message);
			}
		}
		
		public static void forceDebug(String message)
		{
			String instruction = Thread.currentThread().getStackTrace()[2].getMethodName();
			System.out.println("[" + Util.getProc().getName() + " : " + instruction + "] " + message);
		}
		
		public static void setCPSR(boolean N, boolean Z, boolean C, boolean V)
		{
			if(N)
				Util.getProc().setRegisterForMode(16, Util.getProc().getRegisterForMode(16) | (0b1 << 31));
			else
				Util.getProc().setRegisterForMode(16, Util.getProc().getRegisterForMode(16) & ~(0b1 << 31));
			if(Z)
				Util.getProc().setRegisterForMode(16, Util.getProc().getRegisterForMode(16) | (0b1 << 30));
			else
				Util.getProc().setRegisterForMode(16, Util.getProc().getRegisterForMode(16) & ~(0b1 << 30));
			if(C)
				Util.getProc().setRegisterForMode(16, Util.getProc().getRegisterForMode(16) | (0b1 << 29));
			else
				Util.getProc().setRegisterForMode(16, Util.getProc().getRegisterForMode(16) & ~(0b1 << 29));
			if(V)
				Util.getProc().setRegisterForMode(16, Util.getProc().getRegisterForMode(16) | (0b1 << 28));
			else
				Util.getProc().setRegisterForMode(16, Util.getProc().getRegisterForMode(16) & ~(0b1 << 28));
		}
		
		public static int parseInt(String data)
		{
			data = data.toUpperCase().replace("#", "").replace("[", "").replace("]", "").replace("R", "");
			
			if(data.startsWith("0X"))
				return Integer.parseInt(data.replace("0X", ""), 16);
			if(data.startsWith("0B"))
				return Integer.parseInt(data.replace("0B", ""), 2);
			return Integer.parseInt(data);
		}
	}
	
	public APPLETONx32()
	{
		
	}
	
	public APPLETONx32(String biosImage, Integer memoryLength, String[] disks)
	{
		this.memory = new HashMap<Integer, Byte>();
		this.security = new HashMap<Integer, Boolean>();
		this.memSize = memoryLength;
		
		for (int i = 0; i < disks.length; i++)
			try {
				if(new File(FileUtil.baseDir + disks[i]).exists())
					this.disks.add(new RandomAccessFile(FileUtil.baseDir + disks[i], "rw"));
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		
		System.err.println("Openned " + this.disks.size() + " disk" + (this.disks.size() != 1 ? "s" : ""));
		
		InputStream bios = FileUtil.getFile(biosImage);
		ByteArrayOutputStream os = new ByteArrayOutputStream();
		MultiplexOutputStream.writeInputToOutput(bios, os, true);
		this.setMemoryRange(0, os.toByteArray());
		
		System.err.println("Read " + os.size() + " bytes of BIOS data");
	}
	
	public APPLETONx32(String biosImage, Integer memoryLength, String[] disks, String ipAddress)
	{
		this.memory = new HashMap<Integer, Byte>();
		this.security = new HashMap<Integer, Boolean>();
		this.memSize = memoryLength;
		
		for (int i = 0; i < disks.length; i++)
			try {
				if(new File(FileUtil.baseDir + disks[i]).exists())
					this.disks.add(new RandomAccessFile(FileUtil.baseDir + disks[i], "rw"));
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		
		System.err.println("Openned " + this.disks.size() + " disk" + (this.disks.size() != 1 ? "s" : ""));
		
		InputStream bios = FileUtil.getFile(biosImage);
		ByteArrayOutputStream os = new ByteArrayOutputStream();
		MultiplexOutputStream.writeInputToOutput(bios, os, true);
		this.setMemoryRange(0, os.toByteArray());
		
		System.err.println("Read " + os.size() + " bytes of BIOS data");
		
		System.err.println("Constructed with address " + (this.address = ipAddress));
	}
	
	public void setMemory(int addr, byte toSet)
	{
		if(addr <= memSize - 1 && addr >= 0)
			if(toSet != 0){
				memory.put(addr, toSet);}
			else if(memory.containsKey(addr))
					memory.remove(addr);
		if(memory.size() > memSize)
			throw new RuntimeException("Memory exceeded maximum size! Limited to " + memSize + ", managed " + memory.size());
	}
	
	public byte getMemory(int addr)
	{
		if(memory.size() > memSize)
			throw new RuntimeException("Memory exceeded maximum size! Limited to " + memSize + ", managed " + memory.size());
		return memory.containsKey(addr) ? memory.get(addr) : 0;
	}
	
	public byte[] getMemoryRange(int start, int length)
	{
		byte[] toReturn = new byte[length];
		
		for (int i = 0; i < toReturn.length; i++)
			toReturn[i] = getMemory(start + i);
		
		return toReturn;
	}
	
	public void setMemoryRange(int start, byte[] data)
	{
		for(byte toSet : data)
			this.setMemory(start++, toSet);
	}
	
	public boolean getSecurity(int addr)
	{
		if(security.size() > memSize)
			throw new RuntimeException("Securty exceeded maximum size! Limited to " + memSize + ", managed " + security.size());
		return security.containsKey(addr) ? security.get(addr) : false;
	}
	
	public void setSecurity(int addr, boolean secure)
	{
		if(addr <= memSize - 1 && addr >= 0)
			if(secure){
				security.put(addr, true);}
			else if(memory.containsKey(addr))
					memory.remove(addr);
		if(security.size() > memSize)
			throw new RuntimeException("Securty exceeded maximum size! Limited to " + memSize + ", managed " + security.size());
	}
	
	public void setSecurityRange(int start, boolean...data)
	{
		for(boolean toSet : data)
			this.setSecurity(start++, toSet);
	}
	
	public void setSecurityRange(int start, int length, boolean data)
	{
		for (int i = 0; i < length; i++)
			this.setSecurity(start++, data);
	}
	
	public int getRegisterForMode(int register)
	{
		return this.currentMode.getRegister(this, register, registers);
	}
	
	public void setRegisterForMode(int register, int value)
	{
		this.currentMode.setRegister(this, register, value, registers);
	}
	
	public void setSuspended(boolean toSet)
	{
		if(toSet)
			this.shouldSuspend = true;
		else
			synchronized (this)
			{
				this.notify();
			}
	}
	
	public boolean isSuspended()
	{
		return shouldSuspend;
	}
	
	public boolean conditionCode(int instruction)
	{
		int cpsr = this.getRegisterForMode(16);
		boolean[] decode = new boolean[]{(cpsr >> 31 & 0b1) == 1, (cpsr >> 30 & 0b1) == 1, (cpsr >> 29 & 0b1) == 1, (cpsr >> 28 & 0b1) == 1};
		
		byte cond = (byte) (instruction >> 28 & 0xF);
		
		final int N = 0, Z = 1, C = 2, V = 3;
		
		switch(cond)
		{
		case 1: //EQ
			return decode[Z];
		case 2: //NE
			return !decode[Z];
		case 3: //CS
			return decode[C];
		case 4: //CC
			return !decode[C];
		case 5: //MI
			return decode[N];
		case 6: //PL
			return !decode[N];
		case 7: //VS
			return decode[V];
		case 8: //VC
			return !decode[V];
		case 9: //HI
			return decode[C] && !decode[Z];
		case 10: //LS
			return !decode[C] || decode[Z];
		case 11: //GE
			return decode[N] == decode[V];
		case 12: //LT
			return decode[N] != decode[V];
		case 13: //GT
			return !decode[Z] && (decode[N] == decode[V]);
		case 14: //LE
			return decode[Z] || (decode[N] != decode[V]);
		case 15: //AL - ignored
			return true;
		default:
			return false;
		}
	}
	
	public String nameConditionCode(int instruction)
	{
		byte cond = (byte) (instruction >> 28 & 0xF);
		
		if(cond > 0)
			return Instructions.cond[cond - 1];
		else
			return "AL";
	}
	
	public int conditionCode(String name)
	{
		switch(name.toUpperCase())
		{
		case "EQ":
			return 1;
		case "NE":
			return 2;
		case "CS":
			return 3;
		case "CC":
			return 4;
		case "MI":
			return 5;
		case "PL":
			return 6;
		case "VS":
			return 7;
		case "VC":
			return 8;
		case "HI":
			return 9;
		case "LS":
			return 10;
		case "GE":
			return 11;
		case "LT":
			return 12;
		case "GT":
			return 13;
		case "LE":
			return 14;
		case "":
		case "AL":
			return 15;
		default:
			return 0;
		}
	}
	
	public Method getInstruction(int code)
	{
		Method toReturn = null;

		code = (code >> 21) & 0x7f;
		
		for(String proc : Instructions.proc)
		{
			int tmpCode = Integer.parseInt(proc.split("-")[1].replace("_", ""), 2);
			proc = proc.split("-")[0];
			
			if(tmpCode == code)
				try {
					toReturn = Instructions.Execution.class.getDeclaredMethod(proc, int.class);
					break;
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
		}
		
		return toReturn;
	}
	
	public int getASM(String data)
	{
		Method toReturn = null;
		
		for(String proc : Instructions.proc)
		{
			if(proc.split("-")[0].equals(data.split(" ")[0]))
				try {
					toReturn = Instructions.Assembly.class.getDeclaredMethod(data.split(" ")[0], String.class);
					break;
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
		}
		
		try {
			return (int) toReturn.invoke(null, data.split(" ")[0].equals(data) ? "" : data.substring(data.split(" ")[0].length() + 1));
		} catch (IllegalAccessException | IllegalArgumentException
				| InvocationTargetException e) {
			e.printStackTrace();
			return 0;
		}
	}
	
	public void start(String threadName)
	{
		if(executionThread == null)
			return;
		
		if(executionThread.isAlive())
			return;
		
		executionThread.setName(threadName);
		executionThread.start();
	}
	
	public void execute()
	{
		if(shouldSuspend)
		{
			synchronized (this) {
				try {
					this.wait();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			
			shouldSuspend = false;
		}
		
		if(intID != -1 && this.currentMode != Mode.INTERRUPT && this.currentMode != Mode.ABORT)
		{
			switch(intID)
			{
			case 0:
				this.setRegisterForMode(14, r15);
				Mode.ABORT.setRegister(this, 0, (Integer) intArgs[0], registers);
				Mode.ABORT.setRegister(this, 14, r15, registers);
				this.setRegisterForMode(15, Util.fromBytes(this.getMemoryRange(this.getRegisterForMode(12) + (intID * 4), 4)));
				this.currentMode = Mode.ABORT;
				break;
			case 1:
				this.setRegisterForMode(14, r15);
				Mode.INTERRUPT.setRegister(this, 0, (Integer) intArgs[0], registers);
				Mode.INTERRUPT.setRegister(this, 1, (Integer) intArgs[1], registers);
				Mode.INTERRUPT.setRegister(this, 14, r15, registers);
				this.setRegisterForMode(15, Util.fromBytes(this.getMemoryRange(this.getRegisterForMode(12) + (intID * 4), 4)));
				this.currentMode = Mode.INTERRUPT;
				break;
			default:
				this.setRegisterForMode(14, r15);
				Mode.INTERRUPT.setRegister(this, 14, r15, registers);
				this.setRegisterForMode(15, Util.fromBytes(this.getMemoryRange(this.getRegisterForMode(12) + (intID * 4), 4)));
				this.currentMode = Mode.INTERRUPT;
				break;
			}
			intID = -1;
		}
		
		int instruction = Util.fromBytes(this.getMemoryRange(this.getRegisterForMode(15), 4));
		
		if(instruction == 0)
		{
			Util.printDebug("NULL opcode : r15 = " + r15);
			this.interrupt(0, true, 0);
			return;
		}
		
		int cpsr = this.getRegisterForMode(16);
		boolean[] decode = new boolean[]{(cpsr >> 31 & 0b1) == 1, (cpsr >> 30 & 0b1) == 1, (cpsr >> 29 & 0b1) == 1, (cpsr >> 28 & 0b1) == 1};
		if(getInstruction(instruction) != null )
			Util.printDebug("Now attempting " + getInstruction(instruction).getName() + "_" + nameConditionCode(instruction) + " : " + Arrays.toString(decode) + " : " + Integer.toBinaryString(instruction));
		else
		{
			Util.printDebug("Attempting to execute " + Integer.toBinaryString(instruction) + " proved fruitless; it isn't real");
			this.interrupt(0, true, 1);
			return;
		}
		
		if(conditionCode(instruction))
			try {
				Method struct = getInstruction(instruction);
				struct.invoke(null, instruction);
			} catch (IllegalAccessException | IllegalArgumentException
					| InvocationTargetException | NullPointerException e) {
				Util.printDebug("Encountered unreadable data: " + Integer.toBinaryString(instruction));
				e.printStackTrace();
			}
		
		this.setRegisterForMode(15, this.getRegisterForMode(15) + 4);
	}

	public void interrupt(int id, boolean abort, Number... args)
	{
		this.intArgs = args;
		this.intID = id;
	}

	public void terminate()
	{
		this.shouldTerminate = true;
	}
	
	public boolean isTerminated()
	{
		return this.shouldTerminate;
	}

	public boolean checkSanity()
	{
		Instructions.init();
		
		boolean isSane = Instructions.Execution.class.getDeclaredMethods().length == Instructions.Assembly.class.getDeclaredMethods().length;
		
		for(String item : Instructions.proc)
			try {
				Instructions.Execution.class.getDeclaredMethod(item.split("-")[0], int.class);
				Instructions.Assembly.class.getDeclaredMethod(item.split("-")[0], String.class);
			} catch (NoSuchMethodException | SecurityException e) {
				isSane = false;
				System.err.println(item.split("-")[0] + " failed the sanity check in " + (e.getMessage().contains("Assembly") ? "assembly" : "execution"));
			}
		System.err.println((isSane ? "Passed" : "Failed") + " the sanity check");
		
		return isSane;
	}
	
	public int assembleLine(String line)
	{
		int finalCode = 0;
		line = line.replace(",", "").replace("\t", "").replace("_", "");
		String[] comp = line.split(" ");
		
		if(Instructions.proc == null)
			this.checkSanity();
		
		for(String proc : Instructions.proc)
		{
			if(proc.split("-")[0].equals(comp[0]))
			{
				finalCode = 15 << 28;
				finalCode |= Integer.parseInt(proc.split("-")[1].replace("_", ""), 2) << 21;
				finalCode |= getASM(line);
				break;
			}else
				for(String cond : Instructions.cond)
					if(comp[0].equals(proc.split("-")[0] + cond))
					{
						finalCode = conditionCode(cond) << 28;
						finalCode |= Integer.parseInt(proc.split("-")[1].replace("_", ""), 2) << 21;
						finalCode |= getASM(line.replace(cond, ""));
					}
		}
		
		return finalCode;
	}
	
	public int generateCode(String src, OutputStream os) throws IOException
	{
		Scanner in = new Scanner(FileUtil.getFile(src));
		
		HashMap<String, Integer> labelMap = new HashMap<String, Integer>();
		HashMap<String, String> constMap = new HashMap<String, String>();
		
		int off = 0;
		
		while(in.hasNextLine())
		{
			String asmLine = in.nextLine().toUpperCase().trim().replace("\t", "");
			
			if(asmLine.startsWith("$ ") && asmLine.endsWith(" $"))
			{
				int pad = Integer.parseInt(asmLine.replace("$ ", "").replace(" $", ""));
				
				off = off <= pad ? pad : off;
				continue;
			}
			
			if(asmLine.startsWith("# ") && asmLine.endsWith(" #"))
			{
				asmLine = asmLine.replace("# ", "").replace(" #", "");
				
				if(asmLine.toLowerCase().endsWith(".asm"))
					off += generateCode(new File(src).getParent() + "/" + asmLine, (OutputStream)null);//assemble(new File(toAssemble.getAbsoluteFile().getParent() + "/" + asmLine), (OutputStream)null);
				else if(asmLine.toLowerCase().endsWith(".bmp"))
					off += GraphicsUtil.countBitmapBytes(asmLine) / 4 + (GraphicsUtil.countBitmapBytes(asmLine) % 4 == 0 ? 0 : 1);
				else
				{
					InputStream is = FileUtil.getFile(asmLine);
					int tmpOff = 0;
					while(is.available() > 0)
					{
						is.read();
						tmpOff++;
					}
					off += tmpOff / 4 + (tmpOff % 4 == 0 ? 0 : 1);
					is.close();
						
				}
				continue;
			}
			
			if(asmLine.startsWith("\"") && asmLine.endsWith("\""))
			{
				asmLine = asmLine.substring(1, asmLine.length() - 1);
				off += asmLine.getBytes().length / 4 + (asmLine.getBytes().length % 4 == 0 ? 0 : 1);
				continue;
			}
			
			if(asmLine.startsWith("0X ") && asmLine.endsWith(" X0"))
			{
				asmLine = asmLine.replace("_", "").replace("0X ", "").replace(" X0", "");
				off += asmLine.split(" ").length / 4 + (asmLine.split(" ").length % 4 == 0 ? 0 : 1);
				continue;
			}
			
			if(asmLine.endsWith(":") && asmLine.startsWith(":"))
			{
				labelMap.put(asmLine.replace(":", ""), off);
				System.err.println("Attatched label " + asmLine + " to address " + off);
			}
			
			if(asmLine.endsWith("?") && asmLine.startsWith("?"))
				constMap.put(asmLine.replace(" ", "").replace("?", "").split("=")[0], asmLine.replace(" ", "").replace("?", "").split("=")[1]);
			
			if(asmLine.startsWith(";") || asmLine.isEmpty() || (asmLine.endsWith(":") & asmLine.startsWith(":")) || (asmLine.endsWith("?") && asmLine.startsWith("?")))
				continue;
			
			off++;
		}
		
		in.close();
		in = new Scanner(FileUtil.getFile(src));
		off = 0;
		
		while(in.hasNextLine())
		{
			String asmLine = in.nextLine().trim().replace("\t", "");
			
			if(asmLine.startsWith("$ ") && asmLine.endsWith(" $"))
			{
				int pad = Integer.parseInt(asmLine.replace("$ ", "").replace(" $", ""));
				
				int size = pad - off;
				
				if(off <= pad)
				{
					off = pad;
					if(os != null)
						os.write(new byte[size * 4]);
					System.err.println("Padded up to address " + pad * 4 + " : " + size * 4 + " bytes");
				}
				
				continue;
			}
			
			if(asmLine.startsWith("# ") && asmLine.endsWith(" #"))
			{
				asmLine = asmLine.replace("# ", "").replace(" #", "");
				
				if(asmLine.toLowerCase().endsWith(".asm"))
				{
					System.err.println("Assembled \"" + asmLine + "\" within");
					off += generateCode(new File(src).getParent() + "/" + asmLine, os);//assemble(new File(toAssemble.getAbsoluteFile().getParent() + "/" + asmLine), (OutputStream)null);
				}
				else if(asmLine.toLowerCase().endsWith(".bmp"))
				{
					System.err.println("Compiled bitmap \"" + asmLine + "\" within");
					off += GraphicsUtil.countBitmapBytes(asmLine) / 4 + (GraphicsUtil.countBitmapBytes(asmLine) % 4 == 0 ? 0 : 1);
					GraphicsUtil.genBitmap(asmLine, os);
				}
				else
				{
					System.err.println("Added file \"" + asmLine + "\" within");
					InputStream is = FileUtil.getFile(asmLine);
					int tmpOff = 0;
					while(is.available() > 0)
					{
						os.write(is.read());
						tmpOff++;
					}
					off += tmpOff / 4 + (tmpOff % 4 == 0 ? 0 : 1);
					if(os != null)
						os.write(new byte[4 - (tmpOff % 4)]);
					is.close();
						
				}
				continue;
			}
			
			if(asmLine.startsWith("\"") && asmLine.endsWith("\""))
			{
				asmLine = asmLine.substring(1, asmLine.length() - 1);
				System.err.println("Encoded string \"" + asmLine + "\", length of " + asmLine.getBytes().length + " bytes, overflow of " + ( 4 - (asmLine.getBytes().length % 4)) + " bytes");
				if(os != null)
					os.write(asmLine.getBytes());
				off += asmLine.getBytes().length / 4 + (4 - (asmLine.getBytes().length % 4) == 0 ? 0 : 1);
				
				if(asmLine.getBytes().length % 4 > 0 && os != null)
					os.write(new byte[4 - (asmLine.getBytes().length % 4)]);
				continue;
			}
			
			asmLine = asmLine.toUpperCase().replace("_", "");
			
			if(asmLine.startsWith("0X ") && asmLine.endsWith(" X0"))
			{
				int tmpOff = 0;
				
				asmLine = asmLine.replace("_", "").replace("0X ", "").replace(" X0", "");
				
				for(String unit : asmLine.split(" "))
				{
					if(os != null)
						os.write(Integer.parseInt(unit, 16));
					tmpOff++;
				}
				
				System.err.println("Encoded data 0x " + asmLine + " x0, length of " + tmpOff + " bytes, overflow of " + (4 - (tmpOff % 4)) + " bytes");
				
				if(tmpOff % 4 > 0 && os != null)
					os.write(new byte[4 - (tmpOff % 4)]);
				
				off += tmpOff / 4 + (tmpOff % 4 > 0 ? 1 : 0);
				continue;
			}
			
			if(asmLine.startsWith(";") || asmLine.isEmpty() || (asmLine.endsWith(":") & asmLine.startsWith(":")) || (asmLine.endsWith("?") && asmLine.startsWith("?")))
				continue;
			
			
			for(String label : labelMap.keySet())
			{
				if(asmLine.contains(":" + label + ":"))
				{
					System.out.println("Replaced instance of label " + label);
					asmLine = asmLine.replace(":" + label + ":", ""+ (labelMap.get(label) * 4 - off * 4));
				}
			}
			
			for(String constVal : constMap.keySet())
			{
				if(asmLine.contains(constVal))
				{
					System.out.println("Replaced instance of constant " + constVal);
					asmLine = asmLine.replace(constVal, constMap.get(constVal));
				}
			}
			
			if(os != null)
				os.write(Util.toBytes(assembleLine(asmLine)));
			
			off++;
		}
		
		in.close();
		System.out.println("Assembled " + src + " to APPLETONx32 code inline");
		
		return off;
	}
	
	public void generateCode(String src, String output) throws IOException
	{
		Scanner in = new Scanner(FileUtil.getFile(src));
		FileOutputStream os = new FileOutputStream(new File(FileUtil.baseDir + output));
		
		HashMap<String, Integer> labelMap = new HashMap<String, Integer>();
		HashMap<String, String> constMap = new HashMap<String, String>();
		
		int off = 0;
		
		while(in.hasNextLine())
		{
			String asmLine = in.nextLine().toUpperCase().trim().replace("\t", "");
			
			if(asmLine.startsWith("$ ") && asmLine.endsWith(" $"))
			{
				int pad = Integer.parseInt(asmLine.replace("$ ", "").replace(" $", ""));
				
				off = off <= pad ? pad : off;
				continue;
			}
			
			if(asmLine.startsWith("# ") && asmLine.endsWith(" #"))
			{
				asmLine = asmLine.replace("# ", "").replace(" #", "");
				
				if(asmLine.toLowerCase().endsWith(".asm"))
					off += generateCode(new File(src).getParent() + "/" + asmLine, (OutputStream)null);//assemble(new File(toAssemble.getAbsoluteFile().getParent() + "/" + asmLine), (OutputStream)null);
				else if(asmLine.toLowerCase().endsWith(".bmp"))
					off += GraphicsUtil.countBitmapBytes(asmLine) / 4 + (GraphicsUtil.countBitmapBytes(asmLine) % 4 == 0 ? 0 : 1);
				else
				{
					InputStream is = FileUtil.getFile(asmLine);
					int tmpOff = 0;
					while(is.available() > 0)
					{
						is.read();
						tmpOff++;
					}
					off += tmpOff / 4 + (tmpOff % 4 == 0 ? 0 : 1);
					is.close();
						
				}
				continue;
			}
			
			if(asmLine.startsWith("\"") && asmLine.endsWith("\""))
			{
				asmLine = asmLine.substring(1, asmLine.length() - 1);
				off += asmLine.getBytes().length / 4 + (asmLine.getBytes().length % 4 == 0 ? 0 : 1);
				continue;
			}
			
			if(asmLine.startsWith("0X ") && asmLine.endsWith(" X0"))
			{
				asmLine = asmLine.replace("_", "").replace("0X ", "").replace(" X0", "");
				off += asmLine.split(" ").length / 4 + (asmLine.split(" ").length % 4 == 0 ? 0 : 1);
				continue;
			}
			
			if(asmLine.endsWith(":") && asmLine.startsWith(":"))
			{
				labelMap.put(asmLine.replace(":", ""), off);
				System.err.println("Attatched label " + asmLine + " to address " + off);
			}
			
			if(asmLine.endsWith("?") && asmLine.startsWith("?"))
				constMap.put(asmLine.replace(" ", "").replace("?", "").split("=")[0], asmLine.replace(" ", "").replace("?", "").split("=")[1]);
			
			if(asmLine.startsWith(";") || asmLine.isEmpty() || (asmLine.endsWith(":") & asmLine.startsWith(":")) || (asmLine.endsWith("?") && asmLine.startsWith("?")))
				continue;
			
			off++;
		}
		
		in.close();
		in = new Scanner(FileUtil.getFile(src));
		off = 0;
		
		while(in.hasNextLine())
		{
			String asmLine = in.nextLine().trim().replace("\t", "");
			
			if(asmLine.startsWith("$ ") && asmLine.endsWith(" $"))
			{
				int pad = Integer.parseInt(asmLine.replace("$ ", "").replace(" $", ""));
				
				int size = pad - off;
				
				if(off <= pad)
				{
					off = pad;
					os.write(new byte[size * 4]);
					System.err.println("Padded up to address " + pad * 4 + " : " + size * 4 + " bytes");
				}
				
				continue;
			}
			
			if(asmLine.startsWith("# ") && asmLine.endsWith(" #"))
			{
				asmLine = asmLine.replace("# ", "").replace(" #", "");
				
				if(asmLine.toLowerCase().endsWith(".asm"))
				{
					System.err.println("Assembled \"" + asmLine + "\" within");
					off += generateCode(new File(src).getParent() + "/" + asmLine, os);//assemble(new File(toAssemble.getAbsoluteFile().getParent() + "/" + asmLine), (OutputStream)null);
				}
				else if(asmLine.toLowerCase().endsWith(".bmp"))
				{
					System.err.println("Compiled bitmap \"" + asmLine + "\" within");
					off += GraphicsUtil.countBitmapBytes(asmLine) / 4 + (GraphicsUtil.countBitmapBytes(asmLine) % 4 == 0 ? 0 : 1);
					GraphicsUtil.genBitmap(asmLine, os);
				}
				else
				{
					System.err.println("Added file \"" + asmLine + "\" within");
					InputStream is = FileUtil.getFile(asmLine);
					int tmpOff = 0;
					while(is.available() > 0)
					{
						os.write(is.read());
						tmpOff++;
					}
					off += tmpOff / 4 + (tmpOff % 4 == 0 ? 0 : 1);
					os.write(new byte[4 - (tmpOff % 4)]);
					is.close();
						
				}
				continue;
			}
			
			if(asmLine.startsWith("\"") && asmLine.endsWith("\""))
			{
				asmLine = asmLine.substring(1, asmLine.length() - 1);
				System.err.println("Encoded string \"" + asmLine + "\", length of " + asmLine.getBytes().length + " bytes, overflow of " + ( 4 - (asmLine.getBytes().length % 4)) + " bytes");
				os.write(asmLine.getBytes());
				off += asmLine.getBytes().length / 4 + (4 - (asmLine.getBytes().length % 4) == 0 ? 0 : 1);
				
				if(asmLine.getBytes().length % 4 > 0)
					os.write(new byte[4 - (asmLine.getBytes().length % 4)]);
				continue;
			}
			
			asmLine = asmLine.toUpperCase().replace("_", "");
			
			if(asmLine.startsWith("0X ") && asmLine.endsWith(" X0"))
			{
				int tmpOff = 0;
				
				asmLine = asmLine.replace("_", "").replace("0X ", "").replace(" X0", "");
				
				for(String unit : asmLine.split(" "))
				{
					os.write(Integer.parseInt(unit, 16));
					tmpOff++;
				}
				
				System.err.println("Encoded data 0x " + asmLine + " x0, length of " + tmpOff + " bytes, overflow of " + (4 - (tmpOff % 4)) + " bytes");
				
				if(tmpOff % 4 > 0)
					os.write(new byte[4 - (tmpOff % 4)]);
				
				off += tmpOff / 4 + (tmpOff % 4 > 0 ? 1 : 0);
				continue;
			}
			
			if(asmLine.startsWith(";") || asmLine.isEmpty() || (asmLine.endsWith(":") & asmLine.startsWith(":")) || (asmLine.endsWith("?") && asmLine.startsWith("?")))
				continue;
			
			
			for(String label : labelMap.keySet())
			{
				if(asmLine.contains(":" + label + ":"))
				{
					System.out.println("Replaced instance of label " + label);
					asmLine = asmLine.replace(":" + label + ":", ""+ (labelMap.get(label) * 4 - off * 4));
				}
			}
			
			for(String constVal : constMap.keySet())
			{
				if(asmLine.contains(constVal))
				{
					System.out.println("Replaced instance of constant " + constVal);
					asmLine = asmLine.replace(constVal, constMap.get(constVal));
				}
			}
			
			os.write(Util.toBytes(assembleLine(asmLine)));
			
			off++;
		}
		
		in.close();
		os.close();
		System.out.println("Assembled " + src + " to APPLETONx32 code");
	}
}
