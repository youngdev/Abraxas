package net.lotrek.zero.engine;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.concurrent.LinkedBlockingQueue;

import net.lotrek.zero.network.NetworkCore;

public abstract class Engine
{
	private static HashMap<String, Engine> threadPool = new HashMap<String, Engine>();
	private static Class<? extends Engine> globalEngine;
	private static Engine playerEngine;
	
	private LinkedBlockingQueue<Byte> netQueue = new LinkedBlockingQueue<>();
	
	public static Engine createGlobalEngine(Object...args)
	{
		Class<?>[] constructor = new Class<?>[args.length];
		for (int i = 0; i < args.length; i++)
			constructor[i] = args[i].getClass();
		
		try {
			return globalEngine.getConstructor(constructor).newInstance(args);
		} catch (InstantiationException | IllegalAccessException
				| IllegalArgumentException | InvocationTargetException
				| NoSuchMethodException | SecurityException e) {
			e.printStackTrace();
			return null;
		}
	}
	
	public static void setGlobalEngine(Engine newGlobal)
	{
		globalEngine = newGlobal.getClass();
	}
	
	public static void setGlobalEngine(Class<? extends Engine> newGlobal)
	{
		globalEngine = newGlobal;
	}
	
	public static Engine getEngine()
	{
		if(threadPool.containsKey(Thread.currentThread().getName()))
			return threadPool.get(Thread.currentThread().getName());
		else
			throw new RuntimeException("Thread [\"" + Thread.currentThread().getName() + "\", " + Thread.currentThread().getId() + "] does not hold an engine");
	}
	
	public static <T> T getEngine(Class<T> type)
	{
		if(threadPool.containsKey(Thread.currentThread().getName()))
			return type.cast(threadPool.get(Thread.currentThread().getName()));
		else
			throw new RuntimeException("Thread [\"" + Thread.currentThread().getName() + "\", " + Thread.currentThread().getId() + "] does not hold an engine");
	}
	
	public static Engine getEngine(String name)
	{
		if(threadPool.containsKey(name))
			return threadPool.get(name);
		else
			throw new RuntimeException("Thread \"" + name + "\" does not hold an engine");
	}
	
	public static <T> T getEngine(String name, Class<T> type)
	{
		if(threadPool.containsKey(name))
			return type.cast(threadPool.get(name));
		else
			throw new RuntimeException("Thread \"" + name + "\" does not hold an engine");
	}
	
	public static void terminateAll()
	{
		for(Engine eng : threadPool.values())
			eng.terminate();
		playerEngine = null;
	}
	
	public static void suspendAll(boolean toSet)
	{
		for(Engine eng : threadPool.values())
			eng.setSuspended(toSet);
	}
	
	public static Engine getPlayer()
	{
		return playerEngine;
	}
	
	public static void setPlayer(Engine player)
	{
		playerEngine = player;
	}
	
	public static boolean isPlayer()
	{
		return getEngine() == playerEngine;
	}
	
	protected final void registerEngine(String address)
	{
		threadPool.put(Thread.currentThread().getName(), this);
		if(!isPlayer() && address != null)
			NetworkCore.setAddress(NetworkCore.getAddress(address));
		else if(address == null && !isPlayer())
			NetworkCore.assignAddress();
		else
			NetworkCore.setAddress(NetworkCore.getAddress(NetworkCore.getRemoteAddress()));
	}
	
	protected final void unregisterEngine()
	{
		threadPool.remove(this);
	}
	
	protected final String getName()
	{
		return Thread.currentThread().getName();
	}
	
	public final void pushNetworkData(byte[] data)
	{
		for(byte bit : data)
			this.netQueue.add(bit);
	}
	
	protected final byte[] popNetworkData(int length)
	{
		byte[] b = new byte[length];
		
		for (int i = 0; i < b.length; i++)
			if(!this.netQueue.isEmpty())
				b[i] = this.netQueue.poll();
		
		return b;
	}
	
	protected final int networkBufferSize()
	{
		return this.netQueue.size();
	}
	
	protected final void clearNetworkBuffer()
	{
		this.netQueue.clear();
	}
	
	protected final void sendNetworkData(byte[] toSend, int address)
	{
		NetworkCore.sendData(address, toSend);
	}
	
	protected final int getAddress()
	{
		return NetworkCore.getAddress();
	}
	
	public abstract void start(String threadName);
	
	public abstract void interrupt(int id, boolean abort, Number...args);
	
	public abstract void terminate();
	
	public abstract boolean isTerminated();
	
	public abstract boolean checkSanity();
	
	public abstract void setSuspended(boolean toSet);
	
	public abstract boolean isSuspended();
	
	public abstract void generateCode(String src, String output) throws IOException;
}
