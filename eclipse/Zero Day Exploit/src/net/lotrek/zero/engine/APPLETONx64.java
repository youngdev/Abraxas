package net.lotrek.zero.engine;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;

import org.lwjgl.input.Mouse;
import org.newdawn.slick.Color;
import org.newdawn.slick.Graphics;

import net.lotrek.zero.Abraxas;
import net.lotrek.zero.graphics.GLComplex;
import net.lotrek.zero.graphics.GraphicsUtil;
import net.lotrek.zero.graphics.RenderAction;
import net.lotrek.zero.network.NetworkCore;
import net.lotrek.zero.tools.FileUtil;
import net.lotrek.zero.tools.GameUtil;
import net.lotrek.zero.tools.MouseUtil;
import net.lotrek.zero.tools.MultiplexOutputStream;

public final class APPLETONx64 extends Engine
{
	private HashMap<Integer, Byte> memory;
	private HashMap<Integer, Boolean> security;
	private int memSize;
	private volatile boolean shouldTerminate, shouldSuspend;
	private long[][] registers = new long[5][17];
	private float[][] floatRegisters = new float[5][5];
	private Mode currentMode = Mode.SUPERVISOR;
	private ArrayList<RandomAccessFile> disks = new ArrayList<RandomAccessFile>();
	private int quantumLength, quantumCount, intID = -1;
	private long r15 = 0;
	private Number[] intArgs;
	private String address;
	private Thread executionThread = new Thread()
	{
		public void run()
		{
			registerEngine(address);
			
			net.lotrek.zero.story.Event.GoalEvent.hasEnded.remove(UtilX32.getProc().getName());
			
			if(isPlayer())
				UtilX32.getProc().setSuspended(true);
			
			while(!shouldTerminate)
			{
				if(quantumLength > 0)
				{
					quantumCount++;
					
					if(quantumCount > quantumLength)
					{
						UtilX32.getProc().interrupt(0, false);
						quantumCount = 0;
					}
				}else
					quantumCount = 0;
				execute();
			}
			
			executionThread = null;
			
			unregisterEngine();
			
			net.lotrek.zero.story.Event.GoalEvent.hasEnded.add(UtilX32.getProc().getName());
		}
	};
	
	public static enum Mode
	{
		SUPERVISOR(0),
		SYSTEM(1),
		USER(2),
		INTERRUPT(3),
		ABORT(4),
		;
		
		public int id;
		
		Mode(int id)
		{
			this.id = id;
		}
		
		public long getRegister(APPLETONx64 proc, int register)
		{
			if(register == 15)
				return proc.r15;
			return proc.registers[id][register];
		}
		
		public void setRegister(APPLETONx64 proc, int register, long value)
		{
			if(register == 15)
			{
				proc.r15 = value;
				return;
			}
			proc.registers[id][register] = value;
		}
		
		public float getFloatRegister(APPLETONx64 proc, int register)
		{
			return proc.floatRegisters[id][register];
		}
		
		public void setFloatRegister(APPLETONx64 proc, int register, float value)
		{
			proc.floatRegisters[id][register] = value;
		}
		
		public static Mode getModeForID(int id)
		{
			for(Mode mode : Mode.values())
				if(mode.id == id)
					return mode;
			return UtilX32.getProc().currentMode;
		}
	}
	
	public static class Instructions
	{
		public static ArrayList<String> proc32, proc64;
		public static String[] cond = {"EQ",
			"NE",
			"CS",
			"CC",
			"MI",
			"PL",
			"VS",
			"VC",
			"HI",
			"LS",
			"GE",
			"LT",
			"GT",
			"LE",
			"AL"};
		
		public static void init()
		{
			if(proc32 == null)
			{
				proc32 = new ArrayList<String>();
				
				Scanner procReader = new Scanner(FileUtil.getFile("res.bin/PROCx32"));
				
				while(procReader.hasNextLine())
					proc32.add(procReader.nextLine());
				
				procReader.close();
			}
			
			if(proc64 == null)
			{
				proc64 = new ArrayList<String>();
				
				Scanner procReader = new Scanner(FileUtil.getFile("res.bin/PROCx64"));
				
				while(procReader.hasNextLine())
					proc64.add(procReader.nextLine());
				
				procReader.close();
			}
		}
		
		public static class ExecutionX32
		{
			public static void LSL(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int[] values = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) << values[2]);
				UtilX32.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") << " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void LSR(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int[] values = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) >> values[2]);
				UtilX32.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") >> " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void ASR(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int[] values = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) >>> values[2]);
				UtilX32.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") >>> " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void DSTR(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int memStart = (int) proc.getRegisterForMode((opcode >> 16) & 0xf), diskStart = (int) proc.getRegisterForMode((opcode >> 12) & 0xf), length = (int) proc.getRegisterForMode((opcode >> 8) & 0xf), id = (int) ((((opcode >> 12) & 1) == 0) ? proc.getRegisterForMode((opcode >> 0) & 0xf) : UtilX32.expandInt(((opcode >> 0) & 0xf), 4));
				
				UtilX32.printDebug("memStart: " + memStart + " diskStart: " + diskStart + " length: " + length + " id: " + id);
				
				try {
					byte[] read = proc.getMemoryRange(memStart, length);
					proc.disks.get(id).seek(diskStart);
					proc.disks.get(id).write(read);
				} catch (IOException e) {
				}
			}
			
			public static void DLDR(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int memStart = (int) proc.getRegisterForMode((opcode >> 16) & 0xf), diskStart = (int) proc.getRegisterForMode((opcode >> 12) & 0xf), length = (int) proc.getRegisterForMode((opcode >> 8) & 0xf), id = (int) ((((opcode >> 20) & 1) == 0) ? proc.getRegisterForMode((opcode >> 0) & 0xf) : ((opcode >> 0) & 0xf));
				
				UtilX32.printDebug("memStart: " + memStart + " diskStart: " + diskStart + " length: " + length + " id: " + id);
				
				try {
					byte[] read = new byte[length];
					proc.disks.get(id).seek(diskStart);
					proc.disks.get(id).read(read);
					proc.setMemoryRange(memStart, read);
				} catch (IOException e) {
				}
			}
			
			public static void CTD(int opcode)
			{
				UtilX32.getProc().setRegisterForMode(opcode & 0xf, UtilX32.getProc().disks.size());
				UtilX32.printDebug("r" + (opcode & 0xf) + " <- " + UtilX32.getProc().disks.size());
			}
			
			public static void CPM(int opcode)
			{
				Mode toSet = UtilX32.getProc().currentMode;
				
				for(Mode mode : APPLETONx64.Mode.values())
					if(mode.id == (opcode & 0xf))
					{
						toSet = mode;
						break;
					}
				
				UtilX32.getProc().currentMode = toSet;
				
				UtilX32.printDebug("Set processor mode to " + UtilX32.getProc().currentMode.name());
			}
			
			public static void HLT(int opcode)
			{
				UtilX32.getProc().terminate();
				UtilX32.forceDebug(Engine.getEngine().getName() + " terminated");
			}
			
			public static void PUSH(int opcode)
			{
				int val = (int) UtilX32.getProc().getRegisterForMode(13), off = UtilX32.fromBytes(UtilX32.getProc().getMemoryRange(val, 4));
				
				UtilX32.getProc().setMemoryRange(val + off, UtilX32.toBytes((int) UtilX32.getProc().getRegisterForMode(opcode & 0xf)));
				UtilX32.getProc().setMemoryRange(val, UtilX32.toBytes(off + 4));
				
				UtilX32.printDebug("Pushed " + UtilX32.getProc().getRegisterForMode(opcode & 0xf) + " (r" + (opcode & 0xf) + ") stack 0x" + Integer.toHexString(val) + " in offset " + off);
			}
			
			public static void POP(int opcode)
			{
				int val = (int) UtilX32.getProc().getRegisterForMode(13), off = UtilX32.fromBytes(UtilX32.getProc().getMemoryRange(val, 4)) - 4;
				
				UtilX32.getProc().setRegisterForMode(opcode & 0xf, UtilX32.fromBytes(UtilX32.getProc().getMemoryRange(val + off, 4)));
				UtilX32.getProc().setMemoryRange(val, UtilX32.toBytes(off));
				
				UtilX32.printDebug("Popped " + UtilX32.getProc().getRegisterForMode(opcode & 0xf) + " from stack 0x" + Integer.toHexString(val) + " at offset " + off + " into r" + (opcode & 0xf));
			}
			
			public static void SEC(int opcode)
			{
				int start = (int) UtilX32.getProc().getRegisterForMode((opcode >> 16) & 0xf), length = (int) UtilX32.getProc().getRegisterForMode((opcode >> 12) & 0xf);
				boolean toSecure = ((opcode >> 20) & 1) == 0 ? (opcode & 0xf) == 1 : UtilX32.getProc().getRegisterForMode(opcode & 0xf) == 1;
			
				UtilX32.getProc().setSecurityRange(start, length, toSecure);
				
				UtilX32.printDebug("Secured from 0x" + Integer.toHexString(start) + " to 0x" + Integer.toHexString(start + length) + " (" + length + " bytes total)");
			}
			
			public static void QNTM(int opcode)
			{
				UtilX32.getProc().quantumLength = (int) (((opcode >> 20) & 1) == 0 ? UtilX32.expandInt(opcode & 0xfffff, 20) : UtilX32.getProc().getRegisterForMode(opcode & 0xf));
				
				UtilX32.printDebug("Updated quantum length to " + UtilX32.getProc().quantumLength + (((opcode >> 20) & 1) == 1 ? " (r" + (opcode & 0xf) + ")" : ""));
			}
			
			public static void GQTM(int opcode)
			{
				UtilX32.getProc().setRegisterForMode(opcode & 0xf, UtilX32.getProc().quantumLength);
				
				UtilX32.printDebug("r" + (opcode & 0xf) + " <- " + UtilX32.getProc().quantumLength);
			}
			
			public static void B(int opcode)
			{
				UtilX32.getProc().setRegisterForMode(15, UtilX32.getProc().getRegisterForMode(15) + UtilX32.expandInt(opcode & 0x1fffff, 21) - 4);
				
				UtilX32.printDebug("Jumped " + UtilX32.expandInt(opcode & 0x1fffff, 21) + " bytes away and ended up at 0x" + Long.toHexString(UtilX32.getProc().getRegisterForMode(15)));
			}
			
			public static void BL(int opcode)
			{
				UtilX32.getProc().setRegisterForMode(14, UtilX32.getProc().getRegisterForMode(15));
				UtilX32.getProc().setRegisterForMode(15, UtilX32.getProc().getRegisterForMode(15) + UtilX32.expandInt(opcode & 0x1fffff, 21) - 4);
				
				UtilX32.printDebug("Jumped " + UtilX32.expandInt(opcode & 0x1fffff, 21) + " bytes away and ended up at 0x" + Long.toHexString(UtilX32.getProc().getRegisterForMode(15)) + ", left a link to 0x" + Long.toHexString(UtilX32.getProc().getRegisterForMode(14)));
			}
			
			public static void BX(int opcode)
			{
				int toReturn = (int) UtilX32.getProc().getRegisterForMode(15);
				UtilX32.getProc().setRegisterForMode(15, UtilX32.getProc().getRegisterForMode(opcode & 0xf) - 4);
				//Util.getProc().setRegisterForMode(15, Util.getProc().getRegisterForMode(15) + Util.expandInt(opcode & 0x7ffff, 17) - 4);
				UtilX32.getProc().setRegisterForMode(14, toReturn);
				
				UtilX32.printDebug("Jumped to " + UtilX32.getProc().getRegisterForMode(15) + ", left a link to 0x" + Long.toHexString(UtilX32.getProc().getRegisterForMode(14)) + ", switched mode to " + UtilX32.getProc().currentMode.name());
				
				UtilX32.getProc().currentMode = Mode.getModeForID((opcode >> 17) & 0xf);
			}
			
			public static void STR(int opcode)
			{
				int base = (int) UtilX32.getProc().getRegisterForMode((opcode >> 17) & 0xf), toSet = (int) UtilX32.getProc().getRegisterForMode((opcode >> 13) & 0xf), offset = UtilX32.expandInt(opcode & 0x1fff, 13);
				
				UtilX32.getProc().setMemoryRange(base + offset, UtilX32.toBytes(toSet));
				
				UtilX32.printDebug("Stored 0x" + Integer.toHexString(toSet) + " (r" + ((opcode >> 13) & 0xf) + ") to address 0x" + Integer.toHexString(base + offset));
			}
			
			public static void LDR(int opcode)
			{
				int base = (int) UtilX32.getProc().getRegisterForMode((opcode >> 17) & 0xf), toSet = (opcode >> 13) & 0xf, offset = UtilX32.expandInt(opcode & 0x1fff, 13);
				
				UtilX32.getProc().setRegisterForMode(toSet, UtilX32.fromBytes(UtilX32.getProc().getMemoryRange(base + offset, 4)));
				
				UtilX32.printDebug("Loaded 0x" + Integer.toHexString((int) UtilX32.getProc().getRegisterForMode(toSet)) + " to r" + toSet +" from address 0x" + Integer.toHexString(base + offset));
			}
			
			public static void STRB(int opcode)
			{
				int base = (int) UtilX32.getProc().getRegisterForMode((opcode >> 17) & 0xf), toSet = (int) (UtilX32.getProc().getRegisterForMode((opcode >> 13) & 0xf) & 0xff), offset = UtilX32.expandInt(opcode & 0x1fff, 13);
				
				UtilX32.getProc().setMemory(base + offset, (byte) toSet);
				
				UtilX32.printDebug("Stored 0x" + Integer.toHexString(toSet) + " (r" + ((opcode >> 13) & 0xf) + ") to address 0x" + Integer.toHexString(base + offset));
			}
			
			public static void LDRB(int opcode)
			{
				int base = (int) UtilX32.getProc().getRegisterForMode((opcode >> 17) & 0xf), toSet = (opcode >> 13) & 0xf, offset = UtilX32.expandInt(opcode & 0x1fff, 13);
				
				UtilX32.getProc().setRegisterForMode(toSet, UtilX32.getProc().getMemory(base + offset));
				
				UtilX32.printDebug("Loaded 0x" + Integer.toHexString((int) UtilX32.getProc().getRegisterForMode(toSet)) + " to r" + toSet +" from address 0x" + Integer.toHexString(base + offset));
			}
			
			public static void SWP(int opcode)
			{
				int base = (int) UtilX32.getProc().getRegisterForMode((opcode >> 17) & 0xf), toSet = (opcode >> 13) & 0xf, offset = UtilX32.expandInt(opcode & 0x1fff, 13), oldVal = (int) UtilX32.getProc().getRegisterForMode(toSet);
				
				UtilX32.getProc().setRegisterForMode(toSet, UtilX32.fromBytes(UtilX32.getProc().getMemoryRange(base + offset, 4)));
				UtilX32.getProc().setMemoryRange(base + offset, UtilX32.toBytes(oldVal));
				
				UtilX32.printDebug("Swapped 0x" + Integer.toHexString(oldVal) + " (r" + toSet + ") with address 0x" + Integer.toHexString(base + offset));
			}
			
			public static void SWPB(int opcode)
			{
				int base = (int) UtilX32.getProc().getRegisterForMode((opcode >> 17) & 0xf), toSet = (opcode >> 13) & 0xf, offset = UtilX32.expandInt(opcode & 0x1fff, 13), oldVal = (int) (UtilX32.getProc().getRegisterForMode(toSet) & 0xf);
				
				UtilX32.getProc().setRegisterForMode(toSet, UtilX32.getProc().getMemory(base + offset));
				UtilX32.getProc().setMemory(base + offset, (byte) oldVal);
				
				UtilX32.printDebug("Swapped 0x" + Integer.toHexString(oldVal) + " (r" + toSet + ") with address 0x" + Integer.toHexString(base + offset));
			}
			
			public static void MUL(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int[] values = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) * values[2]);
				UtilX32.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") * " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void DIV(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int[] values = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) / values[2]);
				UtilX32.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") / " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void SVC(int opcode)
			{
				UtilX32.getProc().interrupt(opcode & 0xff, false);
				
				UtilX32.printDebug("Called interrupt " + (opcode & 0xff));
			}
			
			public static void CLR(int opcode)
			{
				GameUtil.queueClear();
				UtilX32.printDebug("Queued screen clear");
			}
			
			private static boolean fill = false;
			
			public static void DRAW(int opcode)
			{
				fill = false;
				
				UtilX32.printDebug("Set mode to draw");
			}
			
			public static void FILL(int opcode)
			{
				fill = true;
				
				UtilX32.printDebug("Set mode to fill");
			}
			
			public static void RECT(int opcode)
			{
				int x = (int) UtilX32.getProc().getRegisterForMode(opcode & 0xf), y = (int) UtilX32.getProc().getRegisterForMode((opcode >> 4) & 0xf), w = (int) UtilX32.getProc().getRegisterForMode((opcode >> 8) & 0xf), h = (int) UtilX32.getProc().getRegisterForMode((opcode >> 12) & 0xf);
				
				UtilX32.printDebug("x:" + x + " y:" + y + " w:" + w + " h:" + h);
				
				try {
					GameUtil.renderQueue.add(new RenderAction<Graphics>(Graphics.class.getDeclaredMethod((fill ? "fill" : "draw") + "Rect", float.class, float.class, float.class, float.class), GLComplex.getContainer().getGraphics(), true, x, y, w, h));
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
			}
			
			public static void OVL(int opcode)
			{
				int x = (int) UtilX32.getProc().getRegisterForMode(opcode & 0xf), y = (int) UtilX32.getProc().getRegisterForMode((opcode >> 4) & 0xf), w = (int) UtilX32.getProc().getRegisterForMode((opcode >> 8) & 0xf), h = (int) UtilX32.getProc().getRegisterForMode((opcode >> 12) & 0xf);
				
				UtilX32.printDebug("x:" + x + " y:" + y + " w:" + w + " h:" + h);
				
				try {
					GameUtil.renderQueue.add(new RenderAction<Graphics>(Graphics.class.getDeclaredMethod((fill ? "fill" : "draw") + "Oval", float.class, float.class, float.class, float.class), GLComplex.getContainer().getGraphics(), true, x, y, w, h));
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
			}
			
			public static void COLOR(int opcode)
			{
				int value = (int) UtilX32.getProc().getRegisterForMode(opcode & 0xf);
				Color toSet = new Color((value >> 24) & 0xff, (value >> 16) & 0xff, (value >> 8) & 0xff, (value >> 0) & 0xff);
				
				UtilX32.printDebug("Set color to (" + toSet.r + ", " + toSet.g + ", " + toSet.b + ", " + toSet.a + ") (r" + (opcode & 0xf) + ")"); 
				
				try {
					GameUtil.renderQueue.add(new RenderAction<Graphics>(Graphics.class.getDeclaredMethod("setColor", Color.class), GLComplex.getContainer().getGraphics(), true, toSet));
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
			}
			
			public static void GCOLOR(int opcode)
			{
				UtilX32.getProc().setRegisterForMode(opcode & 0xf, (GLComplex.getContainer().getGraphics().getColor().getRedByte() << 24) | (GLComplex.getContainer().getGraphics().getColor().getGreenByte() << 16) | (GLComplex.getContainer().getGraphics().getColor().getBlueByte() << 8) | (GLComplex.getContainer().getGraphics().getColor().getAlphaByte() << 0));
				
				UtilX32.printDebug("Color pulled at (" + GLComplex.getContainer().getGraphics().getColor().getRed() + ", " + GLComplex.getContainer().getGraphics().getColor().getGreen() + ", " + GLComplex.getContainer().getGraphics().getColor().getBlue() + ") -> r" + (opcode & 0xf));
			}
			
			public static void TEXT(int opcode)
			{
				float x = UtilX32.getProc().getRegisterForMode(opcode & 0xf), y = UtilX32.getProc().getRegisterForMode((opcode >> 4) & 0xf), off = UtilX32.getProc().getRegisterForMode((opcode >> 8) & 0xf);
				
				byte[] textBytes = {};
				
				byte[] oldBytes = textBytes;
				textBytes = new byte[textBytes.length + 1];
				System.arraycopy(oldBytes, 0, textBytes, 0, oldBytes.length);
				textBytes[oldBytes.length] = UtilX32.getProc().getMemory((int) (off + oldBytes.length));
				
				while(textBytes[textBytes.length - 1] != 0)
				{
					oldBytes = textBytes;
					textBytes = new byte[textBytes.length + 1];
					System.arraycopy(oldBytes, 0, textBytes, 0, oldBytes.length);
					textBytes[oldBytes.length] = UtilX32.getProc().getMemory((int) (off + oldBytes.length));
				}
				
				UtilX32.printDebug("Displayed string \"" + new String(textBytes).substring(0, textBytes.length - 1) + "\" at " + x + " (r" + (opcode & 0xf) +"), " + y + " (r" + ((opcode >> 4) & 0xf) + ") from address 0x" + Integer.toHexString((int) off) + " (r" + ((opcode >> 8) & 0xf) + ")");
				
				try {
					GameUtil.renderQueue.add(new RenderAction<Graphics>(Graphics.class.getDeclaredMethod("drawString", String.class, float.class, float.class), GLComplex.getContainer().getGraphics(), true, new String(textBytes, "UTF-8").replace((char) 13, '\n'), x, y));
				} catch (NoSuchMethodException | SecurityException | UnsupportedEncodingException e) {
					e.printStackTrace();
				}
			}
			
			public static void MOUSE(int opcode)
			{
				UtilX32.getProc().setRegisterForMode(opcode & 0xf, Mouse.getX());
				UtilX32.getProc().setRegisterForMode((opcode >> 4) & 0xf, MouseUtil.getY());
				
				UtilX32.printDebug("r" + (opcode & 0xf) + " <- " + UtilX32.getProc().getRegisterForMode(opcode & 0xf) + " r" + ((opcode >> 4) & 0xf) + " <- " + UtilX32.getProc().getRegisterForMode((opcode >> 4) & 0xf));
			}
			
			public static void ROT(int opcode)
			{
				int x = (int) UtilX32.getProc().getRegisterForMode(opcode & 0xf), y = (int) UtilX32.getProc().getRegisterForMode((opcode >> 4) & 0xf), o = (int) UtilX32.getProc().getRegisterForMode((opcode >> 8) & 0xf);
				
				GameUtil.setRotate(x, y, o);
				
				UtilX32.printDebug("Set mode to draw");
			}
			
			public static void SCR(int opcode)
			{
				UtilX32.getProc().setRegisterForMode(opcode & 0xf, GraphicsUtil.getScreenWidth());
				UtilX32.getProc().setRegisterForMode((opcode >> 4) & 0xf, GraphicsUtil.getScreenHeight());
				
				UtilX32.printDebug("[r" + (opcode & 0xf) +  ", r" + ((opcode >> 4) & 0xf) + "] <- [" + GraphicsUtil.getScreenWidth() + ", " + GraphicsUtil.getScreenHeight() + "]");
			}
			
			public static void BLK(int opcode)
			{
				GameUtil.block(true);
				
				UtilX32.printDebug("Blocked rendering");
			}
			
			public static void UBLK(int opcode)
			{
				GameUtil.block(false);
				
				UtilX32.printDebug("Unblocked rendering");
			}
			
			public static void EOR(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int[] values = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) ^ values[2]);
				UtilX32.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") ^ " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void SUB(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int[] values = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) - values[2]);
				UtilX32.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") - " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void RSB(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int[] values = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], values[2] - proc.getRegisterForMode(values[1]));
				UtilX32.printDebug("r" + values[0] + " <- " + values[2] + " - " + op1 + " (r" + values[1] + ") = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void ADD(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int[] values = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) + values[2]);
				UtilX32.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") + " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void TST(int opcode)
			{
				int[] ops = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) UtilX32.getProc().getRegisterForMode(ops[1]);
				
				UtilX32.printDebug(op1 + " & " + ops[2] + " = " + (op1 & ops[2]));
				
				op1 &= ops[2];
				UtilX32.setCPSR(op1 < 0, op1 == 0, false, false);
			}
			
			public static void TEQ(int opcode)
			{
				int[] ops = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) UtilX32.getProc().getRegisterForMode(ops[1]);
				
				UtilX32.printDebug(op1 + " ^ " + ops[2] + " = " + (op1 & ops[2]));
				
				op1 ^= ops[2];
				UtilX32.setCPSR(op1 < 0, op1 == 0, false, false);
			}
			
			public static void CMP(int opcode)
			{
				int[] ops = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) UtilX32.getProc().getRegisterForMode(ops[0]);
				
				UtilX32.printDebug(op1 + " (r" + ops[0] + ") - " + ops[2] + " = " + (op1 - ops[2]));
				
				op1 -= ops[2];
				UtilX32.setCPSR(op1 < 0, op1 == 0, false, false);
			}
			
			public static void CMN(int opcode)
			{
				int[] ops = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) UtilX32.getProc().getRegisterForMode(ops[1]);
				
				UtilX32.printDebug(op1 + " + " + ops[2] + " = " + (op1 & ops[2]));
				
				op1 += ops[2];
				UtilX32.setCPSR(op1 < 0, op1 == 0, false, false);
			}
			
			public static void ORR(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int[] values = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) | values[2]);
				UtilX32.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") | " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void MOV(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int[] values = UtilX32.expandStandardOpcode(opcode);
				
				proc.setRegisterForMode(values[0], values[2]);
				UtilX32.printDebug("r" + values[0] + " <- " + values[2]);
			}
			
			public static void BIC(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int[] values = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) & ~values[2]);
				UtilX32.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") & " + ~values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void MVN(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int[] values = UtilX32.expandStandardOpcode(opcode);
				
				proc.setRegisterForMode(values[0], ~values[2]);
				UtilX32.printDebug("r" + values[0] + " <- " + ~values[2]);
			}
			
			public static void AND(int opcode)
			{
				APPLETONx64 proc = UtilX32.getProc();
				int[] values = UtilX32.expandStandardOpcode(opcode);
				int op1 = (int) proc.getRegisterForMode(values[1]);
				
				proc.setRegisterForMode(values[0], proc.getRegisterForMode(values[1]) & values[2]);
				UtilX32.printDebug("r" + values[0] + " <- " + op1 + " (r" + values[1] + ") & " + values[2] + " = " + proc.getRegisterForMode(values[0]));
			}
			
			public static void MVX(int opcode)
			{
				int value = (int) UtilX32.getProc().getRegisterForMode((opcode >> 8) & 0xf), mode = (opcode >> 4) & 0xf;
				
				Mode.getModeForID(mode).setRegister(UtilX32.getProc(), opcode & 0xf, value);
				UtilX32.printDebug("Moved " + value + " (r" + ((opcode >> 8) & 0xf) + ") to " + Mode.getModeForID(mode).name() + "'s r" + (opcode & 0xf));
			}
			
			public static void SND(int opcode)
			{
				int ip = (int) UtilX32.getProc().getRegisterForMode(opcode & 0xf), start = (int) UtilX32.getProc().getRegisterForMode((opcode >> 4) & 0xf), length = (int) UtilX32.getProc().getRegisterForMode((opcode >> 8) & 0xf);
				
				UtilX32.printDebug("Sent " + length + " bytes of data from 0x" + Integer.toHexString(start) + " to " + NetworkCore.getAddress(ip));
				
				UtilX32.getProc().sendNetworkData(UtilX32.getProc().getMemoryRange(start, length), ip);
			}
			
			public static void RCV(int opcode)
			{
				int start = (int) UtilX32.getProc().getRegisterForMode((opcode >> 4) & 0xf), length = (int) UtilX32.getProc().getRegisterForMode((opcode >> 0) & 0xf);
				
				UtilX32.getProc().setMemoryRange(start, UtilX32.getProc().popNetworkData(length));
				
				UtilX32.printDebug("Recieved " + length + " bytes of data into 0x" + Integer.toHexString(start));
			}
			
			public static void SIZ(int opcode)
			{
				UtilX32.getProc().setRegisterForMode(opcode & 0xf, UtilX32.getProc().networkBufferSize());
				
				UtilX32.printDebug("r" + (opcode & 0xf) + " <- " + UtilX32.getProc().getRegisterForMode(opcode & 0xf));
			}
			
			public static void DMP(int opcode)
			{
				UtilX32.getProc().clearNetworkBuffer();
				
				UtilX32.printDebug("Cleared network buffer");
			}
			
			public static void IP(int opcode)
			{
				UtilX32.getProc().setRegisterForMode(opcode & 0xf, UtilX32.getProc().getAddress());
				
				UtilX32.printDebug("r" + (opcode & 0xf) + " <- " + NetworkCore.getAddress(UtilX32.getProc().getAddress()));
			}
		}
		
		public static class AssemblyX32
		{
			public static int LSL(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int LSR(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int ASR(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int DSTR(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= UtilX32.parseInt(data.split(" ")[0]) << 16;
				toReturn |= UtilX32.parseInt(data.split(" ")[1]) << 12;
				toReturn |= UtilX32.parseInt(data.split(" ")[2]) << 8;
				toReturn |= data.split(" ")[3].startsWith("#") ? UtilX32.compressInt(UtilX32.parseInt(data.split(" ")[3]), 12) | (1 << 20) : UtilX32.parseInt(data.split(" ")[3]);
				
				return toReturn;
			}
			
			public static int DLDR(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= UtilX32.parseInt(data.split(" ")[0]) << 16;
				toReturn |= UtilX32.parseInt(data.split(" ")[1]) << 12;
				toReturn |= UtilX32.parseInt(data.split(" ")[2]) << 8;
				toReturn |= data.split(" ")[3].startsWith("#") ? (UtilX32.parseInt(data.split(" ")[3]) & 0xf) | (1 << 20) : UtilX32.parseInt(data.split(" ")[3]);
				return toReturn;
			}
			
			public static int CTD(String data)
			{
				data = data.toLowerCase().replace("r", "");
				
				return UtilX32.parseInt(data);
			}
			
			public static int CPM(String data)
			{
				data = data.toLowerCase().replace("r", "");
				
				return UtilX32.parseInt(data) & 0xf;
			}
			
			public static int HLT(String data)
			{
				return 0;
			}
			
			public static int PUSH(String data)
			{
				data = data.toLowerCase().replace("r", "");
				
				return UtilX32.parseInt(data) & 0xf;
			}
			
			public static int POP(String data)
			{
				data = data.toLowerCase().replace("r", "");
				
				return UtilX32.parseInt(data) & 0xf;
			}
			
			public static int SEC(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= UtilX32.parseInt(data.split(" ")[0]) << 16;
				toReturn |= UtilX32.parseInt(data.split(" ")[1]) << 12;
				toReturn |= data.split(" ")[2].startsWith("#") ? UtilX32.compressInt(UtilX32.parseInt(data.split(" ")[2]), 12) | (1 << 20) : UtilX32.parseInt(data.split(" ")[2]);
				
				return toReturn;
			}
			
			public static int QNTM(String data)
			{
				data = data.toLowerCase().replace("r", "");
				
				return UtilX32.parseInt(data) & 0xf;
			}
			
			public static int GQTM(String data)
			{
				data = data.toLowerCase().replace("r", "");
				
				return UtilX32.parseInt(data) & 0xf;
			}
			
			public static int B(String data)
			{
				return UtilX32.compressInt(UtilX32.parseInt(data), 21) & 0x1fffff;
			}
			
			public static int BL(String data)
			{
				return UtilX32.compressInt(UtilX32.parseInt(data), 21) & 0x1fffff;
			}
			
			public static int BX(String data)
			{
				return UtilX32.compressInt(UtilX32.parseInt(data.split(" ")[0]), 17) | ((UtilX32.parseInt(data.split(" ")[1]) & 0xf) << 17);
			}
			
			public static int STR(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= UtilX32.parseInt(data.split(" ")[0]) << 17;
				toReturn |= UtilX32.parseInt(data.split(" ")[1]) << 13;
				toReturn |= UtilX32.compressInt(UtilX32.parseInt(data.split(" ")[2]), 17);
				
				return toReturn;
			}
			
			public static int LDR(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= UtilX32.parseInt(data.split(" ")[0]) << 17;
				toReturn |= UtilX32.parseInt(data.split(" ")[1]) << 13;
				toReturn |= UtilX32.compressInt(UtilX32.parseInt(data.split(" ")[2]), 13);
				
				return toReturn;
			}
			
			public static int STRB(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= UtilX32.parseInt(data.split(" ")[0]) << 17;
				toReturn |= UtilX32.parseInt(data.split(" ")[1]) << 13;
				toReturn |= UtilX32.compressInt(UtilX32.parseInt(data.split(" ")[2]), 17);
				
				return toReturn;
			}
			
			public static int LDRB(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= UtilX32.parseInt(data.split(" ")[0]) << 17;
				toReturn |= UtilX32.parseInt(data.split(" ")[1]) << 13;
				toReturn |= UtilX32.compressInt(UtilX32.parseInt(data.split(" ")[2]), 17);
				
				return toReturn;
			}
			
			public static int SWP(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= UtilX32.parseInt(data.split(" ")[0]) << 17;
				toReturn |= UtilX32.parseInt(data.split(" ")[1]) << 13;
				toReturn |= UtilX32.compressInt(UtilX32.parseInt(data.split(" ")[2]), 17);
				
				return toReturn;
			}
			
			public static int SWPB(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= UtilX32.parseInt(data.split(" ")[0]) << 17;
				toReturn |= UtilX32.parseInt(data.split(" ")[1]) << 13;
				toReturn |= UtilX32.compressInt(UtilX32.parseInt(data.split(" ")[2]), 17);
				
				return toReturn;
			}
			
			public static int MUL(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int DIV(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int SVC(String data)
			{
				data.toLowerCase().replace("#", "");
				return UtilX32.compressInt(UtilX32.parseInt(data), 21);
			}
			
			public static int CLR(String data)
			{
				return 0;
			}
			
			public static int DRAW(String data)
			{
				return 0;
			}
			
			public static int FILL(String data)
			{
				return 0;
			}
			
			public static int RECT(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return UtilX32.parseInt(data.split(" ")[0]) | (UtilX32.parseInt(data.split(" ")[1]) << 4) | (UtilX32.parseInt(data.split(" ")[2]) << 8) | (Integer.parseInt(data.split(" ")[3]) << 12);
			}
			
			public static int OVL(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return UtilX32.parseInt(data.split(" ")[0]) | (UtilX32.parseInt(data.split(" ")[1]) << 4) | (UtilX32.parseInt(data.split(" ")[2]) << 8) | (Integer.parseInt(data.split(" ")[3]) << 12);
			}
			
			public static int COLOR(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return UtilX32.parseInt(data);
			}
			
			public static int GCOLOR(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return UtilX32.parseInt(data);
			}
			
			public static int TEXT(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return UtilX32.parseInt(data.split(" ")[0]) | (Integer.parseInt(data.split(" ")[1]) << 4) | (Integer.parseInt(data.split(" ")[2]) << 8);
			}
			
			public static int MOUSE(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return UtilX32.parseInt(data.split(" ")[0]) | (UtilX32.parseInt(data.split(" ")[1]) << 4);
			}
			
			public static int ROT(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return UtilX32.parseInt(data);
			}
			
			public static int SCR(String data)
			{
				data = data.toLowerCase().replace("r", "");
				return UtilX32.parseInt(data.split(" ")[0]) | (UtilX32.parseInt(data.split(" ")[0]) << 4);
			}
			
			public static int BLK(String data)
			{
				return 0;
			}
			
			public static int UBLK(String data)
			{
				return 0;
			}
			
			public static int EOR(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int SUB(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int RSB(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int ADD(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int TST(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int TEQ(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int CMP(String data)
			{
				String[] strgs = data.split(" ");
				int[] args = {UtilX32.parseInt(strgs[0]), 0, UtilX32.parseInt(strgs[1])};
				
				int toReturn = 0;
				
				toReturn |= (args[0] & 0xf) << 16;
				toReturn |= (args[1] & 0xf) << 12;
				
				if(strgs[1].startsWith("#"))
				{
					toReturn |= UtilX32.compressInt(args[2], 11);
				}
				else
				{
					toReturn |= 1 << 20;
					toReturn |= args[2] & 0xf;
				}
				
				return toReturn & 0x1fffff;
			}
			
			public static int CMN(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int ORR(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int MOV(String data)
			{
				String[] strgs = data.split(" ");
				int[] args = {UtilX32.parseInt(strgs[0]), 0, UtilX32.parseInt(strgs[1])};
				
				int toReturn = 0;
				
				toReturn |= (args[0] & 0xf) << 16;
				toReturn |= (args[1] & 0xf) << 12;
				
				if(strgs[1].startsWith("#"))
				{
					toReturn |= UtilX32.compressInt(args[2], 12);
				}
				else
				{
					toReturn |= 1 << 20;
					toReturn |= args[2] & 0xf;
				}
				
				return toReturn & 0x1fffff;
			}
			
			public static int BIC(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int MVN(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int AND(String data)
			{
				return UtilX32.compactStandardOpcode(data);
			}
			
			public static int MVX(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= UtilX32.parseInt(data.split(" ")[0]) << 8;
				toReturn |= UtilX32.parseInt(data.split(" ")[1]) & 0xf;
				toReturn |= (UtilX32.parseInt(data.split(" ")[2]) & 0xf) << 4;
				
				return toReturn;
			}
			
			public static int SND(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= UtilX32.parseInt(data.split(" ")[2]) << 8;
				toReturn |= UtilX32.parseInt(data.split(" ")[1]) << 4;
				toReturn |= UtilX32.parseInt(data.split(" ")[0]) << 0;
				
				return toReturn;
			}
			
			public static int RCV(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= UtilX32.parseInt(data.split(" ")[0]) << 4;
				toReturn |= UtilX32.parseInt(data.split(" ")[1]) << 0;
				
				return toReturn;
			}
			
			public static int SIZ(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= UtilX32.parseInt(data.split(" ")[0]) << 0;
				
				return toReturn;
			}
			
			public static int DMP(String data)
			{
				return 0;
			}
			
			public static int IP(String data)
			{
				int toReturn = 0;
				data = data.toLowerCase().replace("r", "");
				
				toReturn |= UtilX32.parseInt(data.split(" ")[0]) << 0;
				
				return toReturn;
			}
		}
	
		public static class ExecutionX64
		{
			public static void FMOV(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0];
				boolean imm = (boolean) data[2];
				
				if(imm)
					UtilX32.getProc().setFloatRegisterForMode(reg, Float.intBitsToFloat((int) data[3]));
				else
					UtilX32.getProc().setFloatRegisterForMode(reg, UtilX32.getProc().getFloatRegisterForMode((int) data[3]));
				
				UtilX64.printDebug("f" + reg + " <- " + UtilX32.getProc().getFloatRegisterForMode(reg) + (!imm ? "(f" + data[3] + ")" : ""));
			}
			
			public static void FSUB(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				float result = UtilX32.getProc().getFloatRegisterForMode(arg1) - (imm ? Float.intBitsToFloat((int) data[3]) : UtilX32.getProc().getFloatRegisterForMode((int) data[3]));
				
				UtilX64.printDebug("f" + reg + " <- " + UtilX32.getProc().getFloatRegisterForMode(arg1) + " (f" + arg1 + ") - " + (imm ? Float.intBitsToFloat((int) data[3]) : UtilX32.getProc().getFloatRegisterForMode((int) data[3]) + " (f" + data[3] + ")") + " = " + result);
				
				UtilX32.getProc().setFloatRegisterForMode(reg, result);
			}
			
			public static void FRSB(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				float result = imm ? Float.intBitsToFloat((int) data[3]) - UtilX32.getProc().getFloatRegisterForMode(arg1) : UtilX32.getProc().getFloatRegisterForMode((int) data[3]) - UtilX32.getProc().getFloatRegisterForMode(arg1);
				
				UtilX64.printDebug("f" + reg + " <- " + (imm ? Float.intBitsToFloat((int) data[3]) : UtilX32.getProc().getFloatRegisterForMode((int) data[3]) + " (f" + data[3] + ")") + " - " + UtilX32.getProc().getFloatRegisterForMode(arg1) + " (f" + arg1 + ")" + " = " + result);
			
				UtilX32.getProc().setFloatRegisterForMode(reg, result);
			}
			
			public static void FADD(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				float result = UtilX32.getProc().getFloatRegisterForMode(arg1) + (imm ? Float.intBitsToFloat((int) data[3]) : UtilX32.getProc().getFloatRegisterForMode((int) data[3]));
				
				UtilX64.printDebug("f" + reg + " <- " + UtilX32.getProc().getFloatRegisterForMode(arg1) + " (f" + arg1 + ") + " + (imm ? Float.intBitsToFloat((int) data[3]) : UtilX32.getProc().getFloatRegisterForMode((int) data[3]) + " (f" + data[3] + ")") + " = " + result);
				
				UtilX32.getProc().setFloatRegisterForMode(reg, result);
			}
			
			public static void FMUL(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				float result = UtilX32.getProc().getFloatRegisterForMode(arg1) * (imm ? Float.intBitsToFloat((int) data[3]) : UtilX32.getProc().getFloatRegisterForMode((int) data[3]));
				
				UtilX64.printDebug("f" + reg + " <- " + UtilX32.getProc().getFloatRegisterForMode(arg1) + " (f" + arg1 + ") * " + (imm ? Float.intBitsToFloat((int) data[3]) : UtilX32.getProc().getFloatRegisterForMode((int) data[3]) + " (f" + data[3] + ")") + " = " + result);
				
				UtilX32.getProc().setFloatRegisterForMode(reg, result);
			}
			
			public static void FDIV(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				float result = UtilX32.getProc().getFloatRegisterForMode(arg1) / (imm ? Float.intBitsToFloat((int) data[3]) : UtilX32.getProc().getFloatRegisterForMode((int) data[3]));
				
				UtilX64.printDebug("f" + reg + " <- " + UtilX32.getProc().getFloatRegisterForMode(arg1) + " (f" + arg1 + ") / " + (imm ? Float.intBitsToFloat((int) data[3]) : UtilX32.getProc().getFloatRegisterForMode((int) data[3]) + " (f" + data[3] + ")") + " = " + result);
				
				UtilX32.getProc().setFloatRegisterForMode(reg, result);
			}
			
			public static void EOR(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(arg1) ^ (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug("r" + reg + "<- " + UtilX32.getProc().getRegisterForMode(arg1) + " (r" + arg1 + ") ^ " + (imm ? (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
				
				UtilX32.getProc().setRegisterForMode(reg, result);
			}
			
			public static void SUB(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(arg1) - (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug("r" + reg + "<- " + UtilX32.getProc().getRegisterForMode(arg1) + " (r" + arg1 + ") - " + (imm ? (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
			
				UtilX32.getProc().setRegisterForMode(reg, result);
			}
			
			public static void RSB(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				long result = (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3])) - UtilX32.getProc().getRegisterForMode(arg1);
				
				UtilX64.printDebug("r" + reg + "<- " + (imm ? (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " - " + UtilX32.getProc().getRegisterForMode(arg1) + " (r" + arg1 + ") = " + result);
			
				UtilX32.getProc().setRegisterForMode(reg, result);
			}
			
			public static void ADD(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(arg1) - (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug("r" + reg + "<- " + UtilX32.getProc().getRegisterForMode(arg1) + " (r" + arg1 + ") - " + (imm ? (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
			
				UtilX32.getProc().setRegisterForMode(reg, result);
			}
			
			public static void TST(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(reg) & (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug(UtilX32.getProc().getRegisterForMode(reg) + " (r" + reg + ") & " + (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
			
				UtilX32.setCPSR(result < 0, result == 0, false, false);
			}
			
			public static void TEQ(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(reg) ^ (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug(UtilX32.getProc().getRegisterForMode(reg) + " (r" + reg + ") ^ " + (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
			
				UtilX32.setCPSR(result < 0, result == 0, false, false);
			}
			
			public static void CMP(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(reg) - (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug(UtilX32.getProc().getRegisterForMode(reg) + " (r" + reg + ") - " + (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
			
				UtilX32.setCPSR(result < 0, result == 0, false, false);
			}
			
			public static void CMN(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(reg) + (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug(UtilX32.getProc().getRegisterForMode(reg) + " (r" + reg + ") + " + (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
			
				UtilX32.setCPSR(result < 0, result == 0, false, false);
			}
			
			public static void ORR(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(arg1) | (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug("r" + reg + "<- " + UtilX32.getProc().getRegisterForMode(arg1) + " (r" + arg1 + ") | " + (imm ? (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
			
				UtilX32.getProc().setRegisterForMode(reg, result);
			}
			
			public static void MOV(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0];
				boolean imm = (boolean) data[2];
				
				UtilX32.getProc().setRegisterForMode(reg, imm ? (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug("r" + reg + " <- " + UtilX32.getProc().getRegisterForMode(reg) + (!imm ? " (r" + data[3] + ")" : ""));
			}
			
			public static void BIC(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(arg1) & ~(imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug("r" + reg + "<- " + UtilX32.getProc().getRegisterForMode(arg1) + " (r" + arg1 + ") & ~" + (imm ? (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
			
				UtilX32.getProc().setRegisterForMode(reg, result);
			}
			
			public static void MVN(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0];
				boolean imm = (boolean) data[2];
				
				UtilX32.getProc().setRegisterForMode(reg, ~(imm ? (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3])));
				
				UtilX64.printDebug("r" + reg + " <- " + UtilX32.getProc().getRegisterForMode(reg) + (!imm ? " (r" + data[3] + ")" : ""));
			}
			
			public static void AND(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(arg1) & (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug("r" + reg + "<- " + UtilX32.getProc().getRegisterForMode(arg1) + " (r" + arg1 + ") & " + (imm ? (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
			
				UtilX32.getProc().setRegisterForMode(reg, result);
			}
			
			public static void MVX(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				Mode mode = Mode.getModeForID((int) data[3]);
				
				mode.setRegister(UtilX32.getProc(), reg, UtilX32.getProc().getRegisterForMode(arg1));
				
				UtilX64.printDebug("r" + reg + " (" + mode.name() + ") <- " + Mode.getModeForID((int) data[3]).getRegister(UtilX32.getProc(), reg) + " (r" + arg1 + ")");
			}
			
			public static void LSL(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(arg1) << (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug("r" + reg + "<- " + UtilX32.getProc().getRegisterForMode(arg1) + " (r" + arg1 + ") << " + (imm ? (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
			
				UtilX32.getProc().setRegisterForMode(reg, result);
			}
			
			public static void LSR(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(arg1) >> (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug("r" + reg + "<- " + UtilX32.getProc().getRegisterForMode(arg1) + " (r" + arg1 + ") >> " + (imm ? (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
			
				UtilX32.getProc().setRegisterForMode(reg, result);
			}
			
			public static void ASR(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(arg1) >>> (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug("r" + reg + "<- " + UtilX32.getProc().getRegisterForMode(arg1) + " (r" + arg1 + ") >>> " + (imm ? (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
			
				UtilX32.getProc().setRegisterForMode(reg, result);
			}
			
			public static void MUL(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(arg1) * (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug("r" + reg + "<- " + UtilX32.getProc().getRegisterForMode(arg1) + " (r" + arg1 + ") * " + (imm ? (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
			
				UtilX32.getProc().setRegisterForMode(reg, result);
			}
			
			public static void DIV(long instruction)
			{
				Object[] data = UtilX64.extractStandardOpcode(instruction);
				int reg = (int) data[0], arg1 = (int) data[1];
				boolean imm = (boolean) data[2];
				
				long result = UtilX32.getProc().getRegisterForMode(arg1) / (imm ?  (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]));
				
				UtilX64.printDebug("r" + reg + "<- " + UtilX32.getProc().getRegisterForMode(arg1) + " (r" + arg1 + ") / " + (imm ? (long)((int) data[3]) : UtilX32.getProc().getRegisterForMode((int)data[3]) + " (r" + data[3] + ")") + " = " + result);
			
				UtilX32.getProc().setRegisterForMode(reg, result);
			}
		}		
		public static class AssemblyX64
		{
			public static long FMOV(String data)
			{
				String[] strArgs = data.replaceAll(",| ", " ").split(" ");
				return UtilX64.compactStandardOpcode(new int[]{UtilX32.parseInt(strArgs[0]), 0, strArgs[1].startsWith("#") ? Float.floatToRawIntBits(Float.parseFloat(strArgs[1].replace("#", ""))) : UtilX32.parseInt(strArgs[1])}, strArgs[1].startsWith("#"));
			}
			
			public static long FSUB(String data)
			{
				return UtilX64.compactStandardFloatOp(data);
			}
			
			public static long FRSB(String data)
			{
				return UtilX64.compactStandardFloatOp(data);
			}
			
			public static long FADD(String data)
			{
				return UtilX64.compactStandardFloatOp(data);
			}
			
			public static long FMUL(String data)
			{
				return UtilX64.compactStandardFloatOp(data);
			}
			
			public static long FDIV(String data)
			{
				return UtilX64.compactStandardFloatOp(data);
			}
			
			public static long EOR(String data)
			{
				return UtilX64.compactStandardOpcode(data);
			}
			
			public static long SUB(String data)
			{
				return UtilX64.compactStandardOpcode(data);
			}
			
			public static long RSB(String data)
			{
				return UtilX64.compactStandardOpcode(data);
			}
			
			public static long ADD(String data)
			{
				return UtilX64.compactStandardOpcode(data);
			}
			
			public static long TST(String data)
			{
				return UtilX64.compactTwoArgOpcode(data);
			}
			
			public static long TEQ(String data)
			{
				return UtilX64.compactTwoArgOpcode(data);
			}
			
			public static long CMP(String data)
			{
				return UtilX64.compactTwoArgOpcode(data);
			}
			
			public static long CMN(String data)
			{
				return UtilX64.compactTwoArgOpcode(data);
			}
			
			public static long ORR(String data)
			{
				return UtilX64.compactStandardOpcode(data);
			}
			
			public static long MOV(String data)
			{
				return UtilX64.compactTwoArgOpcode(data);
			}
			
			public static long BIC(String data)
			{
				return UtilX64.compactStandardOpcode(data);
			}
			
			public static long MVN(String data)
			{
				return UtilX64.compactTwoArgOpcode(data);
			}
			
			public static long AND(String data)
			{
				return UtilX64.compactStandardOpcode(data);
			}
			
			public static long MVX(String data)
			{
				return UtilX64.compactStandardOpcode(data);
			}
			
			public static long LSL(String data)
			{
				return UtilX64.compactStandardOpcode(data);
			}
			
			public static long LSR(String data)
			{
				return UtilX64.compactStandardOpcode(data);
			}
			
			public static long ASR(String data)
			{
				return UtilX64.compactStandardOpcode(data);
			}
			
			public static long MUL(String data)
			{
				return UtilX64.compactStandardOpcode(data);
			}
			
			public static long DIV(String data)
			{
				return UtilX64.compactStandardOpcode(data);
			}
		}
	}
	
	public static class UtilX64
	{
		public static byte[] toBytes(long value)
		{
			return ByteBuffer.allocate(8).putLong(value).array();
		}
		
		public static long fromBytes(byte[] data)
		{
			return ((ByteBuffer) ByteBuffer.allocate(8).put(data).flip()).getLong();
		}
		
		public static void printDebug(String message)
		{
			if(Abraxas.getKey("--trace"))
			{
				String instruction = Thread.currentThread().getStackTrace()[2].getMethodName();
				System.out.println("[" + UtilX32.getProc().getName() + " : x64 : " + instruction + "] " + message);
			}
		}
		
		public static Object[] extractStandardOpcode(long data)
		{
			return new Object[]{(int) ((data >> 48) & 0xf), (int) ((data >> 44) & 0xf), ((data >> 52) & 1l) == 1, (int)(data & (((data >> 52) & 1l) == 1 ? 0xffffffffl : 0xf))};
		}
		
		public static long compactStandardOpcode(String data)
		{
			data = data.replaceAll(",| ", " ");
			
			long finalCode = 0;
			String[] strArgs = data.split(" ");
			int[] regArgs = {UtilX64.parseInt(strArgs[0]), UtilX64.parseInt(strArgs[1])};
			
			finalCode |= (long)(regArgs[0] & 0xf) << 48;
			finalCode |= (long)(regArgs[1] & 0xf) << 44;
			
			if(strArgs[2].startsWith("#"))
			{
				finalCode |= 1l << 52;
				finalCode |= ((long)UtilX64.parseInt(strArgs[2])) & 0xffffffffl;
			}else
				finalCode |= UtilX32.parseInt(strArgs[2]) & 0xf;
			
			return finalCode;
		}
		
		public static long compactStandardOpcode(int[] args, boolean imm)
		{
			long finalCode = 0;
			int[] regArgs = {args[0], args[1]};
			
			finalCode |= (long)(regArgs[0] & 0xf) << 48;
			finalCode |= (long)(regArgs[1] & 0xf) << 44;
			
			if(imm)
			{
				finalCode |= 1l << 52;
				finalCode |= ((long)args[2]) & 0xffffffffl;
			}else
				finalCode |= args[2] & 0xf;
			
			return finalCode;
		}
		
		public static long compactStandardFloatOp(String data)
		{
			String[] strArgs = data.replaceAll(",| ", " ").split(" ");
			return UtilX64.compactStandardOpcode(new int[]{UtilX64.parseInt(strArgs[0]), UtilX64.parseInt(strArgs[1]), strArgs[2].startsWith("#") ? Float.floatToRawIntBits(Float.parseFloat(strArgs[2].replace("#", ""))) : UtilX64.parseInt(strArgs[2])}, strArgs[2].startsWith("#"));
		}
		
		public static long compactTwoArgOpcode(String data)
		{
			String[] strArgs = data.replaceAll(",| ", " ").split(" ");
			return UtilX64.compactStandardOpcode(new int[]{UtilX64.parseInt(strArgs[0]), 0, UtilX64.parseInt(strArgs[1])}, strArgs[1].startsWith("#"));
		}
		
		public static int parseInt(String data)
		{
			data = data.toUpperCase().replace("#", "").replace("[", "").replace("]", "").replace("R", "");
			
			if(data.startsWith("0X"))
				return (int) Long.parseLong(data.replace("0X", ""), 16);
			if(data.startsWith("0B"))
				return (int) Long.parseLong(data.replace("0B", ""), 2);
			return (int) Long.parseLong(data);
		}
	}
	
	public static class UtilX32
	{
		public static int compressInt(int value, int numBits)
		{
			int toReturn = 0;
			
			int tmpMask = 0;
			
			for(int loop = 0; loop < numBits; loop++)
				tmpMask |= 0xF << loop;
			
			if(value < 0)
				toReturn |= ((value & tmpMask) ) | (1 << numBits);
			else
				toReturn |= value & ~(1 << numBits);
			
			return toReturn;
		}
		
		public static int expandInt(int value, int numBits)
		{
			int toReturn = 0, tmpMask = 0;
			
			for(int loop = 0; loop < numBits; loop++)
				tmpMask |= 0b1 << loop;
			
			toReturn = value & tmpMask;
			if(((toReturn & (1 << (numBits - 1))) >> (numBits - 1)) == 0b1)
			{
				toReturn |= ~tmpMask;
				toReturn = ~toReturn;
				toReturn += 1;
				toReturn = -toReturn;
			}
			
			return toReturn;
		}
		
		public static int fromBytes(byte[] bytes)
		{
			int toReturn = 0;
			int tmpInt = bytes[0] & 0b1111_1111;
			toReturn |= tmpInt;
			toReturn <<= 8;
			tmpInt = bytes[1] & 0b1111_1111;
			toReturn |= tmpInt;
			toReturn <<= 8;
			tmpInt = bytes[2] & 0b1111_1111;
			toReturn |= tmpInt;
			toReturn <<= 8;
			tmpInt = bytes[3] & 0b1111_1111;
			toReturn |= tmpInt;
			
			return toReturn;
		}
		
		public static byte[] toBytes(int value)
		{
			byte[] toReturn = new byte[4];
			
			toReturn[0] = (byte) ((value & 0b1111_1111_0000_0000_0000_0000_0000_0000) >> 24);
			toReturn[1] = (byte) ((value & 0b1111_1111_0000_0000_0000_0000) >> 16);
			toReturn[2] = (byte) ((value & 0b1111_1111_0000_0000) >> 8);
			toReturn[3] = (byte) ((value & 0b1111_1111));
			
			return toReturn;
		}
		
		public static int[] expandStandardOpcode(int instruction)
		{
			APPLETONx64 proc = getProc();
			int[] toReturn = new int[3];
			
			toReturn[0] = (instruction >> 16) & 0xf;
			toReturn[1] = (instruction >> 12) & 0xf;
			toReturn[2] = (int) ((((instruction >> 20) & 1) == 1) ? proc.getRegisterForMode((instruction >> 0) & 0xf) : expandInt(((instruction >> 0) & 0x7ff), 11));
			
			return toReturn;
		}
		
		public static int compactStandardOpcode(String data)
		{
			String[] strgs = data.split(" ");
			int[] args = {parseInt(strgs[0]), parseInt(strgs[1]), parseInt(strgs[2])};
			
			int toReturn = 0;
			
			toReturn |= (args[0] & 0xf) << 16;
			toReturn |= (args[1] & 0xf) << 12;
			
			if(strgs[2].startsWith("#"))
			{
				toReturn |= compressInt(args[2], 12);
			}
			else
			{
				toReturn |= 1 << 20;
				toReturn |= args[2] & 0xf;
			}
			
			return toReturn & 0x1fffff;
		}
		
		public static APPLETONx64 getProc()
		{
			return getEngine(APPLETONx64.class);
		}
		
		public static void printDebug(String message)
		{
			if(Abraxas.getKey("--trace"))
			{
				String instruction = Thread.currentThread().getStackTrace()[2].getMethodName();
				System.out.println("[" + UtilX32.getProc().getName() + " : x32 : " + instruction + "] " + message);
			}
		}
		
		public static void forceDebug(String message)
		{
			String instruction = Thread.currentThread().getStackTrace()[2].getMethodName();
			System.out.println("[" + UtilX32.getProc().getName() + " : " + instruction + "] " + message);
		}
		
		public static void setCPSR(boolean N, boolean Z, boolean C, boolean V)
		{
			if(N)
				UtilX32.getProc().setRegisterForMode(16, UtilX32.getProc().getRegisterForMode(16) | (0b1 << 31));
			else
				UtilX32.getProc().setRegisterForMode(16, UtilX32.getProc().getRegisterForMode(16) & ~(0b1 << 31));
			if(Z)
				UtilX32.getProc().setRegisterForMode(16, UtilX32.getProc().getRegisterForMode(16) | (0b1 << 30));
			else
				UtilX32.getProc().setRegisterForMode(16, UtilX32.getProc().getRegisterForMode(16) & ~(0b1 << 30));
			if(C)
				UtilX32.getProc().setRegisterForMode(16, UtilX32.getProc().getRegisterForMode(16) | (0b1 << 29));
			else
				UtilX32.getProc().setRegisterForMode(16, UtilX32.getProc().getRegisterForMode(16) & ~(0b1 << 29));
			if(V)
				UtilX32.getProc().setRegisterForMode(16, UtilX32.getProc().getRegisterForMode(16) | (0b1 << 28));
			else
				UtilX32.getProc().setRegisterForMode(16, UtilX32.getProc().getRegisterForMode(16) & ~(0b1 << 28));
		}
		
		public static int parseInt(String data)
		{
			data = data.toUpperCase().replace("#", "").replace("[", "").replace("]", "").replace("R", "");
			
			if(data.startsWith("0X"))
				return Integer.parseInt(data.replace("0X", ""), 16);
			if(data.startsWith("0B"))
				return Integer.parseInt(data.replace("0B", ""), 2);
			return Integer.parseInt(data);
		}
	}
	
	public APPLETONx64()
	{
		
	}
	
	public APPLETONx64(String biosImage, Integer memoryLength, String[] disks)
	{
		this.memory = new HashMap<Integer, Byte>();
		this.security = new HashMap<Integer, Boolean>();
		this.memSize = memoryLength;
		
		for (int i = 0; i < disks.length; i++)
			try {
				if(new File(FileUtil.baseDir + disks[i]).exists())
					this.disks.add(new RandomAccessFile(FileUtil.baseDir + disks[i], "rw"));
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		
		System.err.println("Openned " + this.disks.size() + " disk" + (this.disks.size() != 1 ? "s" : ""));
		
		InputStream bios = FileUtil.getFile(biosImage);
		ByteArrayOutputStream os = new ByteArrayOutputStream();
		MultiplexOutputStream.writeInputToOutput(bios, os, true);
		this.setMemoryRange(0, os.toByteArray());
		
		System.err.println("Read " + os.size() + " bytes of BIOS data");
	}
	
	public APPLETONx64(String biosImage, Integer memoryLength, String[] disks, String ipAddress)
	{
		this.memory = new HashMap<Integer, Byte>();
		this.security = new HashMap<Integer, Boolean>();
		this.memSize = memoryLength;
		
		for (int i = 0; i < disks.length; i++)
			try {
				if(new File(FileUtil.baseDir + disks[i]).exists())
					this.disks.add(new RandomAccessFile(FileUtil.baseDir + disks[i], "rw"));
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		
		System.err.println("Openned " + this.disks.size() + " disk" + (this.disks.size() != 1 ? "s" : ""));
		
		InputStream bios = FileUtil.getFile(biosImage);
		ByteArrayOutputStream os = new ByteArrayOutputStream();
		MultiplexOutputStream.writeInputToOutput(bios, os, true);
		this.setMemoryRange(0, os.toByteArray());
		
		System.err.println("Read " + os.size() + " bytes of BIOS data");
		
		System.err.println("Constructed with address " + (this.address = ipAddress));
	}
	
	public void setMemory(int addr, byte toSet)
	{
		if(addr <= memSize - 1 && addr >= 0)
			if(toSet != 0){
				memory.put(addr, toSet);}
			else if(memory.containsKey(addr))
					memory.remove(addr);
		if(memory.size() > memSize)
			throw new RuntimeException("Memory exceeded maximum size! Limited to " + memSize + ", managed " + memory.size());
	}
	
	public byte getMemory(int addr)
	{
		if(memory.size() > memSize)
			throw new RuntimeException("Memory exceeded maximum size! Limited to " + memSize + ", managed " + memory.size());
		return memory.containsKey(addr) ? memory.get(addr) : 0;
	}
	
	public byte[] getMemoryRange(int start, int length)
	{
		byte[] toReturn = new byte[length];
		
		for (int i = 0; i < toReturn.length; i++)
			toReturn[i] = getMemory(start + i);
		
		return toReturn;
	}
	
	public void setMemoryRange(int start, byte[] data)
	{
		for(byte toSet : data)
			this.setMemory(start++, toSet);
	}
	
	public boolean getSecurity(int addr)
	{
		if(security.size() > memSize)
			throw new RuntimeException("Securty exceeded maximum size! Limited to " + memSize + ", managed " + security.size());
		return security.containsKey(addr) ? security.get(addr) : false;
	}
	
	public void setSecurity(int addr, boolean secure)
	{
		if(addr <= memSize - 1 && addr >= 0)
			if(secure){
				security.put(addr, true);}
			else if(memory.containsKey(addr))
					memory.remove(addr);
		if(security.size() > memSize)
			throw new RuntimeException("Securty exceeded maximum size! Limited to " + memSize + ", managed " + security.size());
	}
	
	public void setSecurityRange(int start, boolean...data)
	{
		for(boolean toSet : data)
			this.setSecurity(start++, toSet);
	}
	
	public void setSecurityRange(int start, int length, boolean data)
	{
		for (int i = 0; i < length; i++)
			this.setSecurity(start++, data);
	}
	
	public long getRegisterForMode(int register)
	{
		return this.currentMode.getRegister(this, register);
	}
	
	public void setRegisterForMode(int register, long value)
	{
		this.currentMode.setRegister(this, register, value);
	}
	
	public float getFloatRegisterForMode(int register)
	{
		return this.currentMode.getFloatRegister(this, register);
	}
	
	public void setFloatRegisterForMode(int register, float value)
	{
		this.currentMode.setFloatRegister(this, register, value);
	}
	
	public void setSuspended(boolean toSet)
	{
		if(toSet)
			this.shouldSuspend = true;
		else
			synchronized (this)
			{
				this.notify();
			}
	}
	
	public boolean isSuspended()
	{
		return shouldSuspend;
	}
	
	public boolean conditionCode(int instruction)
	{
		long cpsr = this.getRegisterForMode(16);
		boolean[] decode = new boolean[]{(cpsr >> 31 & 0b1) == 1, (cpsr >> 30 & 0b1) == 1, (cpsr >> 29 & 0b1) == 1, (cpsr >> 28 & 0b1) == 1};
		
		byte cond = (byte) (instruction >> 28 & 0xF);
		
		final int N = 0, Z = 1, C = 2, V = 3;
		
		switch(cond)
		{
		case 1: //EQ
			return decode[Z];
		case 2: //NE
			return !decode[Z];
		case 3: //CS
			return decode[C];
		case 4: //CC
			return !decode[C];
		case 5: //MI
			return decode[N];
		case 6: //PL
			return !decode[N];
		case 7: //VS
			return decode[V];
		case 8: //VC
			return !decode[V];
		case 9: //HI
			return decode[C] && !decode[Z];
		case 10: //LS
			return !decode[C] || decode[Z];
		case 11: //GE
			return decode[N] == decode[V];
		case 12: //LT
			return decode[N] != decode[V];
		case 13: //GT
			return !decode[Z] && (decode[N] == decode[V]);
		case 14: //LE
			return decode[Z] || (decode[N] != decode[V]);
		case 15: //AL - ignored
			return true;
		default:
			return false;
		}
	}
	
	public String nameConditionCode(int instruction)
	{
		byte cond = (byte) (instruction >> 28 & 0xF);
		
		if(cond > 0)
			return Instructions.cond[cond - 1];
		else
			return "AL";
	}
	
	public int conditionCode(String name)
	{
		switch(name.toUpperCase())
		{
		case "EQ":
			return 1;
		case "NE":
			return 2;
		case "CS":
			return 3;
		case "CC":
			return 4;
		case "MI":
			return 5;
		case "PL":
			return 6;
		case "VS":
			return 7;
		case "VC":
			return 8;
		case "HI":
			return 9;
		case "LS":
			return 10;
		case "GE":
			return 11;
		case "LT":
			return 12;
		case "GT":
			return 13;
		case "LE":
			return 14;
		case "":
		case "AL":
			return 15;
		default:
			return 0;
		}
	}
	
	public Method getInstruction(int code)
	{
		Method toReturn = null;

		code = (code >> 21) & 0x7f;
		
		for(String proc : Instructions.proc32)
		{
			int tmpCode = Integer.parseInt(proc.split("-")[1].replace("_", ""), 2);
			proc = proc.split("-")[0];
			
			if(tmpCode == code)
				try {
					toReturn = Instructions.ExecutionX32.class.getDeclaredMethod(proc, int.class);
					break;
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
		}
		
		return toReturn;
	}
	
	public Method getInstruction64(long code)
	{
		Method toReturn = null;

		code = (code >> 53) & 0x7f;
		
		for(String proc : Instructions.proc64)
		{
			int tmpCode = Integer.parseInt(proc.split("-")[1].replace("_", ""), 2);
			proc = proc.split("-")[0];
			
			if(tmpCode == code)
				try {
					toReturn = Instructions.ExecutionX64.class.getDeclaredMethod(proc, long.class);
					break;
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
		}
		
		return toReturn;
	}
	
	public int getASM32(String data)
	{
		Method toReturn = null;
		
		for(String proc : Instructions.proc32)
		{
			if(proc.split("-")[0].equals(data.split(" ")[0]))
				try {
					toReturn = Instructions.AssemblyX32.class.getDeclaredMethod(data.split(" ")[0], String.class);
					break;
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
		}
		
		try {
			return (int) toReturn.invoke(null, data.split(" ")[0].equals(data) ? "" : data.substring(data.split(" ")[0].length() + 1));
		} catch (IllegalAccessException | IllegalArgumentException
				| InvocationTargetException e) {
			e.printStackTrace();
			return 0;
		}
	}
	
	public long getASM64(String data)
	{
		Method toReturn = null;
		
		for(String proc : Instructions.proc64)
		{
			if(proc.split("-")[0].equals(data.split(" ")[0]))
				try {
					toReturn = Instructions.AssemblyX64.class.getDeclaredMethod(data.split(" ")[0], String.class);
					break;
				} catch (NoSuchMethodException | SecurityException e) {
					e.printStackTrace();
				}
		}
		
		try {
			return (long) toReturn.invoke(null, data.split(" ")[0].equals(data) ? "" : data.substring(data.split(" ")[0].length() + 1));
		} catch (IllegalAccessException | IllegalArgumentException
				| InvocationTargetException e) {
			e.printStackTrace();
			return 0;
		}
	}
	
	public void start(String threadName)
	{
		if(executionThread == null)
			return;
		
		if(executionThread.isAlive())
			return;
		
		executionThread.setName(threadName);
		executionThread.start();
	}
	
	public void execute()
	{
		if(shouldSuspend)
		{
			synchronized (this) {
				try {
					this.wait();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			
			shouldSuspend = false;
		}
		
		if(intID != -1 && this.currentMode != Mode.INTERRUPT && this.currentMode != Mode.ABORT)
		{
			switch(intID)
			{
			case 0:
				this.setRegisterForMode(14, r15);
				Mode.ABORT.setRegister(this, 0, (Integer) intArgs[0]);
				Mode.ABORT.setRegister(this, 14, r15);
				this.setRegisterForMode(15, UtilX32.fromBytes(this.getMemoryRange((int) (this.getRegisterForMode(12) + (intID * 4)), 4)));
				this.currentMode = Mode.ABORT;
				break;
			case 1:
				this.setRegisterForMode(14, r15);
				Mode.INTERRUPT.setRegister(this, 0, (Integer) intArgs[0]);
				Mode.INTERRUPT.setRegister(this, 1, (Integer) intArgs[1]);
				Mode.INTERRUPT.setRegister(this, 14, r15);
				this.setRegisterForMode(15, UtilX32.fromBytes(this.getMemoryRange((int) (this.getRegisterForMode(12) + (intID * 4)), 4)));
				this.currentMode = Mode.INTERRUPT;
				break;
			default:
				this.setRegisterForMode(14, r15);
				Mode.INTERRUPT.setRegister(this, 14, r15);
				this.setRegisterForMode(15, UtilX32.fromBytes(this.getMemoryRange((int) (this.getRegisterForMode(12) + (intID * 4)), 4)));
				this.currentMode = Mode.INTERRUPT;
				break;
			}
			intID = -1;
		}
		
		int instruction = UtilX32.fromBytes(this.getMemoryRange((int) this.getRegisterForMode(15), 4));
		
		if(instruction == 0)
		{
			UtilX32.printDebug("NULL opcode : r15 = " + r15);
			this.interrupt(0, true, 0);
			return;
		}
		
		if (((instruction >> 27) & 1) == 0)
		{
			int cpsr = (int) this.getRegisterForMode(16);
			boolean[] decode = new boolean[]{(cpsr >> 31 & 0b1) == 1, (cpsr >> 30 & 0b1) == 1, (cpsr >> 29 & 0b1) == 1, (cpsr >> 28 & 0b1) == 1};
			if(getInstruction(instruction) != null )
				UtilX32.printDebug("Now attempting " + getInstruction(instruction).getName() + "_" + nameConditionCode(instruction) + " : " + Arrays.toString(decode) + " : " + Integer.toBinaryString(instruction));
			else
			{
				UtilX32.printDebug("Attempting to execute " + Integer.toBinaryString(instruction) + " proved fruitless; it isn't real");
				this.interrupt(0, true, 1);
				return;
			}
			
			if (conditionCode(instruction))
				try {
					Method struct = getInstruction(instruction);
					struct.invoke(null, instruction);
				} catch (IllegalAccessException | IllegalArgumentException
						| InvocationTargetException | NullPointerException e) {
					UtilX32.printDebug("Encountered unreadable data: "
							+ Integer.toBinaryString(instruction));
					e.printStackTrace();
				}
			this.setRegisterForMode(15, this.getRegisterForMode(15) + 4);
		}else
		{
			long data = UtilX64.fromBytes(this.getMemoryRange((int) this.getRegisterForMode(15), 8)) & ~(1l << 59);
			
			int cpsr = (int) this.getRegisterForMode(16);
			boolean[] decode = new boolean[]{(cpsr >> 31 & 0b1) == 1, (cpsr >> 30 & 0b1) == 1, (cpsr >> 29 & 0b1) == 1, (cpsr >> 28 & 0b1) == 1};
			if(getInstruction64(data) != null )
				UtilX64.printDebug("Now attempting " + getInstruction64(data).getName() + "_" + nameConditionCode(instruction) + " : " + Arrays.toString(decode) + " : " + Long.toBinaryString(data));
			else
			{
				UtilX64.printDebug("Attempting to execute " + Integer.toBinaryString(instruction) + " proved fruitless; it isn't real");
				this.interrupt(0, true, 1);
				return;
			}
			
			if (conditionCode(instruction))
				try {
					Method struct = getInstruction64(data);
					struct.invoke(null, data);
				} catch (IllegalAccessException | IllegalArgumentException
						| InvocationTargetException | NullPointerException e) {
					UtilX64.printDebug("Encountered unreadable data: "
							+ Long.toBinaryString(data));
					e.printStackTrace();
				}
			this.setRegisterForMode(15, this.getRegisterForMode(15) + 8);
		}
	}

	public void interrupt(int id, boolean abort, Number... args)
	{
		this.intArgs = args;
		this.intID = id;
	}

	public void terminate()
	{
		this.shouldTerminate = true;
	}
	
	public boolean isTerminated()
	{
		return this.shouldTerminate;
	}

	public boolean checkSanity()
	{
		Instructions.init();
		
		boolean isSane = Instructions.ExecutionX32.class.getDeclaredMethods().length == Instructions.AssemblyX32.class.getDeclaredMethods().length;
		
		for(String item : Instructions.proc32)
			try {
				Instructions.ExecutionX32.class.getDeclaredMethod(item.split("-")[0], int.class);
				Instructions.AssemblyX32.class.getDeclaredMethod(item.split("-")[0], String.class);
			} catch (NoSuchMethodException | SecurityException e) {
				isSane = false;
				System.err.println(item.split("-")[0] + " failed the sanity check in " + (e.getMessage().contains("Assembly") ? "assembly" : "execution"));
			}
		System.err.println("32 bit half " + (isSane ? "passed" : "failed") + " the sanity check");
		
		isSane &= Instructions.ExecutionX64.class.getDeclaredMethods().length == Instructions.AssemblyX64.class.getDeclaredMethods().length;
		
		for(String item : Instructions.proc64)
			try {
				Instructions.ExecutionX64.class.getDeclaredMethod(item.split("-")[0], long.class);
				Instructions.AssemblyX64.class.getDeclaredMethod(item.split("-")[0], String.class);
			} catch (NoSuchMethodException | SecurityException e) {
				isSane = false;
				System.err.println(item.split("-")[0] + " failed the sanity check in " + (e.getMessage().contains("Assembly") ? "assembly" : "execution"));
			}
		System.err.println("64 bit half " + (isSane ? "passed" : "failed") + " the sanity check");
		
		return isSane;
	}
	
	public byte[] assembleLine(String line)
	{
		if (!bits64) //32 Bit
		{
			int finalCode = 0;
			line = line.replace(",", "").replace("\t", "").replace("_", "");
			String[] comp = line.split(" ");
			if (Instructions.proc32 == null)
				this.checkSanity();
			for (String proc : Instructions.proc32) {
				if (proc.split("-")[0].equals(comp[0])) {
					finalCode = 15 << 28;
					finalCode |= Integer.parseInt(proc.split("-")[1].replace("_", ""), 2) << 21;
					finalCode &= ~(1 << 27);
					finalCode |= getASM32(line);
					break;
				} else
					for (String cond : Instructions.cond)
						if (comp[0].equals(proc.split("-")[0] + cond)) {
							finalCode = conditionCode(cond) << 28;
							finalCode |= Integer.parseInt(proc.split("-")[1].replace("_", ""), 2) << 21;
							finalCode &= ~(1 << 27);
							finalCode |= getASM32(line.replace(cond, ""));
						}
			}
			
			return UtilX32.toBytes(finalCode);
		}else //64 Bit
		{
			long finalCode = 0;
			line = line.replace(",", "").replace("\t", "").replace("_", "");
			String[] comp = line.split(" ");
			if (Instructions.proc64 == null)
				this.checkSanity();
			for (String proc : Instructions.proc64) {
				if (proc.split("-")[0].equals(comp[0]))
				{
					finalCode = 15l << 60;
					finalCode |= Long.parseLong(proc.split("-")[1].replace("_", ""), 2) << 53;
					finalCode |= 1l << 59;
					finalCode |= getASM64(line);
					break;
				} else
					for (String cond : Instructions.cond)
						if (comp[0].equals(proc.split("-")[0] + cond)) {
							finalCode = (long)conditionCode(cond) << 60;
							finalCode |= Long.parseLong(proc.split("-")[1].replace("_", ""), 2) << 53;
							finalCode |= 1l << 59;
							finalCode |= getASM64(line.replace(cond, ""));
						}
			}
			
			System.err.println("64 : " + line + " : " + Long.toBinaryString(finalCode));
			
			return UtilX64.toBytes(finalCode);
		}
	}
	
	private boolean bits64;
	
	public int generateCode(String src, OutputStream os) throws IOException
	{
		Scanner in = new Scanner(FileUtil.getFile(src));
		
		HashMap<String, Integer> labelMap = new HashMap<String, Integer>();
		HashMap<String, String> constMap = new HashMap<String, String>();
		
		int off = 0;
		
		while(in.hasNextLine())
		{
			String asmLine = in.nextLine().toUpperCase().trim().replace("\t", "");
			
			if(asmLine.startsWith("BITS64"))
			{
				bits64 = true;
				continue;
			}
			else if(asmLine.startsWith("BITS32"))
			{
				bits64 = false;
				continue;
			}
			
			if(asmLine.startsWith("$ ") && asmLine.endsWith(" $"))
			{
				int pad = Integer.parseInt(asmLine.replace("$ ", "").replace(" $", ""));
				
				off = off <= pad ? pad : off;
				continue;
			}
			
			if(asmLine.startsWith("# ") && asmLine.endsWith(" #"))
			{
				asmLine = asmLine.replace("# ", "").replace(" #", "");
				
				if(asmLine.toLowerCase().endsWith(".asm"))
					off += generateCode(new File(src).getParent() + "/" + asmLine, (OutputStream)null);//assemble(new File(toAssemble.getAbsoluteFile().getParent() + "/" + asmLine), (OutputStream)null);
				else if(asmLine.toLowerCase().endsWith(".bmp"))
					off += GraphicsUtil.countBitmapBytes(asmLine) / 4 + (GraphicsUtil.countBitmapBytes(asmLine) % 4 == 0 ? 0 : 1);
				else
				{
					InputStream is = FileUtil.getFile(asmLine);
					int tmpOff = 0;
					while(is.available() > 0)
					{
						is.read();
						tmpOff++;
					}
					off += tmpOff / 4 + (tmpOff % 4 == 0 ? 0 : 1);
					is.close();
						
				}
				continue;
			}
			
			if(asmLine.startsWith("\"") && asmLine.endsWith("\""))
			{
				asmLine = asmLine.substring(1, asmLine.length() - 1);
				off += asmLine.getBytes().length / 4 + (asmLine.getBytes().length % 4 == 0 ? 0 : 1);
				continue;
			}
			
			if(asmLine.startsWith("0X ") && asmLine.endsWith(" X0"))
			{
				asmLine = asmLine.replace("_", "").replace("0X ", "").replace(" X0", "");
				off += asmLine.split(" ").length / 4 + (asmLine.split(" ").length % 4 == 0 ? 0 : 1);
				continue;
			}
			
			if(asmLine.endsWith(":") && asmLine.startsWith(":"))
			{
				labelMap.put(asmLine.replace(":", ""), off);
				System.err.println("Attatched label " + asmLine + " to address " + off);
			}
			
			if(asmLine.endsWith("?") && asmLine.startsWith("?"))
				constMap.put(asmLine.replace(" ", "").replace("?", "").split("=")[0], asmLine.replace(" ", "").replace("?", "").split("=")[1]);
			
			if(asmLine.startsWith(";") || asmLine.isEmpty() || (asmLine.endsWith(":") & asmLine.startsWith(":")) || (asmLine.endsWith("?") && asmLine.startsWith("?")))
				continue;
			
			off += bits64 ? 2 : 1;
		}
		
		in.close();
		in = new Scanner(FileUtil.getFile(src));
		off = 0;
		
		while(in.hasNextLine())
		{
			String asmLine = in.nextLine().trim().replace("\t", "");
			
			if(asmLine.startsWith("BITS64"))
			{
				bits64 = true;
				continue;
			}
			else if(asmLine.startsWith("BITS32"))
			{
				bits64 = false;
				continue;
			}
			
			if(asmLine.startsWith("$ ") && asmLine.endsWith(" $"))
			{
				int pad = Integer.parseInt(asmLine.replace("$ ", "").replace(" $", ""));
				
				int size = pad - off;
				
				if(off <= pad)
				{
					off = pad;
					if(os != null)
						os.write(new byte[size * 4]);
					System.err.println("Padded up to address " + pad * 4 + " : " + size * 4 + " bytes");
				}
				
				continue;
			}
			
			if(asmLine.startsWith("# ") && asmLine.endsWith(" #"))
			{
				asmLine = asmLine.replace("# ", "").replace(" #", "");
				
				if(asmLine.toLowerCase().endsWith(".asm"))
				{
					System.err.println("Assembled \"" + asmLine + "\" within");
					off += generateCode(new File(src).getParent() + "/" + asmLine, os);//assemble(new File(toAssemble.getAbsoluteFile().getParent() + "/" + asmLine), (OutputStream)null);
				}
				else if(asmLine.toLowerCase().endsWith(".bmp"))
				{
					System.err.println("Compiled bitmap \"" + asmLine + "\" within");
					off += GraphicsUtil.countBitmapBytes(asmLine) / 4 + (GraphicsUtil.countBitmapBytes(asmLine) % 4 == 0 ? 0 : 1);
					GraphicsUtil.genBitmap(asmLine, os);
				}
				else
				{
					System.err.println("Added file \"" + asmLine + "\" within");
					InputStream is = FileUtil.getFile(asmLine);
					int tmpOff = 0;
					while(is.available() > 0)
					{
						os.write(is.read());
						tmpOff++;
					}
					off += tmpOff / 4 + (tmpOff % 4 == 0 ? 0 : 1);
					if(os != null)
						os.write(new byte[4 - (tmpOff % 4)]);
					is.close();
						
				}
				continue;
			}
			
			if(asmLine.startsWith("\"") && asmLine.endsWith("\""))
			{
				asmLine = asmLine.substring(1, asmLine.length() - 1);
				System.err.println("Encoded string \"" + asmLine + "\", length of " + asmLine.getBytes().length + " bytes, overflow of " + ( 4 - (asmLine.getBytes().length % 4)) + " bytes");
				if(os != null)
					os.write(asmLine.getBytes());
				off += asmLine.getBytes().length / 4 + (4 - (asmLine.getBytes().length % 4) == 0 ? 0 : 1);
				
				if(asmLine.getBytes().length % 4 > 0 && os != null)
					os.write(new byte[4 - (asmLine.getBytes().length % 4)]);
				continue;
			}
			
			asmLine = asmLine.toUpperCase().replace("_", "");
			
			if(asmLine.startsWith("0X ") && asmLine.endsWith(" X0"))
			{
				int tmpOff = 0;
				
				asmLine = asmLine.replace("_", "").replace("0X ", "").replace(" X0", "");
				
				for(String unit : asmLine.split(" "))
				{
					if(os != null)
						os.write(Integer.parseInt(unit, 16));
					tmpOff++;
				}
				
				System.err.println("Encoded data 0x " + asmLine + " x0, length of " + tmpOff + " bytes, overflow of " + (4 - (tmpOff % 4)) + " bytes");
				
				if(tmpOff % 4 > 0 && os != null)
					os.write(new byte[4 - (tmpOff % 4)]);
				
				off += tmpOff / 4 + (tmpOff % 4 > 0 ? 1 : 0);
				continue;
			}
			
			if(asmLine.startsWith(";") || asmLine.isEmpty() || (asmLine.endsWith(":") & asmLine.startsWith(":")) || (asmLine.endsWith("?") && asmLine.startsWith("?")))
				continue;
			
			
			for(String label : labelMap.keySet())
			{
				if(asmLine.contains(":" + label + ":"))
				{
					System.out.println("Replaced instance of label " + label);
					asmLine = asmLine.replace(":" + label + ":", ""+ (labelMap.get(label) * 4 - off * 4));
				}
			}
			
			for(String constVal : constMap.keySet())
			{
				if(asmLine.contains(constVal))
				{
					System.out.println("Replaced instance of constant " + constVal);
					asmLine = asmLine.replace(constVal, constMap.get(constVal));
				}
			}
			
			if(os != null)
				os.write(assembleLine(asmLine));
			
			off += bits64 ? 2 : 1;
		}
		
		in.close();
		System.out.println("Assembled " + src + " to APPLETONx64 code inline");
		
		return off;
	}
	
	public void generateCode(String src, String output) throws IOException
	{
		Scanner in = new Scanner(FileUtil.getFile(src));
		FileOutputStream os = new FileOutputStream(new File(FileUtil.baseDir + output));
		
		HashMap<String, Integer> labelMap = new HashMap<String, Integer>();
		HashMap<String, String> constMap = new HashMap<String, String>();
		
		int off = 0;
		
		while(in.hasNextLine())
		{
			String asmLine = in.nextLine().toUpperCase().trim().replace("\t", "");
			
			if(asmLine.startsWith("BITS64"))
			{
				bits64 = true;
				continue;
			}
			else if(asmLine.startsWith("BITS32"))
			{
				bits64 = false;
				continue;
			}
			
			if(asmLine.startsWith("$ ") && asmLine.endsWith(" $"))
			{
				int pad = Integer.parseInt(asmLine.replace("$ ", "").replace(" $", ""));
				
				off = off <= pad ? pad : off;
				continue;
			}
			
			if(asmLine.startsWith("# ") && asmLine.endsWith(" #"))
			{
				asmLine = asmLine.replace("# ", "").replace(" #", "");
				
				if(asmLine.toLowerCase().endsWith(".asm"))
					off += generateCode(new File(src).getParent() + "/" + asmLine, (OutputStream)null);//assemble(new File(toAssemble.getAbsoluteFile().getParent() + "/" + asmLine), (OutputStream)null);
				else if(asmLine.toLowerCase().endsWith(".bmp"))
					off += GraphicsUtil.countBitmapBytes(asmLine) / 4 + (GraphicsUtil.countBitmapBytes(asmLine) % 4 == 0 ? 0 : 1);
				else
				{
					InputStream is = FileUtil.getFile(asmLine);
					int tmpOff = 0;
					while(is.available() > 0)
					{
						is.read();
						tmpOff++;
					}
					off += tmpOff / 4 + (tmpOff % 4 == 0 ? 0 : 1);
					is.close();
						
				}
				continue;
			}
			
			if(asmLine.startsWith("\"") && asmLine.endsWith("\""))
			{
				asmLine = asmLine.substring(1, asmLine.length() - 1);
				off += asmLine.getBytes().length / 4 + (asmLine.getBytes().length % 4 == 0 ? 0 : 1);
				continue;
			}
			
			if(asmLine.startsWith("0X ") && asmLine.endsWith(" X0"))
			{
				asmLine = asmLine.replace("_", "").replace("0X ", "").replace(" X0", "");
				off += asmLine.split(" ").length / 4 + (asmLine.split(" ").length % 4 == 0 ? 0 : 1);
				continue;
			}
			
			if(asmLine.endsWith(":") && asmLine.startsWith(":"))
			{
				labelMap.put(asmLine.replace(":", ""), off);
				System.err.println("Attatched label " + asmLine + " to address " + off);
			}
			
			if(asmLine.endsWith("?") && asmLine.startsWith("?"))
				constMap.put(asmLine.replace(" ", "").replace("?", "").split("=")[0], asmLine.replace(" ", "").replace("?", "").split("=")[1]);
			
			if(asmLine.startsWith(";") || asmLine.isEmpty() || (asmLine.endsWith(":") & asmLine.startsWith(":")) || (asmLine.endsWith("?") && asmLine.startsWith("?")))
				continue;
			
			off += bits64 ? 2 : 1;
		}
		
		in.close();
		in = new Scanner(FileUtil.getFile(src));
		off = 0;
		
		while(in.hasNextLine())
		{
			String asmLine = in.nextLine().trim().replace("\t", "");
			
			if(asmLine.startsWith("BITS64"))
			{
				bits64 = true;
				continue;
			}
			else if(asmLine.startsWith("BITS32"))
			{
				bits64 = false;
				continue;
			}
			
			if(asmLine.startsWith("$ ") && asmLine.endsWith(" $"))
			{
				int pad = Integer.parseInt(asmLine.replace("$ ", "").replace(" $", ""));
				
				int size = pad - off;
				
				if(off <= pad)
				{
					off = pad;
					os.write(new byte[size * 4]);
					System.err.println("Padded up to address " + pad * 4 + " : " + size * 4 + " bytes");
				}
				
				continue;
			}
			
			if(asmLine.startsWith("# ") && asmLine.endsWith(" #"))
			{
				asmLine = asmLine.replace("# ", "").replace(" #", "");
				
				if(asmLine.toLowerCase().endsWith(".asm"))
				{
					System.err.println("Assembled \"" + asmLine + "\" within");
					off += generateCode(new File(src).getParent() + "/" + asmLine, os);//assemble(new File(toAssemble.getAbsoluteFile().getParent() + "/" + asmLine), (OutputStream)null);
				}
				else if(asmLine.toLowerCase().endsWith(".bmp"))
				{
					System.err.println("Compiled bitmap \"" + asmLine + "\" within");
					off += GraphicsUtil.countBitmapBytes(asmLine) / 4 + (GraphicsUtil.countBitmapBytes(asmLine) % 4 == 0 ? 0 : 1);
					GraphicsUtil.genBitmap(asmLine, os);
				}
				else
				{
					System.err.println("Added file \"" + asmLine + "\" within");
					InputStream is = FileUtil.getFile(asmLine);
					int tmpOff = 0;
					while(is.available() > 0)
					{
						os.write(is.read());
						tmpOff++;
					}
					off += tmpOff / 4 + (tmpOff % 4 == 0 ? 0 : 1);
					os.write(new byte[4 - (tmpOff % 4)]);
					is.close();
						
				}
				continue;
			}
			
			if(asmLine.startsWith("\"") && asmLine.endsWith("\""))
			{
				asmLine = asmLine.substring(1, asmLine.length() - 1);
				System.err.println("Encoded string \"" + asmLine + "\", length of " + asmLine.getBytes().length + " bytes, overflow of " + ( 4 - (asmLine.getBytes().length % 4)) + " bytes");
				os.write(asmLine.getBytes());
				off += asmLine.getBytes().length / 4 + (4 - (asmLine.getBytes().length % 4) == 0 ? 0 : 1);
				
				if(asmLine.getBytes().length % 4 > 0)
					os.write(new byte[4 - (asmLine.getBytes().length % 4)]);
				continue;
			}
			
			asmLine = asmLine.toUpperCase().replace("_", "");
			
			if(asmLine.startsWith("0X ") && asmLine.endsWith(" X0"))
			{
				int tmpOff = 0;
				
				asmLine = asmLine.replace("_", "").replace("0X ", "").replace(" X0", "");
				
				for(String unit : asmLine.split(" "))
				{
					os.write(Integer.parseInt(unit, 16));
					tmpOff++;
				}
				
				System.err.println("Encoded data 0x " + asmLine + " x0, length of " + tmpOff + " bytes, overflow of " + (4 - (tmpOff % 4)) + " bytes");
				
				if(tmpOff % 4 > 0)
					os.write(new byte[4 - (tmpOff % 4)]);
				
				off += tmpOff / 4 + (tmpOff % 4 > 0 ? 1 : 0);
				continue;
			}
			
			if(asmLine.startsWith(";") || asmLine.isEmpty() || (asmLine.endsWith(":") & asmLine.startsWith(":")) || (asmLine.endsWith("?") && asmLine.startsWith("?")))
				continue;
			
			
			for(String label : labelMap.keySet())
			{
				if(asmLine.contains(":" + label + ":"))
				{
					System.out.println("Replaced instance of label " + label);
					asmLine = asmLine.replace(":" + label + ":", ""+ (labelMap.get(label) * 4 - off * 4));
				}
			}
			
			for(String constVal : constMap.keySet())
			{
				if(asmLine.contains(constVal))
				{
					System.out.println("Replaced instance of constant " + constVal);
					asmLine = asmLine.replace(constVal, constMap.get(constVal));
				}
			}
			
			
			os.write(assembleLine(asmLine));
			
			off += bits64 ? 2 : 1;
		}
		
		in.close();
		os.close();
		System.out.println("Assembled " + src + " to APPLETONx64 code");
	}
}
