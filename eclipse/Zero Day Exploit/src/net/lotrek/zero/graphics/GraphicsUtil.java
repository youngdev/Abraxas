package net.lotrek.zero.graphics;

import static net.lotrek.zero.ZeroDayExploit.castTo;

import java.awt.GraphicsEnvironment;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.ByteBuffer;
import java.util.Random;
import java.util.Stack;

import javax.imageio.ImageIO;

import net.lotrek.zero.ZeroDayExploit;
import net.lotrek.zero.engine.AsmCore;
import net.lotrek.zero.story.StoryCore;
import net.lotrek.zero.tools.FileUtil;
import net.lotrek.zero.tools.GameUtil;
import net.lotrek.zero.tools.HTTPUtil;
import net.lotrek.zero.tools.MouseUtil;

import org.lwjgl.input.Mouse;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.GL11;
import org.newdawn.slick.Color;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;
import org.newdawn.slick.gui.TextField;

public class GraphicsUtil
{
	public static final Color amber = new Color(255, 191, 0);
	
	public static boolean isTakingScreenshot()
	{
		return takingScreenShot;
	}
	
	public static void fadeInMethod(Method toInvoke, Graphics g, int freq, int alphaMod)
	{
		if(!ZeroDayExploit.getKey("--debug"))
			try {
				
				int alpha = 255;
				int tmp = 0;
				while(alpha >= 0)
				{
					Color tmpColor = g.getColor();
					g.clear();
					toInvoke.invoke(null, GLComplex.getContainer(), g);
					g.setColor(new Color(0, 0, 0, alpha));
					g.fillRect(0, 0, getScreenWidth(), getScreenHeight());
					Display.update();
					if(tmp == freq)
					{
						alpha -= alphaMod;
						tmp = -1;
					}
					tmp++;
					
					g.setColor(tmpColor);
				}
				
			} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e1)
			{
				e1.printStackTrace();
			}
	}
	
	public static void fadeOutMethod(Method toInvoke, Graphics g, int freq, int alphaMod)
	{
		if(!ZeroDayExploit.getKey("--debug"))
			try {
				
				int alpha = 0;
				int tmp = 0;
				while(alpha <= 255)
				{
					Color tmpColor = g.getColor();
					g.clear();
					toInvoke.invoke(null, GLComplex.getContainer(), g);
					g.setColor(new Color(0, 0, 0, alpha));
					g.fillRect(0, 0, getScreenWidth(), getScreenHeight());
					Display.update();
					if(tmp == freq)
					{
						alpha += alphaMod;
						tmp = -1;
					}
					tmp++;
					
					g.setColor(tmpColor);
				}
				
			} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e1)
			{
				e1.printStackTrace();
			}
	}
	
	public static void displayLoadingImageSCRIPT(String imageFile, Graphics g, long delay, int freq)
	{
//		System.out.println("LD_IMG START");
		displayLoadingImage(imageFile, g, delay, freq);
		StoryCore.suspendStory(false);
//		System.out.println("LD_IMG STOP");
	}
	
	public static void displayLoadingImage(String imageFile, Graphics g, long delay, int freq)
	{
		if(!ZeroDayExploit.getKey("--debug"))
		{
			Image ldImage = null;
			try {
				ldImage = new Image(FileUtil.getFile(imageFile), imageFile, false);
				
				int alpha = 255;
				int tmp = 0;
				while(alpha >= 0)
				{
					g.clear();
					g.setColor(new Color(0,0,0,alpha));
					ldImage.drawCentered(getScreenWidth() / 2, getScreenHeight() / 2);
					g.fillRect(0, 0, getScreenWidth(), getScreenHeight());
					Display.update();
					if(tmp == freq)
					{
						alpha--;
						tmp = -1;
					}
					tmp++;
				}
				
			} catch (SlickException e1)
			{
				e1.printStackTrace();
			}
			
			try {
				g.clear();
				ldImage.drawCentered(getScreenWidth() / 2, getScreenHeight() / 2);
				Display.update();
				Thread.sleep(delay);
				Display.update();
				g.clear();
				
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			int alpha = 0;
			int tmp = 0;
			while(alpha <= 255)
			{
				g.clear();
				g.setColor(new Color(0,0,0,alpha));
				ldImage.drawCentered(getScreenWidth() / 2, getScreenHeight() / 2);
				g.fillRect(0, 0, getScreenWidth(), getScreenHeight());
				Display.update();
				if(tmp == freq)
				{
					alpha++;
					tmp = -1;
				}
				tmp++;
			}
		}
	}
	
	public static int getStringWidth(String text)
	{
		return GLComplex.getContainer().getDefaultFont().getWidth(text);
	}
	
	public static int getScreenWidth()
	{
		return GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDisplayMode().getWidth();
	}
	
	public static int getScreenHeight()
	{
		return GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDisplayMode().getHeight();
	}
	
	public static boolean takingScreenShot = false;
	
	public static void takeScreenShot(final int xParam, final int yParam, final int width, final int height, final String file)
	{
		System.out.println("Start screenshot");
		//Creating an rbg array of total pixels
        int[] pixels = new int[width * height * 3];
        // allocate space for RBG pixels
        ByteBuffer fb = ByteBuffer.allocateDirect(width * height * 3);

        // grab a copy of the current frame contents as RGB
        GL11.glReadPixels(xParam, yParam, width, height, GL11.GL_RGB, GL11.GL_UNSIGNED_BYTE, fb);

        BufferedImage imageIn = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        // convert RGB data in ByteBuffer to integer array
        for (int i=0; i < pixels.length; i++) {
            pixels[i] = fb.get(i);
        }
        System.out.println("Made array");
        //Allocate colored pixel to buffered Image
        imageIn.getRaster().setPixels(0, 0, width, height, pixels);
        System.out.println("Wrote pixels");
        
        //Creating the transformation direction (horizontal)
        AffineTransform at =  AffineTransform.getScaleInstance(1, -1);
        at.translate(0, -imageIn.getHeight(null));

        //Applying transformation
        AffineTransformOp opRotated = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);
        final BufferedImage imageOut = opRotated.filter(imageIn, null);

        try {
        	new Thread(){
        		public void run()
        		{
        			this.setName(file);
        			try {
        				GraphicsUtil.takingScreenShot = true;
						ImageIO.write(imageOut, "PNG" , new File(file));
						System.err.println("Saved screenshot to " + file);
						GraphicsUtil.takingScreenShot = false;
					} catch (IOException e) {
						e.printStackTrace();
					}
        		}
        	}.start();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("Thread spawned");
	}
	
	private static int skipLines = 0;
	public static Boolean asm = null;
	
	public static void renderFiles(int x, int y, int width, int height, Graphics g)
	{
		if(MouseUtil.withinBounds(x, x + width, y, y + height))
			skipLines -= GameUtil.DWheel / 60;
		skipLines = skipLines < 0 ? 0 : skipLines;
		
		int origY = y;
		x += 5;
		y += 5;
		
		String[] tmpLines = GameUtil.fileList.split("\n");
		skipLines = skipLines > tmpLines.length - 1 ? tmpLines.length - 1 : skipLines;
		int tmpSkip = 0;
		
		for(String line : tmpLines)
		{
			if(line.trim().isEmpty()){
				line = "No Files Found";
				g.drawString(line.length() > 21 ? line.substring(0, 21) : line, x, y + 20);
				break;
			}
			
			if(tmpSkip++ < skipLines) continue;
			
			if(((TextField)GameUtil.saveSelect.getComponent("FILENAME")).getText().equals(line) && y - origY + GLComplex.getContainer().getDefaultFont().getHeight(line) + 20 < height - 20)
				line += " <-";
			
			if(y - origY + GLComplex.getContainer().getDefaultFont().getHeight(line) + 20 < height - 20)
				g.drawString(line.length() > 21 ? line.substring(0, 21) : line, x, y += 20);
			else
			{
				g.drawString("...", x, y + 20);
				break;
			}
		}
	}
	
	public static void renderMessage(int x, int y, int width, int height, Graphics g)
	{
		castTo(GameUtil.saveSelect.getComponent("FILENAME"), TextField.class).deactivate();
		boolean exists = GameUtil.fileList.contains(castTo(GameUtil.saveSelect.getComponent("FILENAME"), TextField.class).getText() + "\n") || GameUtil.fileList.contains("\n" + castTo(GameUtil.saveSelect.getComponent("FILENAME"), TextField.class).getText());
		String message = exists ? "Ready to resume" : "Ready to create";
		g.drawString(message.length() > 21 ? message.substring(0, 21) : message, x + width / 2 - GLComplex.getContainer().getDefaultFont().getWidth(message.length() > 21 ? message.substring(0, 21) : message) / 2, y + 25);
		message = castTo(GameUtil.saveSelect.getComponent("FILENAME"), TextField.class).getText();
		g.drawString(message.length() > 21 ? message.substring(0, 21) : message, x + width / 2 - GLComplex.getContainer().getDefaultFont().getWidth(message.length() > 21 ? message.substring(0, 21) : message) / 2, y + 40);
		
		g.fillRect(x + 5, y + height - 35, width / 2 - 10, 30);
		
		g.fillRect(x + width - (width / 2 - 10) - 5, y + height - 35, width / 2 - 10, 30);
		
		g.setColor(Color.black);
		message = exists ? "RESUME" : "CREATE";
		g.drawString(message.length() > 21 ? message.substring(0, 21) : message, (x + 5) + (width / 2 - 10) / 2 - GLComplex.getContainer().getDefaultFont().getWidth(message.length() > 21 ? message.substring(0, 21) : message) / 2, (y + height - 35) + 5);
		
		message = "CANCEL";
		g.drawString(message.length() > 21 ? message.substring(0, 21) : message, (x + width - (width / 2 - 10) - 5) + (width / 2 - 10) / 2 - GLComplex.getContainer().getDefaultFont().getWidth(message.length() > 21 ? message.substring(0, 21) : message) / 2, (y + height - 35) + 5);
		
		if(MouseUtil.withinBounds(x + 5, width / 2 - 5 + x, y + height - 35, y + height - 5) && Mouse.isButtonDown(0) && !GameUtil.confirmBox.startDrag && !GameUtil.newsWindow.startDrag && !GameUtil.saveFiles.startDrag && !GameUtil.saveSelect.startDrag)
		{
			GameUtil.confirmBox.visible = false;
			GameUtil.initRuntime(castTo(GameUtil.saveSelect.getComponent("FILENAME"), TextField.class).getText() + ".sav");
		}
		
		if(MouseUtil.withinBounds(x + width - (width / 2 - 10) - 5, x + width - (width / 2 - 10) - 5 + width / 2 - 10, y + height - 35, y + height - 5) && Mouse.isButtonDown(0) && !GameUtil.confirmBox.startDrag && !GameUtil.newsWindow.startDrag && !GameUtil.saveFiles.startDrag && !GameUtil.saveSelect.startDrag)
		{
			GameUtil.confirmBox.visible = false;
		}
	}
	
	public static void renderASM(int x, int y, int width, int height, Graphics g)
	{
		if(asm != null)
		{
			GameUtil.asmWindow.height = 100;
			if(!asm && (!GameUtil.asmWindow.getComponent("inFile").hasFocus() && !GameUtil.asmWindow.getComponent("outFile").hasFocus()))
				g.drawString("Assembly failed", x + 5, y + height - 20);
			else if(asm && (!GameUtil.asmWindow.getComponent("inFile").hasFocus() && !GameUtil.asmWindow.getComponent("outFile").hasFocus()))
				g.drawString("Assembly succeeded", x + 5, y + height - 20);
			else
				asm = null;
		}else
			GameUtil.asmWindow.height = 80;
	}
	
	private static String[] news;
	private static int newsIndex, lastTime;
	
	public static void renderNews(int x, int y, int width, int height, Graphics g)
	{
		if(news == null)
		{
			lastTime = (int) (System.currentTimeMillis() / 1000);
			news = new String[]{"Loading..."};
			//Update the news box
			new Thread()
			{
				public void run()
				{
					news = HTTPUtil.getNews();
				}
			}.start();
		}
		
		g.drawString(news[newsIndex], x + 5, y + 25);
		
		if((int) (System.currentTimeMillis() / 1000) - lastTime == 7)
		{
			newsIndex++;
			if(newsIndex >= news.length)
				newsIndex = 0;
			lastTime = (int) (System.currentTimeMillis() / 1000);
		}
	}
	
	private static class Particle
	{
		public int x, y, XF, YF;
		public boolean far = false;
		public Random rng;
		
		public Particle()
		{
			rng = new Random();
			x = rng.nextInt(GraphicsUtil.getScreenWidth());
			y = rng.nextInt(GraphicsUtil.getScreenHeight());
			boolean negBool = rng.nextBoolean();
			XF = ((negBool ? -1 : 1) * rng.nextInt(6) + (negBool ? -2 : 2)) / 2;
			negBool = rng.nextBoolean();
			YF = ((negBool ? -1 : 1) * rng.nextInt(6) + (negBool ? -2 : 2)) / 2;
			this.far = rng.nextBoolean();
		}
		
		public void render(int deltaX, int deltaY, Graphics g)
		{
			deltaX /= 3;
			deltaY /= 3;
			deltaX *= 2;
			deltaY *= 2;
			
			if(!far)
			{
				g.fillRect(x, y, 5, 5);
				if (deltaX < 100 && deltaY < 100) {
					x += deltaX + XF;
					y -= deltaY - YF;
				}
			}else
			{
				g.fillRect(x, y, 3, 3);
				if (deltaX < 100 && deltaY < 100) {
					x += deltaX / 3 + XF;
					y -= deltaY / 3 - YF;
				}
			}
			
			if(x > getScreenWidth())
				x = 0;
			if(y > getScreenHeight())
				y = 0;
			if(y < 0)
				y = getScreenHeight();
			if(x < 0)
				x = getScreenWidth();
			
			if(!far)
				g.fillRect(x, y, 5, 5);
			else
				g.fillRect(x, y, 3, 3);
		}
	}
	
	private static Stack<Particle> particleList = new Stack<Particle>();
	
	public static void initParticles()
	{
		particleList.clear();
		for(int loop = 0; loop < 100; loop++)
			particleList.push(new Particle());
		System.gc();
	}
	
	public static void renderParticles(int deltaX, int deltaY, Color color, Graphics g)
	{
		g.setColor(color);
		for(Particle item : particleList)
			item.render(deltaX / 2, deltaY / 2, g);
	}
	
	public static void genBitmap(String input, String output)
	{
		try {
			BufferedImage imgIn = ImageIO.read(new File(FileUtil.baseDir + input));
			FileOutputStream imgOut = new FileOutputStream(new File(FileUtil.baseDir + output));
			imgOut.write(AsmCore.toBytes(imgIn.getWidth()));
			imgOut.write(AsmCore.toBytes(imgIn.getHeight()));

			for (int x = 0; x < imgIn.getWidth(); x++)
				for (int y = 0; y < imgIn.getHeight(); y++) {
					byte[] tmpBytes = AsmCore.toBytes(imgIn
							.getRGB(x, y));
					imgOut.write(tmpBytes[2]);
					imgOut.write(tmpBytes[3]);
					imgOut.write(tmpBytes[1]);
				}

			imgOut.close();
			System.err.println("Generated raw bitmap for " + input
					+ ", saved to " + output);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public static void genBitmap(String input, OutputStream output)
	{
		try {
			BufferedImage imgIn = ImageIO.read(new File(FileUtil.baseDir + input));
			output.write(AsmCore.toBytes(imgIn.getWidth()));
			output.write(AsmCore.toBytes(imgIn.getHeight()));

			for (int x = 0; x < imgIn.getWidth(); x++)
				for (int y = 0; y < imgIn.getHeight(); y++) {
					byte[] tmpBytes = AsmCore.toBytes(imgIn
							.getRGB(x, y));
					output.write(tmpBytes[1]);
					output.write(tmpBytes[2]);
					output.write(tmpBytes[3]);
				}

			System.err.println("Generated raw bitmap for " + input);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public static int countBitmapBytes(String input)
	{
		int toReturn = 0;
		try {
			BufferedImage imgIn = ImageIO.read(new File(FileUtil.baseDir + input));
			toReturn += 8;

			for (int x = 0; x < imgIn.getWidth(); x++)
				for (int y = 0; y < imgIn.getHeight(); y++)
					toReturn += 3;
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return toReturn;
	}
	
	public static void genImage(String input, String output)
	{
		try {
			FileInputStream imgIn = new FileInputStream(new File(FileUtil.baseDir + input));
			byte[] w = new byte[4], h = new byte[4];
			imgIn.read(w);
			imgIn.read(h);
			BufferedImage imgOut = new BufferedImage(AsmCore.fromBytes(w), AsmCore.fromBytes(h), BufferedImage.TYPE_3BYTE_BGR);
			
			int x = 0, y = 0;
			for(int off = 0; off < imgOut.getWidth() * imgOut.getHeight(); off++)
			{
				byte[] b = new byte[3];
				imgIn.read(b);
				byte[] b2 = new byte[b.length + 1];
				System.arraycopy(b, 0, b2, 1, b.length);
				b2[0] = 0;
				imgOut.setRGB(x, y, AsmCore.fromBytes(b2) | 0b1111_1111_0000_0000_0000_0000_0000_0000);
				y++;
				if(y >= imgOut.getHeight())
				{
					y = 0;
					x++;
				}
			}
			
			imgIn.close();
			ImageIO.write(imgOut, output.split("\\.")[1].toUpperCase(), new File(FileUtil.baseDir + output));
			System.err.println("Generated image for " + output + ", saved to " + output);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}