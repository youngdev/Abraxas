;Orion multitasking module

;Constants
	? USER = #0b1000 ?
	? FIQ = #0b0100 ?
	? SUPERVISOR = #0b0010 ?
	? ABORT = #0b0001 ?
	? IRQ = #0b1001 ?
	? SYSTEM = #0b0011 ?
	
	B #:start:
	
;Data
	;256 byte process table
	;Structure: 4-byte address : 4-byte permission set : 4-byte stack pointer : 4-byte exec address
	:procTable:
	;Current process : process count (Control header)
	0x 00 00 00 00 00 00 00 00 x0
	0x 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 x0
	0x 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 x0
	0x 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 x0
	0x 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 x0
;Code
:start:
	;Set the quantum interrupt (SVC #2) to :quantum:
	ADD r0, r15, #:quantum:
	STR r12, r0, #8
	;Set SVC #3 to exec interrupt
	ADD r0, r15, #:exec:
	STR r12, r0, #12
	
	;Temporary usage of the disk load interrupt, for testing
	ADD r0, r15, #:loadStr:
	PUSH r0
	ADD r0, r15, #:exec:
	PUSH r0
	SVC #4
	POP r1
	CMP r1, #1
	HLT_NE
	ADD r0, r0, #32
	MOV r15, r0
	
:loadStr:
	"netTest"
:quantum:
	;Disable quantum state
	QNTM #0
	
	;Store the return pointer
	ADD r0, r15, #:procTable:
	;Load the current process id
	LDR r0, r1, #0
	;Get the relative table address
	MUL r1, r1, #16
	;Position relative to the table start
	ADD r1, r0, r1
	;Store the return address, compensating for the control header
	STR r1, r14, #20
	
	;Privledged access to user registers
	CPM SYSTEM
	;Store all the registers to the user's stack
	PUSH r0
	PUSH r1
	PUSH r2
	PUSH r3
	PUSH r4
	PUSH r5
	PUSH r6
	PUSH r7
	PUSH r8
	PUSH r9
	PUSH r10
	PUSH r11
	;Skip r12, r13
	PUSH r14
	
	;Store the stack pointer
	ADD r0, r15, #:procTable:
	;Load the current process id
	LDR r0, r1, #0
	;Get the relative table address
	MUL r1, r1, #16
	;Position relative to the table start
	ADD r1, r0, r1
	;Store the stack pointer, compensating for the control header
	STR r1, r13, #16
	MOV r0, #0
	MOV r1, #0
	
	ADD r0, r15, #:procTable:
	;Load the current process id, increasing it at the same time
	LDR r0, r1, #0
	ADD r1, r1, #1
	STR r0, r1, #0
	
	LDR r0, r2, #4
	CMP r1, r2
	;Fix id if it exceeds the counter
	MOV_EQ r1, #0
	STR_EQ r0, r1, #0
	;Get the relative table address
	MUL r1, r1, #16
	;Position relative to the table start
	ADD r1, r0, r1
	;load the stack pointer, compensating for the control header
	LDR r1, r13, #16
	
	POP r14
	POP r11
	POP r10
	POP r9
	POP r8
	POP r7
	POP r6
	POP r5
	POP r4
	POP r3
	POP r2
	POP r1
	POP r0
	
	CPM IRQ
	
	;Load the return pointer
	ADD r0, r15, #:procTable:
	;Load the current process id
	LDR r0, r1, #0
	;Get the relative table address
	MUL r1, r1, #16
	;Position relative to the table start
	ADD r1, r0, r1
	;Load the return address, compensating for the control header
	LDR r1, r14, #20
	
	BX r14, USER
	
:exec: